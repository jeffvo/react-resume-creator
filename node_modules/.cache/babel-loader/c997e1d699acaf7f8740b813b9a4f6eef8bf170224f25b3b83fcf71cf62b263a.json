{"ast":null,"code":"var charCodeDef = require('./char-code-definitions');\nvar isDigit = charCodeDef.isDigit;\nvar isHexDigit = charCodeDef.isHexDigit;\nvar isUppercaseLetter = charCodeDef.isUppercaseLetter;\nvar isName = charCodeDef.isName;\nvar isWhiteSpace = charCodeDef.isWhiteSpace;\nvar isValidEscape = charCodeDef.isValidEscape;\nfunction getCharCode(source, offset) {\n  return offset < source.length ? source.charCodeAt(offset) : 0;\n}\nfunction getNewlineLength(source, offset, code) {\n  if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n    return 2;\n  }\n  return 1;\n}\nfunction cmpChar(testStr, offset, referenceCode) {\n  var code = testStr.charCodeAt(offset);\n\n  // code.toLowerCase() for A..Z\n  if (isUppercaseLetter(code)) {\n    code = code | 32;\n  }\n  return code === referenceCode;\n}\nfunction cmpStr(testStr, start, end, referenceStr) {\n  if (end - start !== referenceStr.length) {\n    return false;\n  }\n  if (start < 0 || end > testStr.length) {\n    return false;\n  }\n  for (var i = start; i < end; i++) {\n    var testCode = testStr.charCodeAt(i);\n    var referenceCode = referenceStr.charCodeAt(i - start);\n\n    // testCode.toLowerCase() for A..Z\n    if (isUppercaseLetter(testCode)) {\n      testCode = testCode | 32;\n    }\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction findWhiteSpaceStart(source, offset) {\n  for (; offset >= 0; offset--) {\n    if (!isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset + 1;\n}\nfunction findWhiteSpaceEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset;\n}\nfunction findDecimalNumberEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!isDigit(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nfunction consumeEscaped(source, offset) {\n  // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n  // that the next input code point has already been verified to be part of a valid escape.\n  offset += 2;\n\n  // hex digit\n  if (isHexDigit(getCharCode(source, offset - 1))) {\n    // Consume as many hex digits as possible, but no more than 5.\n    // Note that this means 1-6 hex digits have been consumed in total.\n    for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n      if (!isHexDigit(getCharCode(source, offset))) {\n        break;\n      }\n    }\n\n    // If the next input code point is whitespace, consume it as well.\n    var code = getCharCode(source, offset);\n    if (isWhiteSpace(code)) {\n      offset += getNewlineLength(source, offset, code);\n    }\n  }\n  return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nfunction consumeName(source, offset) {\n  // Let result initially be an empty string.\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    var code = source.charCodeAt(offset);\n\n    // name code point\n    if (isName(code)) {\n      // Append the code point to result.\n      continue;\n    }\n\n    // the stream starts with a valid escape\n    if (isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point. Append the returned code point to result.\n      offset = consumeEscaped(source, offset) - 1;\n      continue;\n    }\n\n    // anything else\n    // Reconsume the current input code point. Return result.\n    break;\n  }\n  return offset;\n}\n\n// §4.3.12. Consume a number\nfunction consumeNumber(source, offset) {\n  var code = source.charCodeAt(offset);\n\n  // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n  // consume it and append it to repr.\n  if (code === 0x002B || code === 0x002D) {\n    code = source.charCodeAt(offset += 1);\n  }\n\n  // 3. While the next input code point is a digit, consume it and append it to repr.\n  if (isDigit(code)) {\n    offset = findDecimalNumberEnd(source, offset + 1);\n    code = source.charCodeAt(offset);\n  }\n\n  // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n  if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n    // 4.1 Consume them.\n    // 4.2 Append them to repr.\n    code = source.charCodeAt(offset += 2);\n\n    // 4.3 Set type to \"number\".\n    // TODO\n\n    // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n    offset = findDecimalNumberEnd(source, offset);\n  }\n\n  // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n  if (cmpChar(source, offset, 101 /* e */)) {\n    var sign = 0;\n    code = source.charCodeAt(offset + 1);\n\n    // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n    if (code === 0x002D || code === 0x002B) {\n      sign = 1;\n      code = source.charCodeAt(offset + 2);\n    }\n\n    // ... followed by a digit\n    if (isDigit(code)) {\n      // 5.1 Consume them.\n      // 5.2 Append them to repr.\n\n      // 5.3 Set type to \"number\".\n      // TODO\n\n      // 5.4 While the next input code point is a digit, consume it and append it to repr.\n      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n    }\n  }\n  return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nfunction consumeBadUrlRemnants(source, offset) {\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    var code = source.charCodeAt(offset);\n\n    // U+0029 RIGHT PARENTHESIS ())\n    // EOF\n    if (code === 0x0029) {\n      // Return.\n      offset++;\n      break;\n    }\n    if (isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point.\n      // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n      // without ending the <bad-url-token>. This is otherwise identical to\n      // the \"anything else\" clause.\n      offset = consumeEscaped(source, offset);\n    }\n  }\n  return offset;\n}\nmodule.exports = {\n  consumeEscaped: consumeEscaped,\n  consumeName: consumeName,\n  consumeNumber: consumeNumber,\n  consumeBadUrlRemnants: consumeBadUrlRemnants,\n  cmpChar: cmpChar,\n  cmpStr: cmpStr,\n  getNewlineLength: getNewlineLength,\n  findWhiteSpaceStart: findWhiteSpaceStart,\n  findWhiteSpaceEnd: findWhiteSpaceEnd\n};","map":{"version":3,"names":["charCodeDef","require","isDigit","isHexDigit","isUppercaseLetter","isName","isWhiteSpace","isValidEscape","getCharCode","source","offset","length","charCodeAt","getNewlineLength","code","cmpChar","testStr","referenceCode","cmpStr","start","end","referenceStr","i","testCode","findWhiteSpaceStart","findWhiteSpaceEnd","findDecimalNumberEnd","consumeEscaped","maxOffset","Math","min","consumeName","consumeNumber","sign","consumeBadUrlRemnants","module","exports"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/tokenizer/utils.js"],"sourcesContent":["var charCodeDef = require('./char-code-definitions');\nvar isDigit = charCodeDef.isDigit;\nvar isHexDigit = charCodeDef.isHexDigit;\nvar isUppercaseLetter = charCodeDef.isUppercaseLetter;\nvar isName = charCodeDef.isName;\nvar isWhiteSpace = charCodeDef.isWhiteSpace;\nvar isValidEscape = charCodeDef.isValidEscape;\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nfunction getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nfunction cmpChar(testStr, offset, referenceCode) {\n    var code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nfunction cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (var i = start; i < end; i++) {\n        var testCode = testStr.charCodeAt(i);\n        var referenceCode = referenceStr.charCodeAt(i - start);\n\n        // testCode.toLowerCase() for A..Z\n        if (isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nfunction findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nfunction findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nfunction consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        var code = getCharCode(source, offset);\n        if (isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nfunction consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        var code = source.charCodeAt(offset);\n\n        // name code point\n        if (isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// §4.3.12. Consume a number\nfunction consumeNumber(source, offset) {\n    var code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        code = source.charCodeAt(offset += 2);\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        var sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nfunction consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        var code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\nmodule.exports = {\n    consumeEscaped: consumeEscaped,\n    consumeName: consumeName,\n    consumeNumber: consumeNumber,\n    consumeBadUrlRemnants: consumeBadUrlRemnants,\n\n    cmpChar: cmpChar,\n    cmpStr: cmpStr,\n\n    getNewlineLength: getNewlineLength,\n    findWhiteSpaceStart: findWhiteSpaceStart,\n    findWhiteSpaceEnd: findWhiteSpaceEnd\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}