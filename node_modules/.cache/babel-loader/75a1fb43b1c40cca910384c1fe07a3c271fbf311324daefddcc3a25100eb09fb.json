{"ast":null,"code":"var constants = require('../tokenizer/const');\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar utils = require('../tokenizer/utils');\nvar cmpStr = utils.cmpStr;\nvar EOF = TYPE.EOF;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\nvar TokenStream = function () {\n  this.offsetAndType = null;\n  this.balance = null;\n  this.reset();\n};\nTokenStream.prototype = {\n  reset: function () {\n    this.eof = false;\n    this.tokenIndex = -1;\n    this.tokenType = 0;\n    this.tokenStart = this.firstCharOffset;\n    this.tokenEnd = this.firstCharOffset;\n  },\n  lookupType: function (offset) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset] >> TYPE_SHIFT;\n    }\n    return EOF;\n  },\n  lookupOffset: function (offset) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset - 1] & OFFSET_MASK;\n    }\n    return this.source.length;\n  },\n  lookupValue: function (offset, referenceStr) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);\n    }\n    return false;\n  },\n  getTokenStart: function (tokenIndex) {\n    if (tokenIndex === this.tokenIndex) {\n      return this.tokenStart;\n    }\n    if (tokenIndex > 0) {\n      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n    }\n    return this.firstCharOffset;\n  },\n  // TODO: -> skipUntilBalanced\n  getRawLength: function (startToken, mode) {\n    var cursor = startToken;\n    var balanceEnd;\n    var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n    var type;\n    loop: for (; cursor < this.tokenCount; cursor++) {\n      balanceEnd = this.balance[cursor];\n\n      // stop scanning on balance edge that points to offset before start token\n      if (balanceEnd < startToken) {\n        break loop;\n      }\n      type = this.offsetAndType[cursor] >> TYPE_SHIFT;\n\n      // check token is stop type\n      switch (mode(type, this.source, offset)) {\n        case 1:\n          break loop;\n        case 2:\n          cursor++;\n          break loop;\n        default:\n          // fast forward to the end of balanced block\n          if (this.balance[balanceEnd] === cursor) {\n            cursor = balanceEnd;\n          }\n          offset = this.offsetAndType[cursor] & OFFSET_MASK;\n      }\n    }\n    return cursor - this.tokenIndex;\n  },\n  isBalanceEdge: function (pos) {\n    return this.balance[this.tokenIndex] < pos;\n  },\n  isDelim: function (code, offset) {\n    if (offset) {\n      return this.lookupType(offset) === TYPE.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;\n    }\n    return this.tokenType === TYPE.Delim && this.source.charCodeAt(this.tokenStart) === code;\n  },\n  getTokenValue: function () {\n    return this.source.substring(this.tokenStart, this.tokenEnd);\n  },\n  getTokenLength: function () {\n    return this.tokenEnd - this.tokenStart;\n  },\n  substrToCursor: function (start) {\n    return this.source.substring(start, this.tokenStart);\n  },\n  skipWS: function () {\n    for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n      if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {\n        break;\n      }\n    }\n    if (skipTokenCount > 0) {\n      this.skip(skipTokenCount);\n    }\n  },\n  skipSC: function () {\n    while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n      this.next();\n    }\n  },\n  skip: function (tokenCount) {\n    var next = this.tokenIndex + tokenCount;\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.next();\n    }\n  },\n  next: function () {\n    var next = this.tokenIndex + 1;\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.tokenEnd;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.eof = true;\n      this.tokenType = EOF;\n      this.tokenStart = this.tokenEnd = this.source.length;\n    }\n  },\n  forEachToken(fn) {\n    for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n      var start = offset;\n      var item = this.offsetAndType[i];\n      var end = item & OFFSET_MASK;\n      var type = item >> TYPE_SHIFT;\n      offset = end;\n      fn(type, start, end, i);\n    }\n  },\n  dump() {\n    var tokens = new Array(this.tokenCount);\n    this.forEachToken((type, start, end, index) => {\n      tokens[index] = {\n        idx: index,\n        type: NAME[type],\n        chunk: this.source.substring(start, end),\n        balance: this.balance[index]\n      };\n    });\n    return tokens;\n  }\n};\nmodule.exports = TokenStream;","map":{"version":3,"names":["constants","require","TYPE","NAME","utils","cmpStr","EOF","WHITESPACE","WhiteSpace","COMMENT","Comment","OFFSET_MASK","TYPE_SHIFT","TokenStream","offsetAndType","balance","reset","prototype","eof","tokenIndex","tokenType","tokenStart","firstCharOffset","tokenEnd","lookupType","offset","tokenCount","lookupOffset","source","length","lookupValue","referenceStr","getTokenStart","getRawLength","startToken","mode","cursor","balanceEnd","Math","max","type","loop","isBalanceEdge","pos","isDelim","code","Delim","charCodeAt","getTokenValue","substring","getTokenLength","substrToCursor","start","skipWS","i","skipTokenCount","skip","skipSC","next","forEachToken","fn","item","end","dump","tokens","Array","index","idx","chunk","module","exports"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/common/TokenStream.js"],"sourcesContent":["var constants = require('../tokenizer/const');\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\n\nvar utils = require('../tokenizer/utils');\nvar cmpStr = utils.cmpStr;\n\nvar EOF = TYPE.EOF;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\n\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\n\nvar TokenStream = function() {\n    this.offsetAndType = null;\n    this.balance = null;\n\n    this.reset();\n};\n\nTokenStream.prototype = {\n    reset: function() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    },\n\n    lookupType: function(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return EOF;\n    },\n    lookupOffset: function(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    },\n    lookupValue: function(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    },\n    getTokenStart: function(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    },\n\n    // TODO: -> skipUntilBalanced\n    getRawLength: function(startToken, mode) {\n        var cursor = startToken;\n        var balanceEnd;\n        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n        var type;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            type = this.offsetAndType[cursor] >> TYPE_SHIFT;\n\n            // check token is stop type\n            switch (mode(type, this.source, offset)) {\n                case 1:\n                    break loop;\n\n                case 2:\n                    cursor++;\n                    break loop;\n\n                default:\n                    // fast forward to the end of balanced block\n                    if (this.balance[balanceEnd] === cursor) {\n                        cursor = balanceEnd;\n                    }\n\n                    offset = this.offsetAndType[cursor] & OFFSET_MASK;\n            }\n        }\n\n        return cursor - this.tokenIndex;\n    },\n    isBalanceEdge: function(pos) {\n        return this.balance[this.tokenIndex] < pos;\n    },\n    isDelim: function(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === TYPE.Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === TYPE.Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    },\n\n    getTokenValue: function() {\n        return this.source.substring(this.tokenStart, this.tokenEnd);\n    },\n    getTokenLength: function() {\n        return this.tokenEnd - this.tokenStart;\n    },\n    substrToCursor: function(start) {\n        return this.source.substring(start, this.tokenStart);\n    },\n\n    skipWS: function() {\n        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {\n                break;\n            }\n        }\n\n        if (skipTokenCount > 0) {\n            this.skip(skipTokenCount);\n        }\n    },\n    skipSC: function() {\n        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n            this.next();\n        }\n    },\n    skip: function(tokenCount) {\n        var next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    },\n    next: function() {\n        var next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.eof = true;\n            this.tokenType = EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    },\n\n    forEachToken(fn) {\n        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n            var start = offset;\n            var item = this.offsetAndType[i];\n            var end = item & OFFSET_MASK;\n            var type = item >> TYPE_SHIFT;\n\n            offset = end;\n\n            fn(type, start, end, i);\n        }\n    },\n\n    dump() {\n        var tokens = new Array(this.tokenCount);\n\n        this.forEachToken((type, start, end, index) => {\n            tokens[index] = {\n                idx: index,\n                type: NAME[type],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[index]\n            };\n        });\n\n        return tokens;\n    }\n};\n\nmodule.exports = TokenStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}