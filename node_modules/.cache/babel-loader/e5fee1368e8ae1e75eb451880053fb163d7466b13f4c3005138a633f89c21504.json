{"ast":null,"code":"import NodeType from './type';\nimport Node from './node';\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */\nexport default class TextNode extends Node {\n  constructor(rawText, parentNode) {\n    super(parentNode);\n    this.rawText = rawText;\n    /**\n     * Node Type declaration.\n     * @type {Number}\n     */\n    this.nodeType = NodeType.TEXT_NODE;\n  }\n  /**\n   * Returns text with all whitespace trimmed except single leading/trailing non-breaking space\n   */\n  get trimmedText() {\n    if (this._trimmedText !== undefined) return this._trimmedText;\n    const text = this.rawText;\n    let i = 0;\n    let startPos;\n    let endPos;\n    while (i >= 0 && i < text.length) {\n      if (/\\S/.test(text[i])) {\n        if (startPos === undefined) {\n          startPos = i;\n          i = text.length;\n        } else {\n          endPos = i;\n          i = void 0;\n        }\n      }\n      if (startPos === undefined) i++;else i--;\n    }\n    if (startPos === undefined) startPos = 0;\n    if (endPos === undefined) endPos = text.length - 1;\n    const hasLeadingSpace = startPos > 0 && /[^\\S\\r\\n]/.test(text[startPos - 1]);\n    const hasTrailingSpace = endPos < text.length - 1 && /[^\\S\\r\\n]/.test(text[endPos + 1]);\n    this._trimmedText = (hasLeadingSpace ? ' ' : '') + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? ' ' : '');\n    return this._trimmedText;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n  get text() {\n    return this.rawText;\n  }\n  /**\n   * Detect if the node contains only white space.\n   * @return {bool}\n   */\n  get isWhitespace() {\n    return /^(\\s|&nbsp;)*$/.test(this.rawText);\n  }\n  toString() {\n    return this.text;\n  }\n}","map":{"version":3,"names":["NodeType","Node","TextNode","constructor","rawText","parentNode","nodeType","TEXT_NODE","trimmedText","_trimmedText","undefined","text","i","startPos","endPos","length","test","hasLeadingSpace","hasTrailingSpace","slice","isWhitespace","toString"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/node-html-parser/dist/esm/nodes/text.js"],"sourcesContent":["import NodeType from './type';\nimport Node from './node';\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */\nexport default class TextNode extends Node {\n    constructor(rawText, parentNode) {\n        super(parentNode);\n        this.rawText = rawText;\n        /**\n         * Node Type declaration.\n         * @type {Number}\n         */\n        this.nodeType = NodeType.TEXT_NODE;\n    }\n    /**\n     * Returns text with all whitespace trimmed except single leading/trailing non-breaking space\n     */\n    get trimmedText() {\n        if (this._trimmedText !== undefined)\n            return this._trimmedText;\n        const text = this.rawText;\n        let i = 0;\n        let startPos;\n        let endPos;\n        while (i >= 0 && i < text.length) {\n            if (/\\S/.test(text[i])) {\n                if (startPos === undefined) {\n                    startPos = i;\n                    i = text.length;\n                }\n                else {\n                    endPos = i;\n                    i = void 0;\n                }\n            }\n            if (startPos === undefined)\n                i++;\n            else\n                i--;\n        }\n        if (startPos === undefined)\n            startPos = 0;\n        if (endPos === undefined)\n            endPos = text.length - 1;\n        const hasLeadingSpace = startPos > 0 && /[^\\S\\r\\n]/.test(text[startPos - 1]);\n        const hasTrailingSpace = endPos < (text.length - 1) && /[^\\S\\r\\n]/.test(text[endPos + 1]);\n        this._trimmedText = (hasLeadingSpace ? ' ' : '') + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? ' ' : '');\n        return this._trimmedText;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return this.rawText;\n    }\n    /**\n     * Detect if the node contains only white space.\n     * @return {bool}\n     */\n    get isWhitespace() {\n        return /^(\\s|&nbsp;)*$/.test(this.rawText);\n    }\n    toString() {\n        return this.text;\n    }\n}\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,QAAQ;AAC7B,OAAOC,IAAI,MAAM,QAAQ;AACzB;AACA;AACA;AACA;AACA,eAAe,MAAMC,QAAQ,SAASD,IAAI,CAAC;EACvCE,WAAWA,CAACC,OAAO,EAAEC,UAAU,EAAE;IAC7B,KAAK,CAACA,UAAU,CAAC;IACjB,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB;AACR;AACA;AACA;IACQ,IAAI,CAACE,QAAQ,GAAGN,QAAQ,CAACO,SAAS;EACtC;EACA;AACJ;AACA;EACI,IAAIC,WAAWA,CAAA,EAAG;IACd,IAAI,IAAI,CAACC,YAAY,KAAKC,SAAS,EAC/B,OAAO,IAAI,CAACD,YAAY;IAC5B,MAAME,IAAI,GAAG,IAAI,CAACP,OAAO;IACzB,IAAIQ,CAAC,GAAG,CAAC;IACT,IAAIC,QAAQ;IACZ,IAAIC,MAAM;IACV,OAAOF,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAGD,IAAI,CAACI,MAAM,EAAE;MAC9B,IAAI,IAAI,CAACC,IAAI,CAACL,IAAI,CAACC,CAAC,CAAC,CAAC,EAAE;QACpB,IAAIC,QAAQ,KAAKH,SAAS,EAAE;UACxBG,QAAQ,GAAGD,CAAC;UACZA,CAAC,GAAGD,IAAI,CAACI,MAAM;QACnB,CAAC,MACI;UACDD,MAAM,GAAGF,CAAC;UACVA,CAAC,GAAG,KAAK,CAAC;QACd;MACJ;MACA,IAAIC,QAAQ,KAAKH,SAAS,EACtBE,CAAC,EAAE,CAAC,KAEJA,CAAC,EAAE;IACX;IACA,IAAIC,QAAQ,KAAKH,SAAS,EACtBG,QAAQ,GAAG,CAAC;IAChB,IAAIC,MAAM,KAAKJ,SAAS,EACpBI,MAAM,GAAGH,IAAI,CAACI,MAAM,GAAG,CAAC;IAC5B,MAAME,eAAe,GAAGJ,QAAQ,GAAG,CAAC,IAAI,WAAW,CAACG,IAAI,CAACL,IAAI,CAACE,QAAQ,GAAG,CAAC,CAAC,CAAC;IAC5E,MAAMK,gBAAgB,GAAGJ,MAAM,GAAIH,IAAI,CAACI,MAAM,GAAG,CAAE,IAAI,WAAW,CAACC,IAAI,CAACL,IAAI,CAACG,MAAM,GAAG,CAAC,CAAC,CAAC;IACzF,IAAI,CAACL,YAAY,GAAG,CAACQ,eAAe,GAAG,GAAG,GAAG,EAAE,IAAIN,IAAI,CAACQ,KAAK,CAACN,QAAQ,EAAEC,MAAM,GAAG,CAAC,CAAC,IAAII,gBAAgB,GAAG,GAAG,GAAG,EAAE,CAAC;IACnH,OAAO,IAAI,CAACT,YAAY;EAC5B;EACA;AACJ;AACA;AACA;EACI,IAAIE,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACP,OAAO;EACvB;EACA;AACJ;AACA;AACA;EACI,IAAIgB,YAAYA,CAAA,EAAG;IACf,OAAO,gBAAgB,CAACJ,IAAI,CAAC,IAAI,CAACZ,OAAO,CAAC;EAC9C;EACAiB,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACV,IAAI;EACpB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}