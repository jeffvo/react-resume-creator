{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { concat, EMPTY, filter, filterAsync, first, firstValueFrom, from, map, merge, mergeMap, mergeScan, of, raceWith, ReplaySubject, startWith, switchMap, take, takeUntil, timer } from '../../third_party/rxjs/rxjs.js';\nimport { TargetCloseError } from '../common/Errors.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { TimeoutSettings } from '../common/TimeoutSettings.js';\nimport { debugError, fromEmitterEvent, importFSPromises, isString, NETWORK_IDLE_TIME, timeout, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { guarded } from '../util/decorators.js';\nimport { AsyncDisposableStack, asyncDisposeSymbol, DisposableStack, disposeSymbol } from '../util/disposable.js';\nimport { FunctionLocator, Locator, NodeLocator } from './locators/locators.js';\n/**\n * @internal\n */\nexport function setDefaultScreenshotOptions(options) {\n  options.optimizeForSpeed ??= false;\n  options.type ??= 'png';\n  options.fromSurface ??= true;\n  options.fullPage ??= false;\n  options.omitBackground ??= false;\n  options.encoding ??= 'binary';\n  options.captureBeyondViewport ??= true;\n}\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEvent} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link EventEmitter.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nlet Page = (() => {\n  let _classSuper = EventEmitter;\n  let _instanceExtraInitializers = [];\n  let _screenshot_decorators;\n  return class Page extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      __esDecorate(this, null, _screenshot_decorators, {\n        kind: \"method\",\n        name: \"screenshot\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"screenshot\" in obj,\n          get: obj => obj.screenshot\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    /**\n     * @internal\n     */\n    _isDragging = (__runInitializers(this, _instanceExtraInitializers), false);\n    /**\n     * @internal\n     */\n    _timeoutSettings = new TimeoutSettings();\n    #requestHandlers = new WeakMap();\n    #inflight$ = new ReplaySubject(1);\n    /**\n     * @internal\n     */\n    constructor() {\n      super();\n      fromEmitterEvent(this, \"request\" /* PageEvent.Request */).pipe(mergeMap(originalRequest => {\n        return concat(of(1), merge(fromEmitterEvent(this, \"requestfailed\" /* PageEvent.RequestFailed */), fromEmitterEvent(this, \"requestfinished\" /* PageEvent.RequestFinished */), fromEmitterEvent(this, \"response\" /* PageEvent.Response */).pipe(map(response => {\n          return response.request();\n        }))).pipe(filter(request => {\n          return request.id === originalRequest.id;\n        }), take(1), map(() => {\n          return -1;\n        })));\n      }), mergeScan((acc, addend) => {\n        return of(acc + addend);\n      }, 0), takeUntil(fromEmitterEvent(this, \"close\" /* PageEvent.Close */)), startWith(0)).subscribe(this.#inflight$);\n    }\n    /**\n     * Listen to page events.\n     *\n     * @remarks\n     * This method exists to define event typings and handle proper wireup of\n     * cooperative request interception. Actual event listening and dispatching is\n     * delegated to {@link EventEmitter}.\n     *\n     * @internal\n     */\n    on(type, handler) {\n      if (type !== \"request\" /* PageEvent.Request */) {\n        return super.on(type, handler);\n      }\n      let wrapper = this.#requestHandlers.get(handler);\n      if (wrapper === undefined) {\n        wrapper = event => {\n          event.enqueueInterceptAction(() => {\n            return handler(event);\n          });\n        };\n        this.#requestHandlers.set(handler, wrapper);\n      }\n      return super.on(type, wrapper);\n    }\n    /**\n     * @internal\n     */\n    off(type, handler) {\n      if (type === \"request\" /* PageEvent.Request */) {\n        handler = this.#requestHandlers.get(handler) || handler;\n      }\n      return super.off(type, handler);\n    }\n    locator(selectorOrFunc) {\n      if (typeof selectorOrFunc === 'string') {\n        return NodeLocator.create(this, selectorOrFunc);\n      } else {\n        return FunctionLocator.create(this, selectorOrFunc);\n      }\n    }\n    /**\n     * A shortcut for {@link Locator.race} that does not require static imports.\n     *\n     * @internal\n     */\n    locatorRace(locators) {\n      return Locator.race(locators);\n    }\n    /**\n     * Runs `document.querySelector` within the page. If no element matches the\n     * selector, the return value resolves to `null`.\n     *\n     * @param selector - A `selector` to query page for\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query page for.\n     */\n    async $(selector) {\n      return await this.mainFrame().$(selector);\n    }\n    /**\n     * The method runs `document.querySelectorAll` within the page. If no elements\n     * match the selector, the return value resolves to `[]`.\n     *\n     * @param selector - A `selector` to query page for\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n     */\n    async $$(selector) {\n      return await this.mainFrame().$$(selector);\n    }\n    /**\n     * @remarks\n     *\n     * The only difference between {@link Page.evaluate | page.evaluate} and\n     * `page.evaluateHandle` is that `evaluateHandle` will return the value\n     * wrapped in an in-page object.\n     *\n     * If the function passed to `page.evaluateHandle` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     *\n     * ```ts\n     * const aHandle = await page.evaluateHandle('document');\n     * ```\n     *\n     * @example\n     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n     *\n     * ```ts\n     * const aHandle = await page.evaluateHandle(() => document.body);\n     * const resultHandle = await page.evaluateHandle(\n     *   body => body.innerHTML,\n     *   aHandle\n     * );\n     * console.log(await resultHandle.jsonValue());\n     * await resultHandle.dispose();\n     * ```\n     *\n     * Most of the time this function returns a {@link JSHandle},\n     * but if `pageFunction` returns a reference to an element,\n     * you instead get an {@link ElementHandle} back:\n     *\n     * @example\n     *\n     * ```ts\n     * const button = await page.evaluateHandle(() =>\n     *   document.querySelector('button')\n     * );\n     * // can call `click` because `button` is an `ElementHandle`\n     * await button.click();\n     * ```\n     *\n     * The TypeScript definitions assume that `evaluateHandle` returns\n     * a `JSHandle`, but if you know it's going to return an\n     * `ElementHandle`, pass it as the generic argument:\n     *\n     * ```ts\n     * const button = await page.evaluateHandle<ElementHandle>(...);\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluateHandle(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      return await this.mainFrame().evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * This method runs `document.querySelector` within the page and passes the\n     * result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     *\n     * If no element is found matching `selector`, the method will throw an error.\n     *\n     * If `pageFunction` returns a promise `$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * const searchValue = await page.$eval('#search', el => el.value);\n     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n     * const html = await page.$eval('.main-container', el => el.outerHTML);\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```ts\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * const searchValue = await page.$eval(\n     *   '#search',\n     *   (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$eval`:\n     *\n     * @example\n     *\n     * ```ts\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const searchValue = await page.$eval<string>(\n     *   '#search',\n     *   (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * @param selector - the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query for\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed the result of `document.querySelector(selector)` as its\n     * first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $eval(selector, pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n      return await this.mainFrame().$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * This method runs `Array.from(document.querySelectorAll(selector))` within\n     * the page and passes the result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * // get the amount of divs on the page\n     * const divCount = await page.$$eval('div', divs => divs.length);\n     *\n     * // get the text content of all the `.options` elements:\n     * const options = await page.$$eval('div > span.options', options => {\n     *   return options.map(option => option.textContent);\n     * });\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element[]`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```ts\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n     *   return elements.map(e => e.value);\n     * });\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$$eval`:\n     *\n     * @example\n     *\n     * ```ts\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const allInputValues = await page.$$eval<string[]>(\n     *   'input',\n     *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n     * );\n     * ```\n     *\n     * @param selector - the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query for\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed the result of\n     * `Array.from(document.querySelectorAll(selector))` as its first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $$eval(selector, pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n      return await this.mainFrame().$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired URL or content.\n     *\n     * @remarks\n     * Shortcut for\n     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n     *\n     * @param options - Options for the script.\n     * @returns An {@link ElementHandle | element handle} to the injected\n     * `<script>` element.\n     */\n    async addScriptTag(options) {\n      return await this.mainFrame().addScriptTag(options);\n    }\n    async addStyleTag(options) {\n      return await this.mainFrame().addStyleTag(options);\n    }\n    /**\n     * The page's URL.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.url | page.mainFrame().url()}.\n     */\n    url() {\n      return this.mainFrame().url();\n    }\n    /**\n     * The full HTML contents of the page, including the DOCTYPE.\n     */\n    async content() {\n      return await this.mainFrame().content();\n    }\n    /**\n     * Set the content of the page.\n     *\n     * @param html - HTML markup to assign to the page.\n     * @param options - Parameters that has some properties.\n     *\n     * @remarks\n     *\n     * The parameter `options` might have the following options.\n     *\n     * - `timeout` : Maximum time in milliseconds for resources to load, defaults\n     *   to 30 seconds, pass `0` to disable timeout. The default value can be\n     *   changed by using the {@link Page.setDefaultNavigationTimeout} or\n     *   {@link Page.setDefaultTimeout} methods.\n     *\n     * - `waitUntil`: When to consider setting markup succeeded, defaults to\n     *   `load`. Given an array of event strings, setting content is considered\n     *   to be successful after all events have been fired. Events can be\n     *   either:<br/>\n     * - `load` : consider setting content to be finished when the `load` event\n     *   is fired.<br/>\n     * - `domcontentloaded` : consider setting content to be finished when the\n     *   `DOMContentLoaded` event is fired.<br/>\n     * - `networkidle0` : consider setting content to be finished when there are\n     *   no more than 0 network connections for at least `500` ms.<br/>\n     * - `networkidle2` : consider setting content to be finished when there are\n     *   no more than 2 network connections for at least `500` ms.\n     */\n    async setContent(html, options) {\n      await this.mainFrame().setContent(html, options);\n    }\n    /**\n     * Navigates the page to the given `url`.\n     *\n     * @remarks\n     *\n     * Navigation to `about:blank` or navigation to the same URL with a different\n     * hash will succeed and return `null`.\n     *\n     * :::warning\n     *\n     * Headless mode doesn't support navigation to a PDF document. See the {@link\n     * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n     * issue}.\n     *\n     * :::\n     *\n     * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.\n     *\n     * @param url - URL to navigate page to. The URL should include scheme, e.g.\n     * `https://`\n     * @param options - Options to configure waiting behavior.\n     * @returns A promise which resolves to the main resource response. In case of\n     * multiple redirects, the navigation will resolve with the response of the\n     * last redirect.\n     * @throws If:\n     *\n     * - there's an SSL error (e.g. in case of self-signed certificates).\n     * - target URL is invalid.\n     * - the timeout is exceeded during navigation.\n     * - the remote server does not respond or is unreachable.\n     * - the main resource failed to load.\n     *\n     * This method will not throw an error when any valid HTTP status code is\n     * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n     * Server Error\". The status code for such responses can be retrieved by\n     * calling {@link HTTPResponse.status}.\n     */\n    async goto(url, options) {\n      return await this.mainFrame().goto(url, options);\n    }\n    /**\n     * Waits for the page to navigate to a new URL or to reload. It is useful when\n     * you run code that will indirectly cause the page to navigate.\n     *\n     * @example\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(), // The promise resolves after navigation has finished\n     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n     * ]);\n     * ```\n     *\n     * @remarks\n     *\n     * Usage of the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n     * to change the URL is considered a navigation.\n     *\n     * @param options - Navigation parameters which might have the following\n     * properties:\n     * @returns A `Promise` which resolves to the main resource response.\n     *\n     * - In case of multiple redirects, the navigation will resolve with the\n     *   response of the last redirect.\n     * - In case of navigation to a different anchor or navigation due to History\n     *   API usage, the navigation will resolve with `null`.\n     */\n    async waitForNavigation(options = {}) {\n      return await this.mainFrame().waitForNavigation(options);\n    }\n    /**\n     * @param urlOrPredicate - A URL or predicate to wait for\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves to the matched request\n     * @example\n     *\n     * ```ts\n     * const firstRequest = await page.waitForRequest(\n     *   'https://example.com/resource'\n     * );\n     * const finalRequest = await page.waitForRequest(\n     *   request => request.url() === 'https://example.com'\n     * );\n     * return finalRequest.response()?.ok();\n     * ```\n     *\n     * @remarks\n     * Optional Waiting Parameters have:\n     *\n     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass\n     *   `0` to disable the timeout. The default value can be changed by using the\n     *   {@link Page.setDefaultTimeout} method.\n     */\n    waitForRequest(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout()\n      } = options;\n      if (typeof urlOrPredicate === 'string') {\n        const url = urlOrPredicate;\n        urlOrPredicate = request => {\n          return request.url() === url;\n        };\n      }\n      const observable$ = fromEmitterEvent(this, \"request\" /* PageEvent.Request */).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromEmitterEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed!');\n      }))));\n      return firstValueFrom(observable$);\n    }\n    /**\n     * @param urlOrPredicate - A URL or predicate to wait for.\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves to the matched response.\n     * @example\n     *\n     * ```ts\n     * const firstResponse = await page.waitForResponse(\n     *   'https://example.com/resource'\n     * );\n     * const finalResponse = await page.waitForResponse(\n     *   response =>\n     *     response.url() === 'https://example.com' && response.status() === 200\n     * );\n     * const finalResponse = await page.waitForResponse(async response => {\n     *   return (await response.text()).includes('<html>');\n     * });\n     * return finalResponse.ok();\n     * ```\n     *\n     * @remarks\n     * Optional Parameter have:\n     *\n     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n     *   pass `0` to disable the timeout. The default value can be changed by using\n     *   the {@link Page.setDefaultTimeout} method.\n     */\n    waitForResponse(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout()\n      } = options;\n      if (typeof urlOrPredicate === 'string') {\n        const url = urlOrPredicate;\n        urlOrPredicate = response => {\n          return response.url() === url;\n        };\n      }\n      const observable$ = fromEmitterEvent(this, \"response\" /* PageEvent.Response */).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromEmitterEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed!');\n      }))));\n      return firstValueFrom(observable$);\n    }\n    /**\n     * Waits for the network to be idle.\n     *\n     * @param options - Options to configure waiting behavior.\n     * @returns A promise which resolves once the network is idle.\n     */\n    waitForNetworkIdle(options = {}) {\n      return firstValueFrom(this.waitForNetworkIdle$(options));\n    }\n    /**\n     * @internal\n     */\n    waitForNetworkIdle$(options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout(),\n        idleTime = NETWORK_IDLE_TIME,\n        concurrency = 0\n      } = options;\n      return this.#inflight$.pipe(switchMap(inflight => {\n        if (inflight > concurrency) {\n          return EMPTY;\n        }\n        return timer(idleTime);\n      }), map(() => {}), raceWith(timeout(ms), fromEmitterEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed!');\n      }))));\n    }\n    /**\n     * Waits for a frame matching the given conditions to appear.\n     *\n     * @example\n     *\n     * ```ts\n     * const frame = await page.waitForFrame(async frame => {\n     *   return frame.name() === 'Test';\n     * });\n     * ```\n     */\n    async waitForFrame(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this.getDefaultTimeout()\n      } = options;\n      if (isString(urlOrPredicate)) {\n        urlOrPredicate = frame => {\n          return urlOrPredicate === frame.url();\n        };\n      }\n      return await firstValueFrom(merge(fromEmitterEvent(this, \"frameattached\" /* PageEvent.FrameAttached */), fromEmitterEvent(this, \"framenavigated\" /* PageEvent.FrameNavigated */), from(this.frames())).pipe(filterAsync(urlOrPredicate), first(), raceWith(timeout(ms), fromEmitterEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed.');\n      })))));\n    }\n    /**\n     * Emulates a given device's metrics and user agent.\n     *\n     * To aid emulation, Puppeteer provides a list of known devices that can be\n     * via {@link KnownDevices}.\n     *\n     * @remarks\n     * This method is a shortcut for calling two methods:\n     * {@link Page.setUserAgent} and {@link Page.setViewport}.\n     *\n     * This method will resize the page. A lot of websites don't expect phones to\n     * change size, so you should emulate before navigating to the page.\n     *\n     * @example\n     *\n     * ```ts\n     * import {KnownDevices} from 'puppeteer';\n     * const iPhone = KnownDevices['iPhone 6'];\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   await page.emulate(iPhone);\n     *   await page.goto('https://www.google.com');\n     *   // other actions...\n     *   await browser.close();\n     * })();\n     * ```\n     */\n    async emulate(device) {\n      await Promise.all([this.setUserAgent(device.userAgent), this.setViewport(device.viewport)]);\n    }\n    /**\n     * Evaluates a function in the page's context and returns the result.\n     *\n     * If the function passed to `page.evaluate` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * const result = await frame.evaluate(() => {\n     *   return Promise.resolve(8 * 7);\n     * });\n     * console.log(result); // prints \"56\"\n     * ```\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     *\n     * ```ts\n     * const aHandle = await page.evaluate('1 + 2');\n     * ```\n     *\n     * To get the best TypeScript experience, you should pass in as the\n     * generic the type of `pageFunction`:\n     *\n     * ```ts\n     * const aHandle = await page.evaluate(() => 2);\n     * ```\n     *\n     * @example\n     *\n     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n     * as arguments to the `pageFunction`:\n     *\n     * ```ts\n     * const bodyHandle = await page.$('body');\n     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n     * await bodyHandle.dispose();\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     *\n     * @returns the return value of `pageFunction`.\n     */\n    async evaluate(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      return await this.mainFrame().evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async _maybeWriteBufferToFile(path, buffer) {\n      if (!path) {\n        return;\n      }\n      const fs = await importFSPromises();\n      await fs.writeFile(path, buffer);\n    }\n    /**\n     * Captures a screencast of this {@link Page | page}.\n     *\n     * @example\n     * Recording a {@link Page | page}:\n     *\n     * ```\n     * import puppeteer from 'puppeteer';\n     *\n     * // Launch a browser\n     * const browser = await puppeteer.launch();\n     *\n     * // Create a new page\n     * const page = await browser.newPage();\n     *\n     * // Go to your site.\n     * await page.goto(\"https://www.example.com\");\n     *\n     * // Start recording.\n     * const recorder = await page.screencast({path: 'recording.webm'});\n     *\n     * // Do something.\n     *\n     * // Stop recording.\n     * await recorder.stop();\n     *\n     * browser.close();\n     * ```\n     *\n     * @param options - Configures screencast behavior.\n     *\n     * @experimental\n     *\n     * @remarks\n     *\n     * All recordings will be {@link https://www.webmproject.org/ | WebM} format using\n     * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.\n     *\n     * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.\n     */\n    async screencast(options = {}) {\n      const [{\n        ScreenRecorder\n      }, [width, height, devicePixelRatio]] = await Promise.all([import('../node/ScreenRecorder.js'), this.#getNativePixelDimensions()]);\n      let crop;\n      if (options.crop) {\n        const {\n          x,\n          y,\n          width: cropWidth,\n          height: cropHeight\n        } = roundRectangle(normalizeRectangle(options.crop));\n        if (x < 0 || y < 0) {\n          throw new Error(`\\`crop.x\\` and \\`crop.y\\` must be greater than or equal to 0.`);\n        }\n        if (cropWidth <= 0 || cropHeight <= 0) {\n          throw new Error(`\\`crop.height\\` and \\`crop.width\\` must be greater than or equal to 0.`);\n        }\n        const viewportWidth = width / devicePixelRatio;\n        const viewportHeight = height / devicePixelRatio;\n        if (x + cropWidth > viewportWidth) {\n          throw new Error(`\\`crop.width\\` cannot be larger than the viewport width (${viewportWidth}).`);\n        }\n        if (y + cropHeight > viewportHeight) {\n          throw new Error(`\\`crop.height\\` cannot be larger than the viewport height (${viewportHeight}).`);\n        }\n        crop = {\n          x: x * devicePixelRatio,\n          y: y * devicePixelRatio,\n          width: cropWidth * devicePixelRatio,\n          height: cropHeight * devicePixelRatio\n        };\n      }\n      if (options.speed !== undefined && options.speed <= 0) {\n        throw new Error(`\\`speed\\` must be greater than 0.`);\n      }\n      if (options.scale !== undefined && options.scale <= 0) {\n        throw new Error(`\\`scale\\` must be greater than 0.`);\n      }\n      const recorder = new ScreenRecorder(this, width, height, {\n        ...options,\n        path: options.ffmpegPath,\n        crop\n      });\n      try {\n        await this._startScreencast();\n      } catch (error) {\n        void recorder.stop();\n        throw error;\n      }\n      if (options.path) {\n        const {\n          createWriteStream\n        } = await import('fs');\n        const stream = createWriteStream(options.path, 'binary');\n        recorder.pipe(stream);\n      }\n      return recorder;\n    }\n    #screencastSessionCount = 0;\n    #startScreencastPromise;\n    /**\n     * @internal\n     */\n    async _startScreencast() {\n      ++this.#screencastSessionCount;\n      if (!this.#startScreencastPromise) {\n        this.#startScreencastPromise = this.mainFrame().client.send('Page.startScreencast', {\n          format: 'png'\n        }).then(() => {\n          // Wait for the first frame.\n          return new Promise(resolve => {\n            return this.mainFrame().client.once('Page.screencastFrame', () => {\n              return resolve();\n            });\n          });\n        });\n      }\n      await this.#startScreencastPromise;\n    }\n    /**\n     * @internal\n     */\n    async _stopScreencast() {\n      --this.#screencastSessionCount;\n      if (!this.#startScreencastPromise) {\n        return;\n      }\n      this.#startScreencastPromise = undefined;\n      if (this.#screencastSessionCount === 0) {\n        await this.mainFrame().client.send('Page.stopScreencast');\n      }\n    }\n    /**\n     * Gets the native, non-emulated dimensions of the viewport.\n     */\n    async #getNativePixelDimensions() {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const viewport = this.viewport();\n        const stack = __addDisposableResource(env_1, new DisposableStack(), false);\n        if (viewport && viewport.deviceScaleFactor !== 0) {\n          await this.setViewport({\n            ...viewport,\n            deviceScaleFactor: 0\n          });\n          stack.defer(() => {\n            void this.setViewport(viewport).catch(debugError);\n          });\n        }\n        return await this.mainFrame().isolatedRealm().evaluate(() => {\n          return [window.visualViewport.width * window.devicePixelRatio, window.visualViewport.height * window.devicePixelRatio, window.devicePixelRatio];\n        });\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        __disposeResources(env_1);\n      }\n    }\n    async screenshot(userOptions = {}) {\n      const env_2 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        await this.bringToFront();\n        // TODO: use structuredClone after Node 16 support is dropped.\n        const options = {\n          ...userOptions,\n          clip: userOptions.clip ? {\n            ...userOptions.clip\n          } : undefined\n        };\n        if (options.type === undefined && options.path !== undefined) {\n          const filePath = options.path;\n          // Note we cannot use Node.js here due to browser compatability.\n          const extension = filePath.slice(filePath.lastIndexOf('.') + 1).toLowerCase();\n          switch (extension) {\n            case 'png':\n              options.type = 'png';\n              break;\n            case 'jpeg':\n            case 'jpg':\n              options.type = 'jpeg';\n              break;\n            case 'webp':\n              options.type = 'webp';\n              break;\n          }\n        }\n        if (options.quality !== undefined) {\n          if (options.quality < 0 && options.quality > 100) {\n            throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);\n          }\n          if (options.type === undefined || !['jpeg', 'webp'].includes(options.type)) {\n            throw new Error(`${options.type ?? 'png'} screenshots do not support 'quality'.`);\n          }\n        }\n        if (options.clip) {\n          if (options.clip.width <= 0) {\n            throw new Error(\"'width' in 'clip' must be positive.\");\n          }\n          if (options.clip.height <= 0) {\n            throw new Error(\"'height' in 'clip' must be positive.\");\n          }\n        }\n        setDefaultScreenshotOptions(options);\n        const stack = __addDisposableResource(env_2, new AsyncDisposableStack(), true);\n        if (options.clip) {\n          if (options.fullPage) {\n            throw new Error(\"'clip' and 'fullPage' are mutually exclusive\");\n          }\n          options.clip = roundRectangle(normalizeRectangle(options.clip));\n        } else {\n          if (options.fullPage) {\n            // If `captureBeyondViewport` is `false`, then we set the viewport to\n            // capture the full page. Note this may be affected by on-page CSS and\n            // JavaScript.\n            if (!options.captureBeyondViewport) {\n              const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {\n                const element = document.documentElement;\n                return {\n                  width: element.scrollWidth,\n                  height: element.scrollHeight\n                };\n              });\n              const viewport = this.viewport();\n              await this.setViewport({\n                ...viewport,\n                ...scrollDimensions\n              });\n              stack.defer(async () => {\n                if (viewport) {\n                  await this.setViewport(viewport).catch(debugError);\n                } else {\n                  await this.setViewport({\n                    width: 0,\n                    height: 0\n                  }).catch(debugError);\n                }\n              });\n            }\n          } else {\n            options.captureBeyondViewport = false;\n          }\n        }\n        const data = await this._screenshot(options);\n        if (options.encoding === 'base64') {\n          return data;\n        }\n        const buffer = Buffer.from(data, 'base64');\n        await this._maybeWriteBufferToFile(options.path, buffer);\n        return buffer;\n      } catch (e_2) {\n        env_2.error = e_2;\n        env_2.hasError = true;\n      } finally {\n        const result_1 = __disposeResources(env_2);\n        if (result_1) await result_1;\n      }\n    }\n    /**\n     * The page's title\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n     */\n    async title() {\n      return await this.mainFrame().title();\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page | Page.mouse} to click in the center of the\n     * element. If there's no element matching `selector`, the method throws an\n     * error.\n     *\n     * @remarks\n     *\n     * Bear in mind that if `click()` triggers a navigation event and\n     * there's a separate `page.waitForNavigation()` promise to be resolved, you\n     * may end up with a race condition that yields unexpected results. The\n     * correct pattern for click and wait for navigation is the following:\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   page.click(selector, clickOptions),\n     * ]);\n     * ```\n     *\n     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n     * @param selector - A `selector` to search for element to click. If there are\n     * multiple elements satisfying the `selector`, the first will be clicked\n     * @param options - `Object`\n     * @returns Promise which resolves when the element matching `selector` is\n     * successfully clicked. The Promise will be rejected if there is no element\n     * matching `selector`.\n     */\n    click(selector, options) {\n      return this.mainFrame().click(selector, options);\n    }\n    /**\n     * This method fetches an element with `selector` and focuses it. If there's no\n     * element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }\n     * of an element to focus. If there are multiple elements satisfying the\n     * selector, the first will be focused.\n     * @returns Promise which resolves when the element matching selector is\n     * successfully focused. The promise will be rejected if there is no element\n     * matching selector.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.\n     */\n    focus(selector) {\n      return this.mainFrame().focus(selector);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page | Page.mouse}\n     * to hover over the center of the element.\n     * If there's no element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to search for element to hover. If there are multiple elements satisfying\n     * the selector, the first will be hovered.\n     * @returns Promise which resolves when the element matching `selector` is\n     * successfully hovered. Promise gets rejected if there's no element matching\n     * `selector`.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n     */\n    hover(selector) {\n      return this.mainFrame().hover(selector);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     *\n     * ```ts\n     * page.select('select#colors', 'blue'); // single selection\n     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n     * to query the page for\n     * @param values - Values of options to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first one\n     * is taken into account.\n     * @returns\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.select | page.mainFrame().select()}\n     */\n    select(selector, ...values) {\n      return this.mainFrame().select(selector, ...values);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page | Page.touchscreen}\n     * to tap in the center of the element.\n     * If there's no element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n     * to search for element to tap. If there are multiple elements satisfying the\n     * selector, the first will be tapped.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n     */\n    tap(selector) {\n      return this.mainFrame().tap(selector);\n    }\n    /**\n     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n     * in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n     * @example\n     *\n     * ```ts\n     * await page.type('#mytextarea', 'Hello');\n     * // Types instantly\n     * await page.type('#mytextarea', 'World', {delay: 100});\n     * // Types slower, like a user\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * of an element to type into. If there are multiple elements satisfying the\n     * selector, the first will be used.\n     * @param text - A text to type into a focused element.\n     * @param options - have property `delay` which is the Time to wait between\n     * key presses in milliseconds. Defaults to `0`.\n     * @returns\n     */\n    type(selector, text, options) {\n      return this.mainFrame().type(selector, text, options);\n    }\n    /**\n     * Wait for the `selector` to appear in page. If at the moment of calling the\n     * method the `selector` already exists, the method will return immediately. If\n     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * @example\n     * This method works across navigations:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * of an element to wait for\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves when element specified by selector string\n     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n     * selector is not found in DOM.\n     *\n     * @remarks\n     * The optional Parameter in Arguments `options` are:\n     *\n     * - `visible`: A boolean wait for element to be present in DOM and to be\n     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n     *   properties. Defaults to `false`.\n     *\n     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n     *   `false`.\n     *\n     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n     *   by using the {@link Page.setDefaultTimeout} method.\n     */\n    async waitForSelector(selector, options = {}) {\n      return await this.mainFrame().waitForSelector(selector, options);\n    }\n    /**\n     * Waits for the provided function, `pageFunction`, to return a truthy value when\n     * evaluated in the page's context.\n     *\n     * @example\n     * {@link Page.waitForFunction} can be used to observe a viewport size change:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n     *   await page.setViewport({width: 50, height: 50});\n     *   await watchDog;\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @example\n     * Arguments can be passed from Node.js to `pageFunction`:\n     *\n     * ```ts\n     * const selector = '.foo';\n     * await page.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {},\n     *   selector\n     * );\n     * ```\n     *\n     * @example\n     * The provided `pageFunction` can be asynchronous:\n     *\n     * ```ts\n     * const username = 'github-username';\n     * await page.waitForFunction(\n     *   async username => {\n     *     const githubResponse = await fetch(\n     *       `https://api.github.com/users/${username}`\n     *     );\n     *     const githubUser = await githubResponse.json();\n     *     // show the avatar\n     *     const img = document.createElement('img');\n     *     img.src = githubUser.avatar_url;\n     *     // wait 3 seconds\n     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n     *     img.remove();\n     *   },\n     *   {},\n     *   username\n     * );\n     * ```\n     *\n     * @param pageFunction - Function to be evaluated in browser context until it returns a\n     * truthy value.\n     * @param options - Options for configuring waiting behavior.\n     */\n    waitForFunction(pageFunction, options, ...args) {\n      return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n    }\n    /** @internal */\n    [(_screenshot_decorators = [guarded(function () {\n      return this.browser();\n    })], disposeSymbol)]() {\n      return void this.close().catch(debugError);\n    }\n    /** @internal */\n    [asyncDisposeSymbol]() {\n      return this.close();\n    }\n  };\n})();\nexport { Page };\n/**\n * @internal\n */\nexport const supportedMetrics = new Set(['Timestamp', 'Documents', 'Frames', 'JSEventListeners', 'Nodes', 'LayoutCount', 'RecalcStyleCount', 'LayoutDuration', 'RecalcStyleDuration', 'ScriptDuration', 'TaskDuration', 'JSHeapUsedSize', 'JSHeapTotalSize']);\n/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */\nfunction normalizeRectangle(clip) {\n  return {\n    ...clip,\n    ...(clip.width < 0 ? {\n      x: clip.x + clip.width,\n      width: -clip.width\n    } : {\n      x: clip.x,\n      width: clip.width\n    }),\n    ...(clip.height < 0 ? {\n      y: clip.y + clip.height,\n      height: -clip.height\n    } : {\n      y: clip.y,\n      height: clip.height\n    })\n  };\n}\nfunction roundRectangle(clip) {\n  const x = Math.round(clip.x);\n  const y = Math.round(clip.y);\n  const width = Math.round(clip.width + clip.x - x);\n  const height = Math.round(clip.height + clip.y - y);\n  return {\n    ...clip,\n    x,\n    y,\n    width,\n    height\n  };\n}","map":{"version":3,"names":["concat","EMPTY","filter","filterAsync","first","firstValueFrom","from","map","merge","mergeMap","mergeScan","of","raceWith","ReplaySubject","startWith","switchMap","take","takeUntil","timer","TargetCloseError","EventEmitter","TimeoutSettings","debugError","fromEmitterEvent","importFSPromises","isString","NETWORK_IDLE_TIME","timeout","withSourcePuppeteerURLIfNone","guarded","AsyncDisposableStack","asyncDisposeSymbol","DisposableStack","disposeSymbol","FunctionLocator","Locator","NodeLocator","setDefaultScreenshotOptions","options","optimizeForSpeed","type","fromSurface","fullPage","omitBackground","encoding","captureBeyondViewport","Page","_classSuper","__esDecorate","_screenshot_decorators","kind","name","static","private","access","has","obj","get","screenshot","metadata","_metadata","_instanceExtraInitializers","_isDragging","__runInitializers","_timeoutSettings","requestHandlers","WeakMap","inflight$","constructor","pipe","originalRequest","response","request","id","acc","addend","subscribe","on","handler","wrapper","undefined","event","enqueueInterceptAction","set","off","locator","selectorOrFunc","create","locatorRace","locators","race","$","selector","mainFrame","$$","evaluateHandle","pageFunction","args","$eval","$$eval","addScriptTag","addStyleTag","url","content","setContent","html","goto","waitForNavigation","waitForRequest","urlOrPredicate","ms","observable$","waitForResponse","waitForNetworkIdle","waitForNetworkIdle$","idleTime","concurrency","inflight","waitForFrame","getDefaultTimeout","frame","frames","emulate","device","Promise","all","setUserAgent","userAgent","setViewport","viewport","evaluate","_maybeWriteBufferToFile","path","buffer","fs","writeFile","screencast","ScreenRecorder","width","height","devicePixelRatio","getNativePixelDimensions","crop","x","y","cropWidth","cropHeight","roundRectangle","normalizeRectangle","Error","viewportWidth","viewportHeight","speed","scale","recorder","ffmpegPath","_startScreencast","error","stop","createWriteStream","stream","screencastSessionCount","startScreencastPromise","client","send","format","then","resolve","once","_stopScreencast","#getNativePixelDimensions","stack","__addDisposableResource","env_1","deviceScaleFactor","defer","catch","isolatedRealm","window","visualViewport","userOptions","bringToFront","clip","filePath","extension","slice","lastIndexOf","toLowerCase","quality","includes","env_2","scrollDimensions","element","document","documentElement","scrollWidth","scrollHeight","data","_screenshot","Buffer","title","click","focus","hover","select","values","tap","text","waitForSelector","waitForFunction","browser","close","supportedMetrics","Set","Math","round"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/puppeteer-core/src/api/Page.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {\n  concat,\n  EMPTY,\n  filter,\n  filterAsync,\n  first,\n  firstValueFrom,\n  from,\n  map,\n  merge,\n  mergeMap,\n  mergeScan,\n  of,\n  raceWith,\n  ReplaySubject,\n  startWith,\n  switchMap,\n  take,\n  takeUntil,\n  timer,\n  type Observable,\n} from '../../third_party/rxjs/rxjs.js';\nimport type {HTTPRequest} from '../api/HTTPRequest.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {Accessibility} from '../cdp/Accessibility.js';\nimport type {Coverage} from '../cdp/Coverage.js';\nimport type {DeviceRequestPrompt} from '../cdp/DeviceRequestPrompt.js';\nimport type {Credentials, NetworkConditions} from '../cdp/NetworkManager.js';\nimport type {Tracing} from '../cdp/Tracing.js';\nimport type {ConsoleMessage} from '../common/ConsoleMessage.js';\nimport type {\n  Cookie,\n  CookieParam,\n  DeleteCookiesRequest,\n} from '../common/Cookie.js';\nimport type {Device} from '../common/Device.js';\nimport {TargetCloseError} from '../common/Errors.js';\nimport {\n  EventEmitter,\n  type EventsWithWildcard,\n  type EventType,\n  type Handler,\n} from '../common/EventEmitter.js';\nimport type {FileChooser} from '../common/FileChooser.js';\nimport type {PDFOptions} from '../common/PDFOptions.js';\nimport {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {\n  Awaitable,\n  AwaitablePredicate,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  NodeFor,\n} from '../common/types.js';\nimport {\n  debugError,\n  fromEmitterEvent,\n  importFSPromises,\n  isString,\n  NETWORK_IDLE_TIME,\n  timeout,\n  withSourcePuppeteerURLIfNone,\n} from '../common/util.js';\nimport type {Viewport} from '../common/Viewport.js';\nimport type {ScreenRecorder} from '../node/ScreenRecorder.js';\nimport {guarded} from '../util/decorators.js';\nimport {\n  AsyncDisposableStack,\n  asyncDisposeSymbol,\n  DisposableStack,\n  disposeSymbol,\n} from '../util/disposable.js';\n\nimport type {Browser} from './Browser.js';\nimport type {BrowserContext} from './BrowserContext.js';\nimport type {CDPSession} from './CDPSession.js';\nimport type {Dialog} from './Dialog.js';\nimport type {\n  BoundingBox,\n  ClickOptions,\n  ElementHandle,\n} from './ElementHandle.js';\nimport type {\n  Frame,\n  FrameAddScriptTagOptions,\n  FrameAddStyleTagOptions,\n  FrameWaitForFunctionOptions,\n  GoToOptions,\n  WaitForOptions,\n} from './Frame.js';\nimport type {\n  Keyboard,\n  KeyboardTypeOptions,\n  Mouse,\n  Touchscreen,\n} from './Input.js';\nimport type {JSHandle} from './JSHandle.js';\nimport {\n  FunctionLocator,\n  Locator,\n  NodeLocator,\n  type AwaitedLocator,\n} from './locators/locators.js';\nimport type {Target} from './Target.js';\nimport type {WebWorker} from './WebWorker.js';\n\n/**\n * @public\n */\nexport interface Metrics {\n  Timestamp?: number;\n  Documents?: number;\n  Frames?: number;\n  JSEventListeners?: number;\n  Nodes?: number;\n  LayoutCount?: number;\n  RecalcStyleCount?: number;\n  LayoutDuration?: number;\n  RecalcStyleDuration?: number;\n  ScriptDuration?: number;\n  TaskDuration?: number;\n  JSHeapUsedSize?: number;\n  JSHeapTotalSize?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitForNetworkIdleOptions extends WaitTimeoutOptions {\n  /**\n   * Time (in milliseconds) the network should be idle.\n   *\n   * @defaultValue `500`\n   */\n  idleTime?: number;\n  /**\n   * Maximum number concurrent of network connections to be considered inactive.\n   *\n   * @defaultValue `0`\n   */\n  concurrency?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitTimeoutOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass 0 to disable the timeout.\n   *\n   * The default value can be changed by using the\n   * {@link Page.setDefaultTimeout} method.\n   *\n   * @defaultValue `30000`\n   */\n  timeout?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitForSelectorOptions {\n  /**\n   * Wait for the selected element to be present in DOM and to be visible, i.e.\n   * to not have `display: none` or `visibility: hidden` CSS properties.\n   *\n   * @defaultValue `false`\n   */\n  visible?: boolean;\n  /**\n   * Wait for the selected element to not be found in the DOM or to be hidden,\n   * i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *\n   * @defaultValue `false`\n   */\n  hidden?: boolean;\n  /**\n   * Maximum time to wait in milliseconds. Pass `0` to disable timeout.\n   *\n   * The default value can be changed by using {@link Page.setDefaultTimeout}\n   *\n   * @defaultValue `30_000` (30 seconds)\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitForSelector call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface GeolocationOptions {\n  /**\n   * Latitude between `-90` and `90`.\n   */\n  longitude: number;\n  /**\n   * Longitude between `-180` and `180`.\n   */\n  latitude: number;\n  /**\n   * Optional non-negative accuracy value.\n   */\n  accuracy?: number;\n}\n\n/**\n * @public\n */\nexport interface MediaFeature {\n  name: string;\n  value: string;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotClip extends BoundingBox {\n  /**\n   * @defaultValue `1`\n   */\n  scale?: number;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotOptions {\n  /**\n   * @defaultValue `false`\n   */\n  optimizeForSpeed?: boolean;\n  /**\n   * @defaultValue `'png'`\n   */\n  type?: 'png' | 'jpeg' | 'webp';\n  /**\n   * Quality of the image, between 0-100. Not applicable to `png` images.\n   */\n  quality?: number;\n  /**\n   * Capture the screenshot from the surface, rather than the view.\n   *\n   * @defaultValue `true`\n   */\n  fromSurface?: boolean;\n  /**\n   * When `true`, takes a screenshot of the full page.\n   *\n   * @defaultValue `false`\n   */\n  fullPage?: boolean;\n  /**\n   * Hides default white background and allows capturing screenshots with transparency.\n   *\n   * @defaultValue `false`\n   */\n  omitBackground?: boolean;\n  /**\n   * The file path to save the image to. The screenshot type will be inferred\n   * from file extension. If path is a relative path, then it is resolved\n   * relative to current working directory. If no path is provided, the image\n   * won't be saved to the disk.\n   */\n  path?: string;\n  /**\n   * Specifies the region of the page to clip.\n   */\n  clip?: ScreenshotClip;\n  /**\n   * Encoding of the image.\n   *\n   * @defaultValue `'binary'`\n   */\n  encoding?: 'base64' | 'binary';\n  /**\n   * Capture the screenshot beyond the viewport.\n   *\n   * @defaultValue `false` if there is no `clip`. `true` otherwise.\n   */\n  captureBeyondViewport?: boolean;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface ScreencastOptions {\n  /**\n   * File path to save the screencast to.\n   */\n  path?: `${string}.webm`;\n  /**\n   * Specifies the region of the viewport to crop.\n   */\n  crop?: BoundingBox;\n  /**\n   * Scales the output video.\n   *\n   * For example, `0.5` will shrink the width and height of the output video by\n   * half. `2` will double the width and height of the output video.\n   *\n   * @defaultValue `1`\n   */\n  scale?: number;\n  /**\n   * Specifies the speed to record at.\n   *\n   * For example, `0.5` will slowdown the output video by 50%. `2` will double the\n   * speed of the output video.\n   *\n   * @defaultValue `1`\n   */\n  speed?: number;\n  /**\n   * Path to the [ffmpeg](https://ffmpeg.org/).\n   *\n   * Required if `ffmpeg` is not in your PATH.\n   */\n  ffmpegPath?: string;\n}\n\n/**\n * All the events that a page instance may emit.\n *\n * @public\n */\nexport const enum PageEvent {\n  /**\n   * Emitted when the page closes.\n   */\n  Close = 'close',\n  /**\n   * Emitted when JavaScript within the page calls one of console API methods,\n   * e.g. `console.log` or `console.dir`. Also emitted if the page throws an\n   * error or a warning.\n   *\n   * @remarks\n   * A `console` event provides a {@link ConsoleMessage} representing the\n   * console message that was logged.\n   *\n   * @example\n   * An example of handling `console` event:\n   *\n   * ```ts\n   * page.on('console', msg => {\n   *   for (let i = 0; i < msg.args().length; ++i)\n   *     console.log(`${i}: ${msg.args()[i]}`);\n   * });\n   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));\n   * ```\n   */\n  Console = 'console',\n  /**\n   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`,\n   * `confirm` or `beforeunload`. Puppeteer can respond to the dialog via\n   * {@link Dialog.accept} or {@link Dialog.dismiss}.\n   */\n  Dialog = 'dialog',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded | DOMContentLoaded }\n   * event is dispatched.\n   */\n  DOMContentLoaded = 'domcontentloaded',\n  /**\n   * Emitted when the page crashes. Will contain an `Error`.\n   */\n  Error = 'error',\n  /** Emitted when a frame is attached. Will contain a {@link Frame}. */\n  FrameAttached = 'frameattached',\n  /** Emitted when a frame is detached. Will contain a {@link Frame}. */\n  FrameDetached = 'framedetached',\n  /**\n   * Emitted when a frame is navigated to a new URL. Will contain a\n   * {@link Frame}.\n   */\n  FrameNavigated = 'framenavigated',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/load | load}\n   * event is dispatched.\n   */\n  Load = 'load',\n  /**\n   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For\n   * the list of metrics see {@link Page.metrics | page.metrics}.\n   *\n   * @remarks\n   * Contains an object with two properties:\n   *\n   * - `title`: the title passed to `console.timeStamp`\n   * - `metrics`: object containing metrics as key/value pairs. The values will\n   *   be `number`s.\n   */\n  Metrics = 'metrics',\n  /**\n   * Emitted when an uncaught exception happens within the page. Contains an\n   * `Error`.\n   */\n  PageError = 'pageerror',\n  /**\n   * Emitted when the page opens a new tab or window.\n   *\n   * Contains a {@link Page} corresponding to the popup window.\n   *\n   * @example\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.click('a[target=_blank]'),\n   * ]);\n   * ```\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.evaluate(() => window.open('https://example.com')),\n   * ]);\n   * ```\n   */\n  Popup = 'popup',\n  /**\n   * Emitted when a page issues a request and contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * The object is readonly. See {@link Page.setRequestInterception} for\n   * intercepting and mutating requests.\n   */\n  Request = 'request',\n  /**\n   * Emitted when a request ended up loading from cache. Contains a\n   * {@link HTTPRequest}.\n   *\n   * @remarks\n   * For certain requests, might contain undefined.\n   * {@link https://crbug.com/750469}\n   */\n  RequestServedFromCache = 'requestservedfromcache',\n  /**\n   * Emitted when a request fails, for example by timing out.\n   *\n   * Contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * HTTP Error responses, such as 404 or 503, are still successful responses\n   * from HTTP standpoint, so request will complete with `requestfinished` event\n   * and not with `requestfailed`.\n   */\n  RequestFailed = 'requestfailed',\n  /**\n   * Emitted when a request finishes successfully. Contains a\n   * {@link HTTPRequest}.\n   */\n  RequestFinished = 'requestfinished',\n  /**\n   * Emitted when a response is received. Contains a {@link HTTPResponse}.\n   */\n  Response = 'response',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is spawned by the page.\n   */\n  WorkerCreated = 'workercreated',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is destroyed by the page.\n   */\n  WorkerDestroyed = 'workerdestroyed',\n}\n\n/**\n * Denotes the objects received by callback functions for page events.\n *\n * See {@link PageEvent} for more detail on the events and when they are\n * emitted.\n *\n * @public\n */\nexport interface PageEvents extends Record<EventType, unknown> {\n  [PageEvent.Close]: undefined;\n  [PageEvent.Console]: ConsoleMessage;\n  [PageEvent.Dialog]: Dialog;\n  [PageEvent.DOMContentLoaded]: undefined;\n  [PageEvent.Error]: Error;\n  [PageEvent.FrameAttached]: Frame;\n  [PageEvent.FrameDetached]: Frame;\n  [PageEvent.FrameNavigated]: Frame;\n  [PageEvent.Load]: undefined;\n  [PageEvent.Metrics]: {title: string; metrics: Metrics};\n  [PageEvent.PageError]: Error;\n  [PageEvent.Popup]: Page | null;\n  [PageEvent.Request]: HTTPRequest;\n  [PageEvent.Response]: HTTPResponse;\n  [PageEvent.RequestFailed]: HTTPRequest;\n  [PageEvent.RequestFinished]: HTTPRequest;\n  [PageEvent.RequestServedFromCache]: HTTPRequest;\n  [PageEvent.WorkerCreated]: WebWorker;\n  [PageEvent.WorkerDestroyed]: WebWorker;\n}\n\n/**\n * @public\n */\nexport interface NewDocumentScriptEvaluation {\n  identifier: string;\n}\n\n/**\n * @internal\n */\nexport function setDefaultScreenshotOptions(options: ScreenshotOptions): void {\n  options.optimizeForSpeed ??= false;\n  options.type ??= 'png';\n  options.fromSurface ??= true;\n  options.fullPage ??= false;\n  options.omitBackground ??= false;\n  options.encoding ??= 'binary';\n  options.captureBeyondViewport ??= true;\n}\n\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEvent} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link EventEmitter.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nexport abstract class Page extends EventEmitter<PageEvents> {\n  /**\n   * @internal\n   */\n  _isDragging = false;\n  /**\n   * @internal\n   */\n  _timeoutSettings = new TimeoutSettings();\n\n  #requestHandlers = new WeakMap<Handler<HTTPRequest>, Handler<HTTPRequest>>();\n\n  #inflight$ = new ReplaySubject<number>(1);\n\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n\n    fromEmitterEvent(this, PageEvent.Request)\n      .pipe(\n        mergeMap(originalRequest => {\n          return concat(\n            of(1),\n            merge(\n              fromEmitterEvent(this, PageEvent.RequestFailed),\n              fromEmitterEvent(this, PageEvent.RequestFinished),\n              fromEmitterEvent(this, PageEvent.Response).pipe(\n                map(response => {\n                  return response.request();\n                })\n              )\n            ).pipe(\n              filter(request => {\n                return request.id === originalRequest.id;\n              }),\n              take(1),\n              map(() => {\n                return -1;\n              })\n            )\n          );\n        }),\n        mergeScan((acc, addend) => {\n          return of(acc + addend);\n        }, 0),\n        takeUntil(fromEmitterEvent(this, PageEvent.Close)),\n        startWith(0)\n      )\n      .subscribe(this.#inflight$);\n  }\n\n  /**\n   * `true` if the service worker are being bypassed, `false` otherwise.\n   */\n  abstract isServiceWorkerBypassed(): boolean;\n\n  /**\n   * `true` if drag events are being intercepted, `false` otherwise.\n   *\n   * @deprecated We no longer support intercepting drag payloads. Use the new\n   * drag APIs found on {@link ElementHandle} to drag (or just use the\n   * {@link Page | Page.mouse}).\n   */\n  abstract isDragInterceptionEnabled(): boolean;\n\n  /**\n   * `true` if the page has JavaScript enabled, `false` otherwise.\n   */\n  abstract isJavaScriptEnabled(): boolean;\n\n  /**\n   * Listen to page events.\n   *\n   * @remarks\n   * This method exists to define event typings and handle proper wireup of\n   * cooperative request interception. Actual event listening and dispatching is\n   * delegated to {@link EventEmitter}.\n   *\n   * @internal\n   */\n  override on<K extends keyof EventsWithWildcard<PageEvents>>(\n    type: K,\n    handler: (event: EventsWithWildcard<PageEvents>[K]) => void\n  ): this {\n    if (type !== PageEvent.Request) {\n      return super.on(type, handler);\n    }\n    let wrapper = this.#requestHandlers.get(\n      handler as (event: PageEvents[PageEvent.Request]) => void\n    );\n    if (wrapper === undefined) {\n      wrapper = (event: HTTPRequest) => {\n        event.enqueueInterceptAction(() => {\n          return handler(event as EventsWithWildcard<PageEvents>[K]);\n        });\n      };\n      this.#requestHandlers.set(\n        handler as (event: PageEvents[PageEvent.Request]) => void,\n        wrapper\n      );\n    }\n    return super.on(\n      type,\n      wrapper as (event: EventsWithWildcard<PageEvents>[K]) => void\n    );\n  }\n\n  /**\n   * @internal\n   */\n  override off<K extends keyof EventsWithWildcard<PageEvents>>(\n    type: K,\n    handler: (event: EventsWithWildcard<PageEvents>[K]) => void\n  ): this {\n    if (type === PageEvent.Request) {\n      handler =\n        (this.#requestHandlers.get(\n          handler as (\n            event: EventsWithWildcard<PageEvents>[PageEvent.Request]\n          ) => void\n        ) as (event: EventsWithWildcard<PageEvents>[K]) => void) || handler;\n    }\n    return super.off(type, handler);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers file\n   * choosing.\n   *\n   * :::caution\n   *\n   * This must be called before the file chooser is launched. It will not return\n   * a currently active file chooser.\n   *\n   * :::\n   *\n   * @remarks\n   * In the \"headful\" browser, this method results in the native file picker\n   * dialog `not showing up` for the user.\n   *\n   * @example\n   * The following example clicks a button that issues a file chooser\n   * and then responds with `/tmp/myfile.pdf` as if a user has selected this file.\n   *\n   * ```ts\n   * const [fileChooser] = await Promise.all([\n   *   page.waitForFileChooser(),\n   *   page.click('#upload-file-button'),\n   *   // some button that triggers file selection\n   * ]);\n   * await fileChooser.accept(['/tmp/myfile.pdf']);\n   * ```\n   */\n  abstract waitForFileChooser(\n    options?: WaitTimeoutOptions\n  ): Promise<FileChooser>;\n\n  /**\n   * Sets the page's geolocation.\n   *\n   * @remarks\n   * Consider using {@link BrowserContext.overridePermissions} to grant\n   * permissions for the page to read its geolocation.\n   *\n   * @example\n   *\n   * ```ts\n   * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});\n   * ```\n   */\n  abstract setGeolocation(options: GeolocationOptions): Promise<void>;\n\n  /**\n   * A target this page was created from.\n   *\n   * @deprecated Use {@link Page.createCDPSession} directly.\n   */\n  abstract target(): Target;\n\n  /**\n   * Get the browser the page belongs to.\n   */\n  abstract browser(): Browser;\n\n  /**\n   * Get the browser context that the page belongs to.\n   */\n  abstract browserContext(): BrowserContext;\n\n  /**\n   * The page's main frame.\n   *\n   * @remarks\n   * Page is guaranteed to have a main frame which persists during navigations.\n   */\n  abstract mainFrame(): Frame;\n\n  /**\n   * Creates a Chrome Devtools Protocol session attached to the page.\n   */\n  abstract createCDPSession(): Promise<CDPSession>;\n\n  /**\n   * {@inheritDoc Keyboard}\n   */\n  abstract get keyboard(): Keyboard;\n\n  /**\n   * {@inheritDoc Touchscreen}\n   */\n  abstract get touchscreen(): Touchscreen;\n\n  /**\n   * {@inheritDoc Coverage}\n   */\n  abstract get coverage(): Coverage;\n\n  /**\n   * {@inheritDoc Tracing}\n   */\n  abstract get tracing(): Tracing;\n\n  /**\n   * {@inheritDoc Accessibility}\n   */\n  abstract get accessibility(): Accessibility;\n\n  /**\n   * An array of all frames attached to the page.\n   */\n  abstract frames(): Frame[];\n\n  /**\n   * All of the dedicated {@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n   * WebWorkers} associated with the page.\n   *\n   * @remarks\n   * This does not contain ServiceWorkers\n   */\n  abstract workers(): WebWorker[];\n\n  /**\n   * Activating request interception enables {@link HTTPRequest.abort},\n   * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods. This\n   * provides the capability to modify network requests that are made by a page.\n   *\n   * Once request interception is enabled, every request will stall unless it's\n   * continued, responded or aborted; or completed using the browser cache.\n   *\n   * See the\n   * {@link https://pptr.dev/next/guides/request-interception|Request interception guide}\n   * for more details.\n   *\n   * @example\n   * An example of a naïve request interceptor that aborts all image requests:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.setRequestInterception(true);\n   *   page.on('request', interceptedRequest => {\n   *     if (\n   *       interceptedRequest.url().endsWith('.png') ||\n   *       interceptedRequest.url().endsWith('.jpg')\n   *     )\n   *       interceptedRequest.abort();\n   *     else interceptedRequest.continue();\n   *   });\n   *   await page.goto('https://example.com');\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param value - Whether to enable request interception.\n   */\n  abstract setRequestInterception(value: boolean): Promise<void>;\n\n  /**\n   * Toggles ignoring of service worker for each request.\n   *\n   * @param bypass - Whether to bypass service worker and load from network.\n   */\n  abstract setBypassServiceWorker(bypass: boolean): Promise<void>;\n\n  /**\n   * @param enabled - Whether to enable drag interception.\n   *\n   * @deprecated We no longer support intercepting drag payloads. Use the new\n   * drag APIs found on {@link ElementHandle} to drag (or just use the\n   * {@link Page | Page.mouse}).\n   */\n  abstract setDragInterception(enabled: boolean): Promise<void>;\n\n  /**\n   * Sets the network connection to offline.\n   *\n   * It does not change the parameters used in {@link Page.emulateNetworkConditions}\n   *\n   * @param enabled - When `true`, enables offline mode for the page.\n   */\n  abstract setOfflineMode(enabled: boolean): Promise<void>;\n\n  /**\n   * This does not affect WebSockets and WebRTC PeerConnections (see\n   * https://crbug.com/563644). To set the page offline, you can use\n   * {@link Page.setOfflineMode}.\n   *\n   * A list of predefined network conditions can be used by importing\n   * {@link PredefinedNetworkConditions}.\n   *\n   * @example\n   *\n   * ```ts\n   * import {PredefinedNetworkConditions} from 'puppeteer';\n   * const slow3G = PredefinedNetworkConditions['Slow 3G'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulateNetworkConditions(slow3G);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param networkConditions - Passing `null` disables network condition\n   * emulation.\n   */\n  abstract emulateNetworkConditions(\n    networkConditions: NetworkConditions | null\n  ): Promise<void>;\n\n  /**\n   * This setting will change the default maximum navigation time for the\n   * following methods and related shortcuts:\n   *\n   * - {@link Page.goBack | page.goBack(options)}\n   *\n   * - {@link Page.goForward | page.goForward(options)}\n   *\n   * - {@link Page.goto | page.goto(url,options)}\n   *\n   * - {@link Page.reload | page.reload(options)}\n   *\n   * - {@link Page.setContent | page.setContent(html,options)}\n   *\n   * - {@link Page.waitForNavigation | page.waitForNavigation(options)}\n   *   @param timeout - Maximum navigation time in milliseconds.\n   */\n  abstract setDefaultNavigationTimeout(timeout: number): void;\n\n  /**\n   * @param timeout - Maximum time in milliseconds.\n   */\n  abstract setDefaultTimeout(timeout: number): void;\n\n  /**\n   * Maximum time in milliseconds.\n   */\n  abstract getDefaultTimeout(): number;\n\n  /**\n   * Creates a locator for the provided selector. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Selector extends string>(\n    selector: Selector\n  ): Locator<NodeFor<Selector>>;\n\n  /**\n   * Creates a locator for the provided function. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Ret>(func: () => Awaitable<Ret>): Locator<Ret>;\n  locator<Selector extends string, Ret>(\n    selectorOrFunc: Selector | (() => Awaitable<Ret>)\n  ): Locator<NodeFor<Selector>> | Locator<Ret> {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n\n  /**\n   * A shortcut for {@link Locator.race} that does not require static imports.\n   *\n   * @internal\n   */\n  locatorRace<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return Locator.race(locators);\n  }\n\n  /**\n   * Runs `document.querySelector` within the page. If no element matches the\n   * selector, the return value resolves to `null`.\n   *\n   * @param selector - A `selector` to query page for\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query page for.\n   */\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().$(selector);\n  }\n\n  /**\n   * The method runs `document.querySelectorAll` within the page. If no elements\n   * match the selector, the return value resolves to `[]`.\n   *\n   * @param selector - A `selector` to query page for\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n   */\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    return await this.mainFrame().$$(selector);\n  }\n\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Page.evaluate | page.evaluate} and\n   * `page.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * If the function passed to `page.evaluateHandle` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle('document');\n   * ```\n   *\n   * @example\n   * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle(() => document.body);\n   * const resultHandle = await page.evaluateHandle(\n   *   body => body.innerHTML,\n   *   aHandle\n   * );\n   * console.log(await resultHandle.jsonValue());\n   * await resultHandle.dispose();\n   * ```\n   *\n   * Most of the time this function returns a {@link JSHandle},\n   * but if `pageFunction` returns a reference to an element,\n   * you instead get an {@link ElementHandle} back:\n   *\n   * @example\n   *\n   * ```ts\n   * const button = await page.evaluateHandle(() =>\n   *   document.querySelector('button')\n   * );\n   * // can call `click` because `button` is an `ElementHandle`\n   * await button.click();\n   * ```\n   *\n   * The TypeScript definitions assume that `evaluateHandle` returns\n   * a `JSHandle`, but if you know it's going to return an\n   * `ElementHandle`, pass it as the generic argument:\n   *\n   * ```ts\n   * const button = await page.evaluateHandle<ElementHandle>(...);\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.mainFrame().evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * This method iterates the JavaScript heap and finds all objects with the\n   * given prototype.\n   *\n   * @example\n   *\n   * ```ts\n   * // Create a Map object\n   * await page.evaluate(() => (window.map = new Map()));\n   * // Get a handle to the Map object prototype\n   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n   * // Query all map instances into an array\n   * const mapInstances = await page.queryObjects(mapPrototype);\n   * // Count amount of map objects in heap\n   * const count = await page.evaluate(maps => maps.length, mapInstances);\n   * await mapInstances.dispose();\n   * await mapPrototype.dispose();\n   * ```\n   *\n   * @param prototypeHandle - a handle to the object prototype.\n   * @returns Promise which resolves to a handle to an array of objects with\n   * this prototype.\n   */\n  abstract queryObjects<Prototype>(\n    prototypeHandle: JSHandle<Prototype>\n  ): Promise<JSHandle<Prototype[]>>;\n\n  /**\n   * This method runs `document.querySelector` within the page and passes the\n   * result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   *\n   * If no element is found matching `selector`, the method will throw an error.\n   *\n   * If `pageFunction` returns a promise `$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await page.$eval('#search', el => el.value);\n   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n   * const html = await page.$eval('.main-container', el => el.outerHTML);\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * const searchValue = await page.$eval(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const searchValue = await page.$eval<string>(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of `document.querySelector(selector)` as its\n   * first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    return await this.mainFrame().$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the page and passes the result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * // get the amount of divs on the page\n   * const divCount = await page.$$eval('div', divs => divs.length);\n   *\n   * // get the text content of all the `.options` elements:\n   * const options = await page.$$eval('div > span.options', options => {\n   *   return options.map(option => option.textContent);\n   * });\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element[]`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n   *   return elements.map(e => e.value);\n   * });\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const allInputValues = await page.$$eval<string[]>(\n   *   'input',\n   *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of\n   * `Array.from(document.querySelectorAll(selector))` as its first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    return await this.mainFrame().$$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * If no URLs are specified, this method returns cookies for the current page\n   * URL. If URLs are specified, only cookies for those URLs are returned.\n   */\n  abstract cookies(...urls: string[]): Promise<Cookie[]>;\n\n  abstract deleteCookie(...cookies: DeleteCookiesRequest[]): Promise<void>;\n\n  /**\n   * @example\n   *\n   * ```ts\n   * await page.setCookie(cookieObject1, cookieObject2);\n   * ```\n   */\n  abstract setCookie(...cookies: CookieParam[]): Promise<void>;\n\n  /**\n   * Adds a `<script>` tag into the page with the desired URL or content.\n   *\n   * @remarks\n   * Shortcut for\n   * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  async addScriptTag(\n    options: FrameAddScriptTagOptions\n  ): Promise<ElementHandle<HTMLScriptElement>> {\n    return await this.mainFrame().addScriptTag(options);\n  }\n\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired URL or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * Shortcut for\n   * {@link Frame.(addStyleTag:2) | page.mainFrame().addStyleTag(options)}.\n   *\n   * @returns An {@link ElementHandle | element handle} to the injected `<link>`\n   * or `<style>` element.\n   */\n  async addStyleTag(\n    options: Omit<FrameAddStyleTagOptions, 'url'>\n  ): Promise<ElementHandle<HTMLStyleElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLLinkElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLStyleElement | HTMLLinkElement>> {\n    return await this.mainFrame().addStyleTag(options);\n  }\n\n  /**\n   * The method adds a function called `name` on the page's `window` object.\n   * When called, the function executes `puppeteerFunction` in node.js and\n   * returns a `Promise` which resolves to the return value of\n   * `puppeteerFunction`.\n   *\n   * If the puppeteerFunction returns a `Promise`, it will be awaited.\n   *\n   * :::note\n   *\n   * Functions installed via `page.exposeFunction` survive navigations.\n   *\n   * :::note\n   *\n   * @example\n   * An example of adding an `md5` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import crypto from 'crypto';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('md5', text =>\n   *     crypto.createHash('md5').update(text).digest('hex')\n   *   );\n   *   await page.evaluate(async () => {\n   *     // use window.md5 to compute hashes\n   *     const myString = 'PUPPETEER';\n   *     const myHash = await window.md5(myString);\n   *     console.log(`md5 of ${myString} is ${myHash}`);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * An example of adding a `window.readfile` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import fs from 'fs';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('readfile', async filePath => {\n   *     return new Promise((resolve, reject) => {\n   *       fs.readFile(filePath, 'utf8', (err, text) => {\n   *         if (err) reject(err);\n   *         else resolve(text);\n   *       });\n   *     });\n   *   });\n   *   await page.evaluate(async () => {\n   *     // use window.readfile to read contents of a file\n   *     const content = await window.readfile('/etc/hosts');\n   *     console.log(content);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param name - Name of the function on the window object\n   * @param pptrFunction - Callback function which will be called in Puppeteer's\n   * context.\n   */\n  abstract exposeFunction(\n    name: string,\n    pptrFunction: Function | {default: Function}\n  ): Promise<void>;\n\n  /**\n   * The method removes a previously added function via ${@link Page.exposeFunction}\n   * called `name` from the page's `window` object.\n   */\n  abstract removeExposedFunction(name: string): Promise<void>;\n\n  /**\n   * Provide credentials for `HTTP authentication`.\n   *\n   * @remarks\n   * To disable authentication, pass `null`.\n   */\n  abstract authenticate(credentials: Credentials): Promise<void>;\n\n  /**\n   * The extra HTTP headers will be sent with every request the page initiates.\n   *\n   * :::tip\n   *\n   * All HTTP header names are lowercased. (HTTP headers are\n   * case-insensitive, so this shouldn’t impact your server code.)\n   *\n   * :::\n   *\n   * :::note\n   *\n   * page.setExtraHTTPHeaders does not guarantee the order of headers in\n   * the outgoing requests.\n   *\n   * :::\n   *\n   * @param headers - An object containing additional HTTP headers to be sent\n   * with every request. All header values must be strings.\n   */\n  abstract setExtraHTTPHeaders(headers: Record<string, string>): Promise<void>;\n\n  /**\n   * @param userAgent - Specific user agent to use in this page\n   * @param userAgentData - Specific user agent client hint data to use in this\n   * page\n   * @returns Promise which resolves when the user agent is set.\n   */\n  abstract setUserAgent(\n    userAgent: string,\n    userAgentMetadata?: Protocol.Emulation.UserAgentMetadata\n  ): Promise<void>;\n\n  /**\n   * Object containing metrics as key/value pairs.\n   *\n   * @returns\n   *\n   * - `Timestamp` : The timestamp when the metrics sample was taken.\n   *\n   * - `Documents` : Number of documents in the page.\n   *\n   * - `Frames` : Number of frames in the page.\n   *\n   * - `JSEventListeners` : Number of events in the page.\n   *\n   * - `Nodes` : Number of DOM nodes in the page.\n   *\n   * - `LayoutCount` : Total number of full or partial page layout.\n   *\n   * - `RecalcStyleCount` : Total number of page style recalculations.\n   *\n   * - `LayoutDuration` : Combined durations of all page layouts.\n   *\n   * - `RecalcStyleDuration` : Combined duration of all page style\n   *   recalculations.\n   *\n   * - `ScriptDuration` : Combined duration of JavaScript execution.\n   *\n   * - `TaskDuration` : Combined duration of all tasks performed by the browser.\n   *\n   * - `JSHeapUsedSize` : Used JavaScript heap size.\n   *\n   * - `JSHeapTotalSize` : Total JavaScript heap size.\n   *\n   * @remarks\n   * All timestamps are in monotonic time: monotonically increasing time\n   * in seconds since an arbitrary point in the past.\n   */\n  abstract metrics(): Promise<Metrics>;\n\n  /**\n   * The page's URL.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.url | page.mainFrame().url()}.\n   */\n  url(): string {\n    return this.mainFrame().url();\n  }\n\n  /**\n   * The full HTML contents of the page, including the DOCTYPE.\n   */\n  async content(): Promise<string> {\n    return await this.mainFrame().content();\n  }\n\n  /**\n   * Set the content of the page.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - Parameters that has some properties.\n   *\n   * @remarks\n   *\n   * The parameter `options` might have the following options.\n   *\n   * - `timeout` : Maximum time in milliseconds for resources to load, defaults\n   *   to 30 seconds, pass `0` to disable timeout. The default value can be\n   *   changed by using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider setting markup succeeded, defaults to\n   *   `load`. Given an array of event strings, setting content is considered\n   *   to be successful after all events have been fired. Events can be\n   *   either:<br/>\n   * - `load` : consider setting content to be finished when the `load` event\n   *   is fired.<br/>\n   * - `domcontentloaded` : consider setting content to be finished when the\n   *   `DOMContentLoaded` event is fired.<br/>\n   * - `networkidle0` : consider setting content to be finished when there are\n   *   no more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider setting content to be finished when there are\n   *   no more than 2 network connections for at least `500` ms.\n   */\n  async setContent(html: string, options?: WaitForOptions): Promise<void> {\n    await this.mainFrame().setContent(html, options);\n  }\n\n  /**\n   * Navigates the page to the given `url`.\n   *\n   * @remarks\n   *\n   * Navigation to `about:blank` or navigation to the same URL with a different\n   * hash will succeed and return `null`.\n   *\n   * :::warning\n   *\n   * Headless mode doesn't support navigation to a PDF document. See the {@link\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n   * issue}.\n   *\n   * :::\n   *\n   * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.\n   *\n   * @param url - URL to navigate page to. The URL should include scheme, e.g.\n   * `https://`\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   * @throws If:\n   *\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   * - target URL is invalid.\n   * - the timeout is exceeded during navigation.\n   * - the remote server does not respond or is unreachable.\n   * - the main resource failed to load.\n   *\n   * This method will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n   * Server Error\". The status code for such responses can be retrieved by\n   * calling {@link HTTPResponse.status}.\n   */\n  async goto(url: string, options?: GoToOptions): Promise<HTTPResponse | null> {\n    return await this.mainFrame().goto(url, options);\n  }\n\n  /**\n   * Reloads the page.\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   */\n  abstract reload(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * Waits for the page to navigate to a new URL or to reload. It is useful when\n   * you run code that will indirectly cause the page to navigate.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(), // The promise resolves after navigation has finished\n   *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n   * ]);\n   * ```\n   *\n   * @remarks\n   *\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @param options - Navigation parameters which might have the following\n   * properties:\n   * @returns A `Promise` which resolves to the main resource response.\n   *\n   * - In case of multiple redirects, the navigation will resolve with the\n   *   response of the last redirect.\n   * - In case of navigation to a different anchor or navigation due to History\n   *   API usage, the navigation will resolve with `null`.\n   */\n  async waitForNavigation(\n    options: WaitForOptions = {}\n  ): Promise<HTTPResponse | null> {\n    return await this.mainFrame().waitForNavigation(options);\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched request\n   * @example\n   *\n   * ```ts\n   * const firstRequest = await page.waitForRequest(\n   *   'https://example.com/resource'\n   * );\n   * const finalRequest = await page.waitForRequest(\n   *   request => request.url() === 'https://example.com'\n   * );\n   * return finalRequest.response()?.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Waiting Parameters have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass\n   *   `0` to disable the timeout. The default value can be changed by using the\n   *   {@link Page.setDefaultTimeout} method.\n   */\n  waitForRequest(\n    urlOrPredicate: string | AwaitablePredicate<HTTPRequest>,\n    options: WaitTimeoutOptions = {}\n  ): Promise<HTTPRequest> {\n    const {timeout: ms = this._timeoutSettings.timeout()} = options;\n    if (typeof urlOrPredicate === 'string') {\n      const url = urlOrPredicate;\n      urlOrPredicate = (request: HTTPRequest) => {\n        return request.url() === url;\n      };\n    }\n    const observable$ = fromEmitterEvent(this, PageEvent.Request).pipe(\n      filterAsync(urlOrPredicate),\n      raceWith(\n        timeout(ms),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n    return firstValueFrom(observable$);\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for.\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched response.\n   * @example\n   *\n   * ```ts\n   * const firstResponse = await page.waitForResponse(\n   *   'https://example.com/resource'\n   * );\n   * const finalResponse = await page.waitForResponse(\n   *   response =>\n   *     response.url() === 'https://example.com' && response.status() === 200\n   * );\n   * const finalResponse = await page.waitForResponse(async response => {\n   *   return (await response.text()).includes('<html>');\n   * });\n   * return finalResponse.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Parameter have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n   *   pass `0` to disable the timeout. The default value can be changed by using\n   *   the {@link Page.setDefaultTimeout} method.\n   */\n  waitForResponse(\n    urlOrPredicate: string | AwaitablePredicate<HTTPResponse>,\n    options: WaitTimeoutOptions = {}\n  ): Promise<HTTPResponse> {\n    const {timeout: ms = this._timeoutSettings.timeout()} = options;\n    if (typeof urlOrPredicate === 'string') {\n      const url = urlOrPredicate;\n      urlOrPredicate = (response: HTTPResponse) => {\n        return response.url() === url;\n      };\n    }\n    const observable$ = fromEmitterEvent(this, PageEvent.Response).pipe(\n      filterAsync(urlOrPredicate),\n      raceWith(\n        timeout(ms),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n    return firstValueFrom(observable$);\n  }\n\n  /**\n   * Waits for the network to be idle.\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves once the network is idle.\n   */\n  waitForNetworkIdle(options: WaitForNetworkIdleOptions = {}): Promise<void> {\n    return firstValueFrom(this.waitForNetworkIdle$(options));\n  }\n\n  /**\n   * @internal\n   */\n  waitForNetworkIdle$(\n    options: WaitForNetworkIdleOptions = {}\n  ): Observable<void> {\n    const {\n      timeout: ms = this._timeoutSettings.timeout(),\n      idleTime = NETWORK_IDLE_TIME,\n      concurrency = 0,\n    } = options;\n\n    return this.#inflight$.pipe(\n      switchMap(inflight => {\n        if (inflight > concurrency) {\n          return EMPTY;\n        }\n        return timer(idleTime);\n      }),\n      map(() => {}),\n      raceWith(\n        timeout(ms),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n  }\n\n  /**\n   * Waits for a frame matching the given conditions to appear.\n   *\n   * @example\n   *\n   * ```ts\n   * const frame = await page.waitForFrame(async frame => {\n   *   return frame.name() === 'Test';\n   * });\n   * ```\n   */\n  async waitForFrame(\n    urlOrPredicate: string | ((frame: Frame) => Awaitable<boolean>),\n    options: WaitTimeoutOptions = {}\n  ): Promise<Frame> {\n    const {timeout: ms = this.getDefaultTimeout()} = options;\n\n    if (isString(urlOrPredicate)) {\n      urlOrPredicate = (frame: Frame) => {\n        return urlOrPredicate === frame.url();\n      };\n    }\n\n    return await firstValueFrom(\n      merge(\n        fromEmitterEvent(this, PageEvent.FrameAttached),\n        fromEmitterEvent(this, PageEvent.FrameNavigated),\n        from(this.frames())\n      ).pipe(\n        filterAsync(urlOrPredicate),\n        first(),\n        raceWith(\n          timeout(ms),\n          fromEmitterEvent(this, PageEvent.Close).pipe(\n            map(() => {\n              throw new TargetCloseError('Page closed.');\n            })\n          )\n        )\n      )\n    );\n  }\n\n  /**\n   * This method navigate to the previous page in history.\n   * @param options - Navigation parameters\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go back, resolves to `null`.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil` : When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  abstract goBack(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * This method navigate to the next page in history.\n   * @param options - Navigation Parameter\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go forward, resolves to `null`.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  abstract goForward(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * Brings page to front (activates tab).\n   */\n  abstract bringToFront(): Promise<void>;\n\n  /**\n   * Emulates a given device's metrics and user agent.\n   *\n   * To aid emulation, Puppeteer provides a list of known devices that can be\n   * via {@link KnownDevices}.\n   *\n   * @remarks\n   * This method is a shortcut for calling two methods:\n   * {@link Page.setUserAgent} and {@link Page.setViewport}.\n   *\n   * This method will resize the page. A lot of websites don't expect phones to\n   * change size, so you should emulate before navigating to the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import {KnownDevices} from 'puppeteer';\n   * const iPhone = KnownDevices['iPhone 6'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulate(iPhone);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   */\n  async emulate(device: Device): Promise<void> {\n    await Promise.all([\n      this.setUserAgent(device.userAgent),\n      this.setViewport(device.viewport),\n    ]);\n  }\n\n  /**\n   * @param enabled - Whether or not to enable JavaScript on the page.\n   * @remarks\n   * NOTE: changing this value won't affect scripts that have already been run.\n   * It will take full effect on the next navigation.\n   */\n  abstract setJavaScriptEnabled(enabled: boolean): Promise<void>;\n\n  /**\n   * Toggles bypassing page's Content-Security-Policy.\n   * @param enabled - sets bypassing of page's Content-Security-Policy.\n   * @remarks\n   * NOTE: CSP bypassing happens at the moment of CSP initialization rather than\n   * evaluation. Usually, this means that `page.setBypassCSP` should be called\n   * before navigating to the domain.\n   */\n  abstract setBypassCSP(enabled: boolean): Promise<void>;\n\n  /**\n   * @param type - Changes the CSS media type of the page. The only allowed\n   * values are `screen`, `print` and `null`. Passing `null` disables CSS media\n   * emulation.\n   * @example\n   *\n   * ```ts\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → false\n   *\n   * await page.emulateMediaType('print');\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → false\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → true\n   *\n   * await page.emulateMediaType(null);\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → false\n   * ```\n   */\n  abstract emulateMediaType(type?: string): Promise<void>;\n\n  /**\n   * Enables CPU throttling to emulate slow CPUs.\n   * @param factor - slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).\n   */\n  abstract emulateCPUThrottling(factor: number | null): Promise<void>;\n\n  /**\n   * @param features - `<?Array<Object>>` Given an array of media feature\n   * objects, emulates CSS media features on the page. Each media feature object\n   * must have the following properties:\n   * @example\n   *\n   * ```ts\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * // → false\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([{name: 'color-gamut', value: 'p3'}]);\n   * await page.evaluate(() => matchMedia('(color-gamut: srgb)').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('(color-gamut: p3)').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('(color-gamut: rec2020)').matches);\n   * // → false\n   * ```\n   */\n  abstract emulateMediaFeatures(features?: MediaFeature[]): Promise<void>;\n\n  /**\n   * @param timezoneId - Changes the timezone of the page. See\n   * {@link https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt | ICU’s metaZones.txt}\n   * for a list of supported timezone IDs. Passing\n   * `null` disables timezone emulation.\n   */\n  abstract emulateTimezone(timezoneId?: string): Promise<void>;\n\n  /**\n   * Emulates the idle state.\n   * If no arguments set, clears idle state emulation.\n   *\n   * @example\n   *\n   * ```ts\n   * // set idle emulation\n   * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});\n   *\n   * // do some checks here\n   * ...\n   *\n   * // clear idle emulation\n   * await page.emulateIdleState();\n   * ```\n   *\n   * @param overrides - Mock idle state. If not set, clears idle overrides\n   */\n  abstract emulateIdleState(overrides?: {\n    isUserActive: boolean;\n    isScreenUnlocked: boolean;\n  }): Promise<void>;\n\n  /**\n   * Simulates the given vision deficiency on the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.goto('https://v8.dev/blog/10-years');\n   *\n   *   await page.emulateVisionDeficiency('achromatopsia');\n   *   await page.screenshot({path: 'achromatopsia.png'});\n   *\n   *   await page.emulateVisionDeficiency('deuteranopia');\n   *   await page.screenshot({path: 'deuteranopia.png'});\n   *\n   *   await page.emulateVisionDeficiency('blurredVision');\n   *   await page.screenshot({path: 'blurred-vision.png'});\n   *\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param type - the type of deficiency to simulate, or `'none'` to reset.\n   */\n  abstract emulateVisionDeficiency(\n    type?: Protocol.Emulation.SetEmulatedVisionDeficiencyRequest['type']\n  ): Promise<void>;\n\n  /**\n   * `page.setViewport` will resize the page. A lot of websites don't expect\n   * phones to change size, so you should set the viewport before navigating to\n   * the page.\n   *\n   * In the case of multiple pages in a single browser, each page can have its\n   * own viewport size.\n   * @example\n   *\n   * ```ts\n   * const page = await browser.newPage();\n   * await page.setViewport({\n   *   width: 640,\n   *   height: 480,\n   *   deviceScaleFactor: 1,\n   * });\n   * await page.goto('https://example.com');\n   * ```\n   *\n   * @param viewport -\n   * @remarks\n   * NOTE: in certain cases, setting viewport will reload the page in order to\n   * set the isMobile or hasTouch properties.\n   */\n  abstract setViewport(viewport: Viewport): Promise<void>;\n\n  /**\n   * Returns the current page viewport settings without checking the actual page\n   * viewport.\n   *\n   * This is either the viewport set with the previous {@link Page.setViewport}\n   * call or the default viewport set via\n   * {@link BrowserConnectOptions | BrowserConnectOptions.defaultViewport}.\n   */\n  abstract viewport(): Viewport | null;\n\n  /**\n   * Evaluates a function in the page's context and returns the result.\n   *\n   * If the function passed to `page.evaluate` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const result = await frame.evaluate(() => {\n   *   return Promise.resolve(8 * 7);\n   * });\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluate('1 + 2');\n   * ```\n   *\n   * To get the best TypeScript experience, you should pass in as the\n   * generic the type of `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluate(() => 2);\n   * ```\n   *\n   * @example\n   *\n   * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n   * as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const bodyHandle = await page.$('body');\n   * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n   * await bodyHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   *\n   * @returns the return value of `pageFunction`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.mainFrame().evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Adds a function which would be invoked in one of the following scenarios:\n   *\n   * - whenever the page is navigated\n   *\n   * - whenever the child frame is attached or navigated. In this case, the\n   *   function is invoked in the context of the newly attached frame.\n   *\n   * The function is invoked after the document was created but before any of\n   * its scripts were run. This is useful to amend the JavaScript environment,\n   * e.g. to seed `Math.random`.\n   * @param pageFunction - Function to be evaluated in browser context\n   * @param args - Arguments to pass to `pageFunction`\n   * @example\n   * An example of overriding the navigator.languages property before the page loads:\n   *\n   * ```ts\n   * // preload.js\n   *\n   * // overwrite the `languages` property to use a custom getter\n   * Object.defineProperty(navigator, 'languages', {\n   *   get: function () {\n   *     return ['en-US', 'en', 'bn'];\n   *   },\n   * });\n   *\n   * // In your puppeteer script, assuming the preload.js file is\n   * // in same folder of our script.\n   * const preloadFile = fs.readFileSync('./preload.js', 'utf8');\n   * await page.evaluateOnNewDocument(preloadFile);\n   * ```\n   */\n  abstract evaluateOnNewDocument<\n    Params extends unknown[],\n    Func extends (...args: Params) => unknown = (...args: Params) => unknown,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<NewDocumentScriptEvaluation>;\n\n  /**\n   * Removes script that injected into page by Page.evaluateOnNewDocument.\n   *\n   * @param identifier - script identifier\n   */\n  abstract removeScriptToEvaluateOnNewDocument(\n    identifier: string\n  ): Promise<void>;\n\n  /**\n   * Toggles ignoring cache for each request based on the enabled state. By\n   * default, caching is enabled.\n   * @param enabled - sets the `enabled` state of cache\n   * @defaultValue `true`\n   */\n  abstract setCacheEnabled(enabled?: boolean): Promise<void>;\n\n  /**\n   * @internal\n   */\n  async _maybeWriteBufferToFile(\n    path: string | undefined,\n    buffer: Buffer\n  ): Promise<void> {\n    if (!path) {\n      return;\n    }\n\n    const fs = await importFSPromises();\n\n    await fs.writeFile(path, buffer);\n  }\n\n  /**\n   * Captures a screencast of this {@link Page | page}.\n   *\n   * @example\n   * Recording a {@link Page | page}:\n   *\n   * ```\n   * import puppeteer from 'puppeteer';\n   *\n   * // Launch a browser\n   * const browser = await puppeteer.launch();\n   *\n   * // Create a new page\n   * const page = await browser.newPage();\n   *\n   * // Go to your site.\n   * await page.goto(\"https://www.example.com\");\n   *\n   * // Start recording.\n   * const recorder = await page.screencast({path: 'recording.webm'});\n   *\n   * // Do something.\n   *\n   * // Stop recording.\n   * await recorder.stop();\n   *\n   * browser.close();\n   * ```\n   *\n   * @param options - Configures screencast behavior.\n   *\n   * @experimental\n   *\n   * @remarks\n   *\n   * All recordings will be {@link https://www.webmproject.org/ | WebM} format using\n   * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.\n   *\n   * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.\n   */\n  async screencast(\n    options: Readonly<ScreencastOptions> = {}\n  ): Promise<ScreenRecorder> {\n    const [{ScreenRecorder}, [width, height, devicePixelRatio]] =\n      await Promise.all([\n        import('../node/ScreenRecorder.js'),\n        this.#getNativePixelDimensions(),\n      ]);\n\n    let crop: BoundingBox | undefined;\n    if (options.crop) {\n      const {\n        x,\n        y,\n        width: cropWidth,\n        height: cropHeight,\n      } = roundRectangle(normalizeRectangle(options.crop));\n      if (x < 0 || y < 0) {\n        throw new Error(\n          `\\`crop.x\\` and \\`crop.y\\` must be greater than or equal to 0.`\n        );\n      }\n      if (cropWidth <= 0 || cropHeight <= 0) {\n        throw new Error(\n          `\\`crop.height\\` and \\`crop.width\\` must be greater than or equal to 0.`\n        );\n      }\n\n      const viewportWidth = width / devicePixelRatio;\n      const viewportHeight = height / devicePixelRatio;\n      if (x + cropWidth > viewportWidth) {\n        throw new Error(\n          `\\`crop.width\\` cannot be larger than the viewport width (${viewportWidth}).`\n        );\n      }\n      if (y + cropHeight > viewportHeight) {\n        throw new Error(\n          `\\`crop.height\\` cannot be larger than the viewport height (${viewportHeight}).`\n        );\n      }\n\n      crop = {\n        x: x * devicePixelRatio,\n        y: y * devicePixelRatio,\n        width: cropWidth * devicePixelRatio,\n        height: cropHeight * devicePixelRatio,\n      };\n    }\n    if (options.speed !== undefined && options.speed <= 0) {\n      throw new Error(`\\`speed\\` must be greater than 0.`);\n    }\n    if (options.scale !== undefined && options.scale <= 0) {\n      throw new Error(`\\`scale\\` must be greater than 0.`);\n    }\n\n    const recorder = new ScreenRecorder(this, width, height, {\n      ...options,\n      path: options.ffmpegPath,\n      crop,\n    });\n    try {\n      await this._startScreencast();\n    } catch (error) {\n      void recorder.stop();\n      throw error;\n    }\n    if (options.path) {\n      const {createWriteStream} = await import('fs');\n      const stream = createWriteStream(options.path, 'binary');\n      recorder.pipe(stream);\n    }\n    return recorder;\n  }\n\n  #screencastSessionCount = 0;\n  #startScreencastPromise: Promise<void> | undefined;\n\n  /**\n   * @internal\n   */\n  async _startScreencast(): Promise<void> {\n    ++this.#screencastSessionCount;\n    if (!this.#startScreencastPromise) {\n      this.#startScreencastPromise = this.mainFrame()\n        .client.send('Page.startScreencast', {format: 'png'})\n        .then(() => {\n          // Wait for the first frame.\n          return new Promise(resolve => {\n            return this.mainFrame().client.once('Page.screencastFrame', () => {\n              return resolve();\n            });\n          });\n        });\n    }\n    await this.#startScreencastPromise;\n  }\n\n  /**\n   * @internal\n   */\n  async _stopScreencast(): Promise<void> {\n    --this.#screencastSessionCount;\n    if (!this.#startScreencastPromise) {\n      return;\n    }\n    this.#startScreencastPromise = undefined;\n    if (this.#screencastSessionCount === 0) {\n      await this.mainFrame().client.send('Page.stopScreencast');\n    }\n  }\n\n  /**\n   * Gets the native, non-emulated dimensions of the viewport.\n   */\n  async #getNativePixelDimensions(): Promise<\n    readonly [width: number, height: number, devicePixelRatio: number]\n  > {\n    const viewport = this.viewport();\n    using stack = new DisposableStack();\n    if (viewport && viewport.deviceScaleFactor !== 0) {\n      await this.setViewport({...viewport, deviceScaleFactor: 0});\n      stack.defer(() => {\n        void this.setViewport(viewport).catch(debugError);\n      });\n    }\n    return await this.mainFrame()\n      .isolatedRealm()\n      .evaluate(() => {\n        return [\n          window.visualViewport!.width * window.devicePixelRatio,\n          window.visualViewport!.height * window.devicePixelRatio,\n          window.devicePixelRatio,\n        ] as const;\n      });\n  }\n\n  /**\n   * Captures a screenshot of this {@link Page | page}.\n   *\n   * @param options - Configures screenshot behavior.\n   */\n  async screenshot(\n    options: Readonly<ScreenshotOptions> & {encoding: 'base64'}\n  ): Promise<string>;\n  async screenshot(options?: Readonly<ScreenshotOptions>): Promise<Buffer>;\n  @guarded(function () {\n    return this.browser();\n  })\n  async screenshot(\n    userOptions: Readonly<ScreenshotOptions> = {}\n  ): Promise<Buffer | string> {\n    await this.bringToFront();\n\n    // TODO: use structuredClone after Node 16 support is dropped.\n    const options = {\n      ...userOptions,\n      clip: userOptions.clip\n        ? {\n            ...userOptions.clip,\n          }\n        : undefined,\n    };\n    if (options.type === undefined && options.path !== undefined) {\n      const filePath = options.path;\n      // Note we cannot use Node.js here due to browser compatability.\n      const extension = filePath\n        .slice(filePath.lastIndexOf('.') + 1)\n        .toLowerCase();\n      switch (extension) {\n        case 'png':\n          options.type = 'png';\n          break;\n        case 'jpeg':\n        case 'jpg':\n          options.type = 'jpeg';\n          break;\n        case 'webp':\n          options.type = 'webp';\n          break;\n      }\n    }\n    if (options.quality !== undefined) {\n      if (options.quality < 0 && options.quality > 100) {\n        throw new Error(\n          `Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`\n        );\n      }\n      if (\n        options.type === undefined ||\n        !['jpeg', 'webp'].includes(options.type)\n      ) {\n        throw new Error(\n          `${options.type ?? 'png'} screenshots do not support 'quality'.`\n        );\n      }\n    }\n    if (options.clip) {\n      if (options.clip.width <= 0) {\n        throw new Error(\"'width' in 'clip' must be positive.\");\n      }\n      if (options.clip.height <= 0) {\n        throw new Error(\"'height' in 'clip' must be positive.\");\n      }\n    }\n\n    setDefaultScreenshotOptions(options);\n\n    await using stack = new AsyncDisposableStack();\n    if (options.clip) {\n      if (options.fullPage) {\n        throw new Error(\"'clip' and 'fullPage' are mutually exclusive\");\n      }\n\n      options.clip = roundRectangle(normalizeRectangle(options.clip));\n    } else {\n      if (options.fullPage) {\n        // If `captureBeyondViewport` is `false`, then we set the viewport to\n        // capture the full page. Note this may be affected by on-page CSS and\n        // JavaScript.\n        if (!options.captureBeyondViewport) {\n          const scrollDimensions = await this.mainFrame()\n            .isolatedRealm()\n            .evaluate(() => {\n              const element = document.documentElement;\n              return {\n                width: element.scrollWidth,\n                height: element.scrollHeight,\n              };\n            });\n          const viewport = this.viewport();\n          await this.setViewport({\n            ...viewport,\n            ...scrollDimensions,\n          });\n          stack.defer(async () => {\n            if (viewport) {\n              await this.setViewport(viewport).catch(debugError);\n            } else {\n              await this.setViewport({\n                width: 0,\n                height: 0,\n              }).catch(debugError);\n            }\n          });\n        }\n      } else {\n        options.captureBeyondViewport = false;\n      }\n    }\n\n    const data = await this._screenshot(options);\n    if (options.encoding === 'base64') {\n      return data;\n    }\n    const buffer = Buffer.from(data, 'base64');\n    await this._maybeWriteBufferToFile(options.path, buffer);\n    return buffer;\n  }\n\n  /**\n   * @internal\n   */\n  abstract _screenshot(options: Readonly<ScreenshotOptions>): Promise<string>;\n\n  /**\n   * Generates a PDF of the page with the `print` CSS media type.\n   *\n   * @param options - options for generating the PDF.\n   *\n   * @remarks\n   *\n   * To generate a PDF with the `screen` media type, call\n   * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before\n   * calling `page.pdf()`.\n   *\n   * By default, `page.pdf()` generates a pdf with modified colors for printing.\n   * Use the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}\n   * property to force rendering of exact colors.\n   */\n  abstract createPDFStream(\n    options?: PDFOptions\n  ): Promise<ReadableStream<Uint8Array>>;\n\n  /**\n   * {@inheritDoc Page.createPDFStream}\n   */\n  abstract pdf(options?: PDFOptions): Promise<Buffer>;\n\n  /**\n   * The page's title\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n   */\n  async title(): Promise<string> {\n    return await this.mainFrame().title();\n  }\n\n  abstract close(options?: {runBeforeUnload?: boolean}): Promise<void>;\n\n  /**\n   * Indicates that the page has been closed.\n   * @returns\n   */\n  abstract isClosed(): boolean;\n\n  /**\n   * {@inheritDoc Mouse}\n   */\n  abstract get mouse(): Mouse;\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.mouse} to click in the center of the\n   * element. If there's no element matching `selector`, the method throws an\n   * error.\n   *\n   * @remarks\n   *\n   * Bear in mind that if `click()` triggers a navigation event and\n   * there's a separate `page.waitForNavigation()` promise to be resolved, you\n   * may end up with a race condition that yields unexpected results. The\n   * correct pattern for click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   page.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n   * @param selector - A `selector` to search for element to click. If there are\n   * multiple elements satisfying the `selector`, the first will be clicked\n   * @param options - `Object`\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully clicked. The Promise will be rejected if there is no element\n   * matching `selector`.\n   */\n  click(selector: string, options?: Readonly<ClickOptions>): Promise<void> {\n    return this.mainFrame().click(selector, options);\n  }\n\n  /**\n   * This method fetches an element with `selector` and focuses it. If there's no\n   * element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }\n   * of an element to focus. If there are multiple elements satisfying the\n   * selector, the first will be focused.\n   * @returns Promise which resolves when the element matching selector is\n   * successfully focused. The promise will be rejected if there is no element\n   * matching selector.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.\n   */\n  focus(selector: string): Promise<void> {\n    return this.mainFrame().focus(selector);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.mouse}\n   * to hover over the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to search for element to hover. If there are multiple elements satisfying\n   * the selector, the first will be hovered.\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully hovered. Promise gets rejected if there's no element matching\n   * `selector`.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n   */\n  hover(selector: string): Promise<void> {\n    return this.mainFrame().hover(selector);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * page.select('select#colors', 'blue'); // single selection\n   * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to query the page for\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first one\n   * is taken into account.\n   * @returns\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.select | page.mainFrame().select()}\n   */\n  select(selector: string, ...values: string[]): Promise<string[]> {\n    return this.mainFrame().select(selector, ...values);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.touchscreen}\n   * to tap in the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to search for element to tap. If there are multiple elements satisfying the\n   * selector, the first will be tapped.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n   */\n  tap(selector: string): Promise<void> {\n    return this.mainFrame().tap(selector);\n  }\n\n  /**\n   * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n   * in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n   * @example\n   *\n   * ```ts\n   * await page.type('#mytextarea', 'Hello');\n   * // Types instantly\n   * await page.type('#mytextarea', 'World', {delay: 100});\n   * // Types slower, like a user\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to type into. If there are multiple elements satisfying the\n   * selector, the first will be used.\n   * @param text - A text to type into a focused element.\n   * @param options - have property `delay` which is the Time to wait between\n   * key presses in milliseconds. Defaults to `0`.\n   * @returns\n   */\n  type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    return this.mainFrame().type(selector, text, options);\n  }\n\n  /**\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately. If\n   * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigations:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by selector string\n   * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n   * selector is not found in DOM.\n   *\n   * @remarks\n   * The optional Parameter in Arguments `options` are:\n   *\n   * - `visible`: A boolean wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n   *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n   *   `false`.\n   *\n   * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n   *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n   *   by using the {@link Page.setDefaultTimeout} method.\n   */\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().waitForSelector(selector, options);\n  }\n\n  /**\n   * Waits for the provided function, `pageFunction`, to return a truthy value when\n   * evaluated in the page's context.\n   *\n   * @example\n   * {@link Page.waitForFunction} can be used to observe a viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n   *   await page.setViewport({width: 50, height: 50});\n   *   await watchDog;\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * Arguments can be passed from Node.js to `pageFunction`:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await page.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {},\n   *   selector\n   * );\n   * ```\n   *\n   * @example\n   * The provided `pageFunction` can be asynchronous:\n   *\n   * ```ts\n   * const username = 'github-username';\n   * await page.waitForFunction(\n   *   async username => {\n   *     const githubResponse = await fetch(\n   *       `https://api.github.com/users/${username}`\n   *     );\n   *     const githubUser = await githubResponse.json();\n   *     // show the avatar\n   *     const img = document.createElement('img');\n   *     img.src = githubUser.avatar_url;\n   *     // wait 3 seconds\n   *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n   *     img.remove();\n   *   },\n   *   {},\n   *   username\n   * );\n   * ```\n   *\n   * @param pageFunction - Function to be evaluated in browser context until it returns a\n   * truthy value.\n   * @param options - Options for configuring waiting behavior.\n   */\n  waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    options?: FrameWaitForFunctionOptions,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   page.waitForDevicePrompt(),\n   *   page.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  abstract waitForDevicePrompt(\n    options?: WaitTimeoutOptions\n  ): Promise<DeviceRequestPrompt>;\n\n  /** @internal */\n  [disposeSymbol](): void {\n    return void this.close().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    return this.close();\n  }\n}\n\n/**\n * @internal\n */\nexport const supportedMetrics = new Set<string>([\n  'Timestamp',\n  'Documents',\n  'Frames',\n  'JSEventListeners',\n  'Nodes',\n  'LayoutCount',\n  'RecalcStyleCount',\n  'LayoutDuration',\n  'RecalcStyleDuration',\n  'ScriptDuration',\n  'TaskDuration',\n  'JSHeapUsedSize',\n  'JSHeapTotalSize',\n]);\n\n/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */\nfunction normalizeRectangle<BoundingBoxType extends BoundingBox>(\n  clip: Readonly<BoundingBoxType>\n): BoundingBoxType {\n  return {\n    ...clip,\n    ...(clip.width < 0\n      ? {\n          x: clip.x + clip.width,\n          width: -clip.width,\n        }\n      : {\n          x: clip.x,\n          width: clip.width,\n        }),\n    ...(clip.height < 0\n      ? {\n          y: clip.y + clip.height,\n          height: -clip.height,\n        }\n      : {\n          y: clip.y,\n          height: clip.height,\n        }),\n  };\n}\n\nfunction roundRectangle<BoundingBoxType extends BoundingBox>(\n  clip: Readonly<BoundingBoxType>\n): BoundingBoxType {\n  const x = Math.round(clip.x);\n  const y = Math.round(clip.y);\n  const width = Math.round(clip.width + clip.x - x);\n  const height = Math.round(clip.height + clip.y - y);\n  return {...clip, x, y, width, height};\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,SACEA,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,WAAW,EACXC,KAAK,EACLC,cAAc,EACdC,IAAI,EACJC,GAAG,EACHC,KAAK,EACLC,QAAQ,EACRC,SAAS,EACTC,EAAE,EACFC,QAAQ,EACRC,aAAa,EACbC,SAAS,EACTC,SAAS,EACTC,IAAI,EACJC,SAAS,EACTC,KAAK,QAEA,gCAAgC;AAevC,SAAQC,gBAAgB,QAAO,qBAAqB;AACpD,SACEC,YAAY,QAIP,2BAA2B;AAGlC,SAAQC,eAAe,QAAO,8BAA8B;AAS5D,SACEC,UAAU,EACVC,gBAAgB,EAChBC,gBAAgB,EAChBC,QAAQ,EACRC,iBAAiB,EACjBC,OAAO,EACPC,4BAA4B,QACvB,mBAAmB;AAG1B,SAAQC,OAAO,QAAO,uBAAuB;AAC7C,SACEC,oBAAoB,EACpBC,kBAAkB,EAClBC,eAAe,EACfC,aAAa,QACR,uBAAuB;AA0B9B,SACEC,eAAe,EACfC,OAAO,EACPC,WAAW,QAEN,wBAAwB;AA2Z/B;;;AAGA,OAAM,SAAUC,2BAA2BA,CAACC,OAA0B;EACpEA,OAAO,CAACC,gBAAgB,KAAK,KAAK;EAClCD,OAAO,CAACE,IAAI,KAAK,KAAK;EACtBF,OAAO,CAACG,WAAW,KAAK,IAAI;EAC5BH,OAAO,CAACI,QAAQ,KAAK,KAAK;EAC1BJ,OAAO,CAACK,cAAc,KAAK,KAAK;EAChCL,OAAO,CAACM,QAAQ,KAAK,QAAQ;EAC7BN,OAAO,CAACO,qBAAqB,KAAK,IAAI;AACxC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAiDsBC,IAAI;oBAAS1B,YAAY;;;eAAzB0B,IAAK,SAAQC,WAAwB;;;MAq0DzDC,YAAA,aAAAC,sBAAA;QAAAC,IAAA;QAAAC,IAAA;QAAAC,MAAA;QAAAC,OAAA;QAAAC,MAAA;UAAAC,GAAA,EAAAC,GAAA,oBAAAA,GAAA;UAAAC,GAAA,EAAAD,GAAA,IAAAA,GAAA,CAAME;QAAU;QAAAC,QAAA,EAAAC;MAAA,SAAAC,0BAAA;;;;;;;;IAp0DhB;;;IAGAC,WAAW,IAAAC,iBAAA,OAAAF,0BAAA,GAAG,KAAK;IACnB;;;IAGAG,gBAAgB,GAAG,IAAI3C,eAAe,EAAE;IAExC,CAAA4C,eAAgB,GAAG,IAAIC,OAAO,EAA8C;IAE5E,CAAAC,SAAU,GAAG,IAAItD,aAAa,CAAS,CAAC,CAAC;IAEzC;;;IAGAuD,YAAA;MACE,KAAK,EAAE;MAEP7C,gBAAgB,CAAC,IAAI,oCAAoB,CACtC8C,IAAI,CACH5D,QAAQ,CAAC6D,eAAe,IAAG;QACzB,OAAOtE,MAAM,CACXW,EAAE,CAAC,CAAC,CAAC,EACLH,KAAK,CACHe,gBAAgB,CAAC,IAAI,gDAA0B,EAC/CA,gBAAgB,CAAC,IAAI,oDAA4B,EACjDA,gBAAgB,CAAC,IAAI,sCAAqB,CAAC8C,IAAI,CAC7C9D,GAAG,CAACgE,QAAQ,IAAG;UACb,OAAOA,QAAQ,CAACC,OAAO,EAAE;QAC3B,CAAC,CAAC,CACH,CACF,CAACH,IAAI,CACJnE,MAAM,CAACsE,OAAO,IAAG;UACf,OAAOA,OAAO,CAACC,EAAE,KAAKH,eAAe,CAACG,EAAE;QAC1C,CAAC,CAAC,EACFzD,IAAI,CAAC,CAAC,CAAC,EACPT,GAAG,CAAC,MAAK;UACP,OAAO,CAAC,CAAC;QACX,CAAC,CAAC,CACH,CACF;MACH,CAAC,CAAC,EACFG,SAAS,CAAC,CAACgE,GAAG,EAAEC,MAAM,KAAI;QACxB,OAAOhE,EAAE,CAAC+D,GAAG,GAAGC,MAAM,CAAC;MACzB,CAAC,EAAE,CAAC,CAAC,EACL1D,SAAS,CAACM,gBAAgB,CAAC,IAAI,gCAAkB,CAAC,EAClDT,SAAS,CAAC,CAAC,CAAC,CACb,CACA8D,SAAS,CAAC,IAAI,CAAC,CAAAT,SAAU,CAAC;IAC/B;IAqBA;;;;;;;;;;IAUSU,EAAEA,CACTrC,IAAO,EACPsC,OAA2D;MAE3D,IAAItC,IAAI,wCAAwB;QAC9B,OAAO,KAAK,CAACqC,EAAE,CAACrC,IAAI,EAAEsC,OAAO,CAAC;MAChC;MACA,IAAIC,OAAO,GAAG,IAAI,CAAC,CAAAd,eAAgB,CAACR,GAAG,CACrCqB,OAAyD,CAC1D;MACD,IAAIC,OAAO,KAAKC,SAAS,EAAE;QACzBD,OAAO,GAAIE,KAAkB,IAAI;UAC/BA,KAAK,CAACC,sBAAsB,CAAC,MAAK;YAChC,OAAOJ,OAAO,CAACG,KAA0C,CAAC;UAC5D,CAAC,CAAC;QACJ,CAAC;QACD,IAAI,CAAC,CAAAhB,eAAgB,CAACkB,GAAG,CACvBL,OAAyD,EACzDC,OAAO,CACR;MACH;MACA,OAAO,KAAK,CAACF,EAAE,CACbrC,IAAI,EACJuC,OAA6D,CAC9D;IACH;IAEA;;;IAGSK,GAAGA,CACV5C,IAAO,EACPsC,OAA2D;MAE3D,IAAItC,IAAI,wCAAwB;QAC9BsC,OAAO,GACJ,IAAI,CAAC,CAAAb,eAAgB,CAACR,GAAG,CACxBqB,OAES,CAC6C,IAAIA,OAAO;MACvE;MACA,OAAO,KAAK,CAACM,GAAG,CAAC5C,IAAI,EAAEsC,OAAO,CAAC;IACjC;IAuQAO,OAAOA,CACLC,cAAiD;MAEjD,IAAI,OAAOA,cAAc,KAAK,QAAQ,EAAE;QACtC,OAAOlD,WAAW,CAACmD,MAAM,CAAC,IAAI,EAAED,cAAc,CAAC;MACjD,CAAC,MAAM;QACL,OAAOpD,eAAe,CAACqD,MAAM,CAAC,IAAI,EAAED,cAAc,CAAC;MACrD;IACF;IAEA;;;;;IAKAE,WAAWA,CACTC,QAAkB;MAElB,OAAOtD,OAAO,CAACuD,IAAI,CAACD,QAAQ,CAAC;IAC/B;IAEA;;;;;;;;IAQA,MAAME,CAACA,CACLC,QAAkB;MAElB,OAAO,MAAM,IAAI,CAACC,SAAS,EAAE,CAACF,CAAC,CAACC,QAAQ,CAAC;IAC3C;IAEA;;;;;;;;;;IAUA,MAAME,EAAEA,CACNF,QAAkB;MAElB,OAAO,MAAM,IAAI,CAACC,SAAS,EAAE,CAACC,EAAE,CAACF,QAAQ,CAAC;IAC5C;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAyDA,MAAMG,cAAcA,CAIlBC,YAA2B,EAC3B,GAAGC,IAAY;MAEfD,YAAY,GAAGpE,4BAA4B,CACzC,IAAI,CAACmE,cAAc,CAAC5C,IAAI,EACxB6C,YAAY,CACb;MACD,OAAO,MAAM,IAAI,CAACH,SAAS,EAAE,CAACE,cAAc,CAACC,YAAY,EAAE,GAAGC,IAAI,CAAC;IACrE;IA6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8DA,MAAMC,KAAKA,CAQTN,QAAkB,EAClBI,YAA2B,EAC3B,GAAGC,IAAY;MAEfD,YAAY,GAAGpE,4BAA4B,CAAC,IAAI,CAACsE,KAAK,CAAC/C,IAAI,EAAE6C,YAAY,CAAC;MAC1E,OAAO,MAAM,IAAI,CAACH,SAAS,EAAE,CAACK,KAAK,CAACN,QAAQ,EAAEI,YAAY,EAAE,GAAGC,IAAI,CAAC;IACtE;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8DA,MAAME,MAAMA,CAQVP,QAAkB,EAClBI,YAA2B,EAC3B,GAAGC,IAAY;MAEfD,YAAY,GAAGpE,4BAA4B,CAAC,IAAI,CAACuE,MAAM,CAAChD,IAAI,EAAE6C,YAAY,CAAC;MAC3E,OAAO,MAAM,IAAI,CAACH,SAAS,EAAE,CAACM,MAAM,CAACP,QAAQ,EAAEI,YAAY,EAAE,GAAGC,IAAI,CAAC;IACvE;IAmBA;;;;;;;;;;;IAWA,MAAMG,YAAYA,CAChB9D,OAAiC;MAEjC,OAAO,MAAM,IAAI,CAACuD,SAAS,EAAE,CAACO,YAAY,CAAC9D,OAAO,CAAC;IACrD;IAkBA,MAAM+D,WAAWA,CACf/D,OAAgC;MAEhC,OAAO,MAAM,IAAI,CAACuD,SAAS,EAAE,CAACQ,WAAW,CAAC/D,OAAO,CAAC;IACpD;IAkKA;;;;;;;IAOAgE,GAAGA,CAAA;MACD,OAAO,IAAI,CAACT,SAAS,EAAE,CAACS,GAAG,EAAE;IAC/B;IAEA;;;IAGA,MAAMC,OAAOA,CAAA;MACX,OAAO,MAAM,IAAI,CAACV,SAAS,EAAE,CAACU,OAAO,EAAE;IACzC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4BA,MAAMC,UAAUA,CAACC,IAAY,EAAEnE,OAAwB;MACrD,MAAM,IAAI,CAACuD,SAAS,EAAE,CAACW,UAAU,CAACC,IAAI,EAAEnE,OAAO,CAAC;IAClD;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqCA,MAAMoE,IAAIA,CAACJ,GAAW,EAAEhE,OAAqB;MAC3C,OAAO,MAAM,IAAI,CAACuD,SAAS,EAAE,CAACa,IAAI,CAACJ,GAAG,EAAEhE,OAAO,CAAC;IAClD;IAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4BA,MAAMqE,iBAAiBA,CACrBrE,OAAA,GAA0B,EAAE;MAE5B,OAAO,MAAM,IAAI,CAACuD,SAAS,EAAE,CAACc,iBAAiB,CAACrE,OAAO,CAAC;IAC1D;IAEA;;;;;;;;;;;;;;;;;;;;;;;IAuBAsE,cAAcA,CACZC,cAAwD,EACxDvE,OAAA,GAA8B,EAAE;MAEhC,MAAM;QAACX,OAAO,EAAEmF,EAAE,GAAG,IAAI,CAAC9C,gBAAgB,CAACrC,OAAO;MAAE,CAAC,GAAGW,OAAO;MAC/D,IAAI,OAAOuE,cAAc,KAAK,QAAQ,EAAE;QACtC,MAAMP,GAAG,GAAGO,cAAc;QAC1BA,cAAc,GAAIrC,OAAoB,IAAI;UACxC,OAAOA,OAAO,CAAC8B,GAAG,EAAE,KAAKA,GAAG;QAC9B,CAAC;MACH;MACA,MAAMS,WAAW,GAAGxF,gBAAgB,CAAC,IAAI,oCAAoB,CAAC8C,IAAI,CAChElE,WAAW,CAAC0G,cAAc,CAAC,EAC3BjG,QAAQ,CACNe,OAAO,CAACmF,EAAE,CAAC,EACXvF,gBAAgB,CAAC,IAAI,gCAAkB,CAAC8C,IAAI,CAC1C9D,GAAG,CAAC,MAAK;QACP,MAAM,IAAIY,gBAAgB,CAAC,cAAc,CAAC;MAC5C,CAAC,CAAC,CACH,CACF,CACF;MACD,OAAOd,cAAc,CAAC0G,WAAW,CAAC;IACpC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;IA2BAC,eAAeA,CACbH,cAAyD,EACzDvE,OAAA,GAA8B,EAAE;MAEhC,MAAM;QAACX,OAAO,EAAEmF,EAAE,GAAG,IAAI,CAAC9C,gBAAgB,CAACrC,OAAO;MAAE,CAAC,GAAGW,OAAO;MAC/D,IAAI,OAAOuE,cAAc,KAAK,QAAQ,EAAE;QACtC,MAAMP,GAAG,GAAGO,cAAc;QAC1BA,cAAc,GAAItC,QAAsB,IAAI;UAC1C,OAAOA,QAAQ,CAAC+B,GAAG,EAAE,KAAKA,GAAG;QAC/B,CAAC;MACH;MACA,MAAMS,WAAW,GAAGxF,gBAAgB,CAAC,IAAI,sCAAqB,CAAC8C,IAAI,CACjElE,WAAW,CAAC0G,cAAc,CAAC,EAC3BjG,QAAQ,CACNe,OAAO,CAACmF,EAAE,CAAC,EACXvF,gBAAgB,CAAC,IAAI,gCAAkB,CAAC8C,IAAI,CAC1C9D,GAAG,CAAC,MAAK;QACP,MAAM,IAAIY,gBAAgB,CAAC,cAAc,CAAC;MAC5C,CAAC,CAAC,CACH,CACF,CACF;MACD,OAAOd,cAAc,CAAC0G,WAAW,CAAC;IACpC;IAEA;;;;;;IAMAE,kBAAkBA,CAAC3E,OAAA,GAAqC,EAAE;MACxD,OAAOjC,cAAc,CAAC,IAAI,CAAC6G,mBAAmB,CAAC5E,OAAO,CAAC,CAAC;IAC1D;IAEA;;;IAGA4E,mBAAmBA,CACjB5E,OAAA,GAAqC,EAAE;MAEvC,MAAM;QACJX,OAAO,EAAEmF,EAAE,GAAG,IAAI,CAAC9C,gBAAgB,CAACrC,OAAO,EAAE;QAC7CwF,QAAQ,GAAGzF,iBAAiB;QAC5B0F,WAAW,GAAG;MAAC,CAChB,GAAG9E,OAAO;MAEX,OAAO,IAAI,CAAC,CAAA6B,SAAU,CAACE,IAAI,CACzBtD,SAAS,CAACsG,QAAQ,IAAG;QACnB,IAAIA,QAAQ,GAAGD,WAAW,EAAE;UAC1B,OAAOnH,KAAK;QACd;QACA,OAAOiB,KAAK,CAACiG,QAAQ,CAAC;MACxB,CAAC,CAAC,EACF5G,GAAG,CAAC,MAAK,CAAE,CAAC,CAAC,EACbK,QAAQ,CACNe,OAAO,CAACmF,EAAE,CAAC,EACXvF,gBAAgB,CAAC,IAAI,gCAAkB,CAAC8C,IAAI,CAC1C9D,GAAG,CAAC,MAAK;QACP,MAAM,IAAIY,gBAAgB,CAAC,cAAc,CAAC;MAC5C,CAAC,CAAC,CACH,CACF,CACF;IACH;IAEA;;;;;;;;;;;IAWA,MAAMmG,YAAYA,CAChBT,cAA+D,EAC/DvE,OAAA,GAA8B,EAAE;MAEhC,MAAM;QAACX,OAAO,EAAEmF,EAAE,GAAG,IAAI,CAACS,iBAAiB;MAAE,CAAC,GAAGjF,OAAO;MAExD,IAAIb,QAAQ,CAACoF,cAAc,CAAC,EAAE;QAC5BA,cAAc,GAAIW,KAAY,IAAI;UAChC,OAAOX,cAAc,KAAKW,KAAK,CAAClB,GAAG,EAAE;QACvC,CAAC;MACH;MAEA,OAAO,MAAMjG,cAAc,CACzBG,KAAK,CACHe,gBAAgB,CAAC,IAAI,gDAA0B,EAC/CA,gBAAgB,CAAC,IAAI,kDAA2B,EAChDjB,IAAI,CAAC,IAAI,CAACmH,MAAM,EAAE,CAAC,CACpB,CAACpD,IAAI,CACJlE,WAAW,CAAC0G,cAAc,CAAC,EAC3BzG,KAAK,EAAE,EACPQ,QAAQ,CACNe,OAAO,CAACmF,EAAE,CAAC,EACXvF,gBAAgB,CAAC,IAAI,gCAAkB,CAAC8C,IAAI,CAC1C9D,GAAG,CAAC,MAAK;QACP,MAAM,IAAIY,gBAAgB,CAAC,cAAc,CAAC;MAC5C,CAAC,CAAC,CACH,CACF,CACF,CACF;IACH;IA+DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA6BA,MAAMuG,OAAOA,CAACC,MAAc;MAC1B,MAAMC,OAAO,CAACC,GAAG,CAAC,CAChB,IAAI,CAACC,YAAY,CAACH,MAAM,CAACI,SAAS,CAAC,EACnC,IAAI,CAACC,WAAW,CAACL,MAAM,CAACM,QAAQ,CAAC,CAClC,CAAC;IACJ;IAwNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA+CA,MAAMC,QAAQA,CAIZlC,YAA2B,EAC3B,GAAGC,IAAY;MAEfD,YAAY,GAAGpE,4BAA4B,CACzC,IAAI,CAACsG,QAAQ,CAAC/E,IAAI,EAClB6C,YAAY,CACb;MACD,OAAO,MAAM,IAAI,CAACH,SAAS,EAAE,CAACqC,QAAQ,CAAClC,YAAY,EAAE,GAAGC,IAAI,CAAC;IAC/D;IA2DA;;;IAGA,MAAMkC,uBAAuBA,CAC3BC,IAAwB,EACxBC,MAAc;MAEd,IAAI,CAACD,IAAI,EAAE;QACT;MACF;MAEA,MAAME,EAAE,GAAG,MAAM9G,gBAAgB,EAAE;MAEnC,MAAM8G,EAAE,CAACC,SAAS,CAACH,IAAI,EAAEC,MAAM,CAAC;IAClC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAwCA,MAAMG,UAAUA,CACdlG,OAAA,GAAuC,EAAE;MAEzC,MAAM,CAAC;QAACmG;MAAc,CAAC,EAAE,CAACC,KAAK,EAAEC,MAAM,EAAEC,gBAAgB,CAAC,CAAC,GACzD,MAAMhB,OAAO,CAACC,GAAG,CAAC,CAChB,MAAM,CAAC,2BAA2B,CAAC,EACnC,IAAI,CAAC,CAAAgB,wBAAyB,EAAE,CACjC,CAAC;MAEJ,IAAIC,IAA6B;MACjC,IAAIxG,OAAO,CAACwG,IAAI,EAAE;QAChB,MAAM;UACJC,CAAC;UACDC,CAAC;UACDN,KAAK,EAAEO,SAAS;UAChBN,MAAM,EAAEO;QAAU,CACnB,GAAGC,cAAc,CAACC,kBAAkB,CAAC9G,OAAO,CAACwG,IAAI,CAAC,CAAC;QACpD,IAAIC,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,EAAE;UAClB,MAAM,IAAIK,KAAK,CACb,+DAA+D,CAChE;QACH;QACA,IAAIJ,SAAS,IAAI,CAAC,IAAIC,UAAU,IAAI,CAAC,EAAE;UACrC,MAAM,IAAIG,KAAK,CACb,wEAAwE,CACzE;QACH;QAEA,MAAMC,aAAa,GAAGZ,KAAK,GAAGE,gBAAgB;QAC9C,MAAMW,cAAc,GAAGZ,MAAM,GAAGC,gBAAgB;QAChD,IAAIG,CAAC,GAAGE,SAAS,GAAGK,aAAa,EAAE;UACjC,MAAM,IAAID,KAAK,CACb,4DAA4DC,aAAa,IAAI,CAC9E;QACH;QACA,IAAIN,CAAC,GAAGE,UAAU,GAAGK,cAAc,EAAE;UACnC,MAAM,IAAIF,KAAK,CACb,8DAA8DE,cAAc,IAAI,CACjF;QACH;QAEAT,IAAI,GAAG;UACLC,CAAC,EAAEA,CAAC,GAAGH,gBAAgB;UACvBI,CAAC,EAAEA,CAAC,GAAGJ,gBAAgB;UACvBF,KAAK,EAAEO,SAAS,GAAGL,gBAAgB;UACnCD,MAAM,EAAEO,UAAU,GAAGN;SACtB;MACH;MACA,IAAItG,OAAO,CAACkH,KAAK,KAAKxE,SAAS,IAAI1C,OAAO,CAACkH,KAAK,IAAI,CAAC,EAAE;QACrD,MAAM,IAAIH,KAAK,CAAC,mCAAmC,CAAC;MACtD;MACA,IAAI/G,OAAO,CAACmH,KAAK,KAAKzE,SAAS,IAAI1C,OAAO,CAACmH,KAAK,IAAI,CAAC,EAAE;QACrD,MAAM,IAAIJ,KAAK,CAAC,mCAAmC,CAAC;MACtD;MAEA,MAAMK,QAAQ,GAAG,IAAIjB,cAAc,CAAC,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAE;QACvD,GAAGrG,OAAO;QACV8F,IAAI,EAAE9F,OAAO,CAACqH,UAAU;QACxBb;OACD,CAAC;MACF,IAAI;QACF,MAAM,IAAI,CAACc,gBAAgB,EAAE;MAC/B,CAAC,CAAC,OAAOC,KAAK,EAAE;QACd,KAAKH,QAAQ,CAACI,IAAI,EAAE;QACpB,MAAMD,KAAK;MACb;MACA,IAAIvH,OAAO,CAAC8F,IAAI,EAAE;QAChB,MAAM;UAAC2B;QAAiB,CAAC,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC;QAC9C,MAAMC,MAAM,GAAGD,iBAAiB,CAACzH,OAAO,CAAC8F,IAAI,EAAE,QAAQ,CAAC;QACxDsB,QAAQ,CAACrF,IAAI,CAAC2F,MAAM,CAAC;MACvB;MACA,OAAON,QAAQ;IACjB;IAEA,CAAAO,sBAAuB,GAAG,CAAC;IAC3B,CAAAC,sBAAuB;IAEvB;;;IAGA,MAAMN,gBAAgBA,CAAA;MACpB,EAAE,IAAI,CAAC,CAAAK,sBAAuB;MAC9B,IAAI,CAAC,IAAI,CAAC,CAAAC,sBAAuB,EAAE;QACjC,IAAI,CAAC,CAAAA,sBAAuB,GAAG,IAAI,CAACrE,SAAS,EAAE,CAC5CsE,MAAM,CAACC,IAAI,CAAC,sBAAsB,EAAE;UAACC,MAAM,EAAE;QAAK,CAAC,CAAC,CACpDC,IAAI,CAAC,MAAK;UACT;UACA,OAAO,IAAI1C,OAAO,CAAC2C,OAAO,IAAG;YAC3B,OAAO,IAAI,CAAC1E,SAAS,EAAE,CAACsE,MAAM,CAACK,IAAI,CAAC,sBAAsB,EAAE,MAAK;cAC/D,OAAOD,OAAO,EAAE;YAClB,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ,CAAC,CAAC;MACN;MACA,MAAM,IAAI,CAAC,CAAAL,sBAAuB;IACpC;IAEA;;;IAGA,MAAMO,eAAeA,CAAA;MACnB,EAAE,IAAI,CAAC,CAAAR,sBAAuB;MAC9B,IAAI,CAAC,IAAI,CAAC,CAAAC,sBAAuB,EAAE;QACjC;MACF;MACA,IAAI,CAAC,CAAAA,sBAAuB,GAAGlF,SAAS;MACxC,IAAI,IAAI,CAAC,CAAAiF,sBAAuB,KAAK,CAAC,EAAE;QACtC,MAAM,IAAI,CAACpE,SAAS,EAAE,CAACsE,MAAM,CAACC,IAAI,CAAC,qBAAqB,CAAC;MAC3D;IACF;IAEA;;;IAGA,MAAM,CAAAvB,wBAAyB6B,CAAA;;;;;;;QAG7B,MAAMzC,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;QAChC,MAAM0C,KAAK,GAAAC,uBAAA,CAAAC,KAAA,EAAG,IAAI7I,eAAe,EAAE;QACnC,IAAIiG,QAAQ,IAAIA,QAAQ,CAAC6C,iBAAiB,KAAK,CAAC,EAAE;UAChD,MAAM,IAAI,CAAC9C,WAAW,CAAC;YAAC,GAAGC,QAAQ;YAAE6C,iBAAiB,EAAE;UAAC,CAAC,CAAC;UAC3DH,KAAK,CAACI,KAAK,CAAC,MAAK;YACf,KAAK,IAAI,CAAC/C,WAAW,CAACC,QAAQ,CAAC,CAAC+C,KAAK,CAAC1J,UAAU,CAAC;UACnD,CAAC,CAAC;QACJ;QACA,OAAO,MAAM,IAAI,CAACuE,SAAS,EAAE,CAC1BoF,aAAa,EAAE,CACf/C,QAAQ,CAAC,MAAK;UACb,OAAO,CACLgD,MAAM,CAACC,cAAe,CAACzC,KAAK,GAAGwC,MAAM,CAACtC,gBAAgB,EACtDsC,MAAM,CAACC,cAAe,CAACxC,MAAM,GAAGuC,MAAM,CAACtC,gBAAgB,EACvDsC,MAAM,CAACtC,gBAAgB,CACf;QACZ,CAAC,CAAC;;;;;;;;IAeN,MAAMlF,UAAUA,CACd0H,WAAA,GAA2C,EAAE;;;;;;;QAE7C,MAAM,IAAI,CAACC,YAAY,EAAE;QAEzB;QACA,MAAM/I,OAAO,GAAG;UACd,GAAG8I,WAAW;UACdE,IAAI,EAAEF,WAAW,CAACE,IAAI,GAClB;YACE,GAAGF,WAAW,CAACE;WAChB,GACDtG;SACL;QACD,IAAI1C,OAAO,CAACE,IAAI,KAAKwC,SAAS,IAAI1C,OAAO,CAAC8F,IAAI,KAAKpD,SAAS,EAAE;UAC5D,MAAMuG,QAAQ,GAAGjJ,OAAO,CAAC8F,IAAI;UAC7B;UACA,MAAMoD,SAAS,GAAGD,QAAQ,CACvBE,KAAK,CAACF,QAAQ,CAACG,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CACpCC,WAAW,EAAE;UAChB,QAAQH,SAAS;YACf,KAAK,KAAK;cACRlJ,OAAO,CAACE,IAAI,GAAG,KAAK;cACpB;YACF,KAAK,MAAM;YACX,KAAK,KAAK;cACRF,OAAO,CAACE,IAAI,GAAG,MAAM;cACrB;YACF,KAAK,MAAM;cACTF,OAAO,CAACE,IAAI,GAAG,MAAM;cACrB;UACJ;QACF;QACA,IAAIF,OAAO,CAACsJ,OAAO,KAAK5G,SAAS,EAAE;UACjC,IAAI1C,OAAO,CAACsJ,OAAO,GAAG,CAAC,IAAItJ,OAAO,CAACsJ,OAAO,GAAG,GAAG,EAAE;YAChD,MAAM,IAAIvC,KAAK,CACb,uBAAuB/G,OAAO,CAACsJ,OAAO,uCAAuC,CAC9E;UACH;UACA,IACEtJ,OAAO,CAACE,IAAI,KAAKwC,SAAS,IAC1B,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC6G,QAAQ,CAACvJ,OAAO,CAACE,IAAI,CAAC,EACxC;YACA,MAAM,IAAI6G,KAAK,CACb,GAAG/G,OAAO,CAACE,IAAI,IAAI,KAAK,wCAAwC,CACjE;UACH;QACF;QACA,IAAIF,OAAO,CAACgJ,IAAI,EAAE;UAChB,IAAIhJ,OAAO,CAACgJ,IAAI,CAAC5C,KAAK,IAAI,CAAC,EAAE;YAC3B,MAAM,IAAIW,KAAK,CAAC,qCAAqC,CAAC;UACxD;UACA,IAAI/G,OAAO,CAACgJ,IAAI,CAAC3C,MAAM,IAAI,CAAC,EAAE;YAC5B,MAAM,IAAIU,KAAK,CAAC,sCAAsC,CAAC;UACzD;QACF;QAEAhH,2BAA2B,CAACC,OAAO,CAAC;QAEpC,MAAYqI,KAAK,GAAAC,uBAAA,CAAAkB,KAAA,EAAG,IAAIhK,oBAAoB,EAAE;QAC9C,IAAIQ,OAAO,CAACgJ,IAAI,EAAE;UAChB,IAAIhJ,OAAO,CAACI,QAAQ,EAAE;YACpB,MAAM,IAAI2G,KAAK,CAAC,8CAA8C,CAAC;UACjE;UAEA/G,OAAO,CAACgJ,IAAI,GAAGnC,cAAc,CAACC,kBAAkB,CAAC9G,OAAO,CAACgJ,IAAI,CAAC,CAAC;QACjE,CAAC,MAAM;UACL,IAAIhJ,OAAO,CAACI,QAAQ,EAAE;YACpB;YACA;YACA;YACA,IAAI,CAACJ,OAAO,CAACO,qBAAqB,EAAE;cAClC,MAAMkJ,gBAAgB,GAAG,MAAM,IAAI,CAAClG,SAAS,EAAE,CAC5CoF,aAAa,EAAE,CACf/C,QAAQ,CAAC,MAAK;gBACb,MAAM8D,OAAO,GAAGC,QAAQ,CAACC,eAAe;gBACxC,OAAO;kBACLxD,KAAK,EAAEsD,OAAO,CAACG,WAAW;kBAC1BxD,MAAM,EAAEqD,OAAO,CAACI;iBACjB;cACH,CAAC,CAAC;cACJ,MAAMnE,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;cAChC,MAAM,IAAI,CAACD,WAAW,CAAC;gBACrB,GAAGC,QAAQ;gBACX,GAAG8D;eACJ,CAAC;cACFpB,KAAK,CAACI,KAAK,CAAC,YAAW;gBACrB,IAAI9C,QAAQ,EAAE;kBACZ,MAAM,IAAI,CAACD,WAAW,CAACC,QAAQ,CAAC,CAAC+C,KAAK,CAAC1J,UAAU,CAAC;gBACpD,CAAC,MAAM;kBACL,MAAM,IAAI,CAAC0G,WAAW,CAAC;oBACrBU,KAAK,EAAE,CAAC;oBACRC,MAAM,EAAE;mBACT,CAAC,CAACqC,KAAK,CAAC1J,UAAU,CAAC;gBACtB;cACF,CAAC,CAAC;YACJ;UACF,CAAC,MAAM;YACLgB,OAAO,CAACO,qBAAqB,GAAG,KAAK;UACvC;QACF;QAEA,MAAMwJ,IAAI,GAAG,MAAM,IAAI,CAACC,WAAW,CAAChK,OAAO,CAAC;QAC5C,IAAIA,OAAO,CAACM,QAAQ,KAAK,QAAQ,EAAE;UACjC,OAAOyJ,IAAI;QACb;QACA,MAAMhE,MAAM,GAAGkE,MAAM,CAACjM,IAAI,CAAC+L,IAAI,EAAE,QAAQ,CAAC;QAC1C,MAAM,IAAI,CAAClE,uBAAuB,CAAC7F,OAAO,CAAC8F,IAAI,EAAEC,MAAM,CAAC;QACxD,OAAOA,MAAM;;;;;;;;;IAiCf;;;;;;;IAOA,MAAMmE,KAAKA,CAAA;MACT,OAAO,MAAM,IAAI,CAAC3G,SAAS,EAAE,CAAC2G,KAAK,EAAE;IACvC;IAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4BAC,KAAKA,CAAC7G,QAAgB,EAAEtD,OAAgC;MACtD,OAAO,IAAI,CAACuD,SAAS,EAAE,CAAC4G,KAAK,CAAC7G,QAAQ,EAAEtD,OAAO,CAAC;IAClD;IAEA;;;;;;;;;;;;;;;IAeAoK,KAAKA,CAAC9G,QAAgB;MACpB,OAAO,IAAI,CAACC,SAAS,EAAE,CAAC6G,KAAK,CAAC9G,QAAQ,CAAC;IACzC;IAEA;;;;;;;;;;;;;;;;;IAiBA+G,KAAKA,CAAC/G,QAAgB;MACpB,OAAO,IAAI,CAACC,SAAS,EAAE,CAAC8G,KAAK,CAAC/G,QAAQ,CAAC;IACzC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;IAwBAgH,MAAMA,CAAChH,QAAgB,EAAE,GAAGiH,MAAgB;MAC1C,OAAO,IAAI,CAAChH,SAAS,EAAE,CAAC+G,MAAM,CAAChH,QAAQ,EAAE,GAAGiH,MAAM,CAAC;IACrD;IAEA;;;;;;;;;;;;;;IAcAC,GAAGA,CAAClH,QAAgB;MAClB,OAAO,IAAI,CAACC,SAAS,EAAE,CAACiH,GAAG,CAAClH,QAAQ,CAAC;IACvC;IAEA;;;;;;;;;;;;;;;;;;;;;;;IAuBApD,IAAIA,CACFoD,QAAgB,EAChBmH,IAAY,EACZzK,OAAuC;MAEvC,OAAO,IAAI,CAACuD,SAAS,EAAE,CAACrD,IAAI,CAACoD,QAAQ,EAAEmH,IAAI,EAAEzK,OAAO,CAAC;IACvD;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAoDA,MAAM0K,eAAeA,CACnBpH,QAAkB,EAClBtD,OAAA,GAAkC,EAAE;MAEpC,OAAO,MAAM,IAAI,CAACuD,SAAS,EAAE,CAACmH,eAAe,CAACpH,QAAQ,EAAEtD,OAAO,CAAC;IAClE;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA0DA2K,eAAeA,CAIbjH,YAA2B,EAC3B1D,OAAqC,EACrC,GAAG2D,IAAY;MAEf,OAAO,IAAI,CAACJ,SAAS,EAAE,CAACoH,eAAe,CAACjH,YAAY,EAAE1D,OAAO,EAAE,GAAG2D,IAAI,CAAC;IACzE;IA6BA;IACA,EAAAhD,sBAAA,IAzdCpB,OAAO,CAAC;MACP,OAAO,IAAI,CAACqL,OAAO,EAAE;IACvB,CAAC,CAAC,GAudDjL,aAAa,KAAC;MACb,OAAO,KAAK,IAAI,CAACkL,KAAK,EAAE,CAACnC,KAAK,CAAC1J,UAAU,CAAC;IAC5C;IAEA;IACA,CAACS,kBAAkB,IAAC;MAClB,OAAO,IAAI,CAACoL,KAAK,EAAE;IACrB;;;SAlyEoBrK,IAAI;AAqyE1B;;;AAGA,OAAO,MAAMsK,gBAAgB,GAAG,IAAIC,GAAG,CAAS,CAC9C,WAAW,EACX,WAAW,EACX,QAAQ,EACR,kBAAkB,EAClB,OAAO,EACP,aAAa,EACb,kBAAkB,EAClB,gBAAgB,EAChB,qBAAqB,EACrB,gBAAgB,EAChB,cAAc,EACd,gBAAgB,EAChB,iBAAiB,CAClB,CAAC;AAEF;AACA,SAASjE,kBAAkBA,CACzBkC,IAA+B;EAE/B,OAAO;IACL,GAAGA,IAAI;IACP,IAAIA,IAAI,CAAC5C,KAAK,GAAG,CAAC,GACd;MACEK,CAAC,EAAEuC,IAAI,CAACvC,CAAC,GAAGuC,IAAI,CAAC5C,KAAK;MACtBA,KAAK,EAAE,CAAC4C,IAAI,CAAC5C;KACd,GACD;MACEK,CAAC,EAAEuC,IAAI,CAACvC,CAAC;MACTL,KAAK,EAAE4C,IAAI,CAAC5C;KACb,CAAC;IACN,IAAI4C,IAAI,CAAC3C,MAAM,GAAG,CAAC,GACf;MACEK,CAAC,EAAEsC,IAAI,CAACtC,CAAC,GAAGsC,IAAI,CAAC3C,MAAM;MACvBA,MAAM,EAAE,CAAC2C,IAAI,CAAC3C;KACf,GACD;MACEK,CAAC,EAAEsC,IAAI,CAACtC,CAAC;MACTL,MAAM,EAAE2C,IAAI,CAAC3C;KACd;GACN;AACH;AAEA,SAASQ,cAAcA,CACrBmC,IAA+B;EAE/B,MAAMvC,CAAC,GAAGuE,IAAI,CAACC,KAAK,CAACjC,IAAI,CAACvC,CAAC,CAAC;EAC5B,MAAMC,CAAC,GAAGsE,IAAI,CAACC,KAAK,CAACjC,IAAI,CAACtC,CAAC,CAAC;EAC5B,MAAMN,KAAK,GAAG4E,IAAI,CAACC,KAAK,CAACjC,IAAI,CAAC5C,KAAK,GAAG4C,IAAI,CAACvC,CAAC,GAAGA,CAAC,CAAC;EACjD,MAAMJ,MAAM,GAAG2E,IAAI,CAACC,KAAK,CAACjC,IAAI,CAAC3C,MAAM,GAAG2C,IAAI,CAACtC,CAAC,GAAGA,CAAC,CAAC;EACnD,OAAO;IAAC,GAAGsC,IAAI;IAAEvC,CAAC;IAAEC,CAAC;IAAEN,KAAK;IAAEC;EAAM,CAAC;AACvC"},"metadata":{},"sourceType":"module","externalDependencies":[]}