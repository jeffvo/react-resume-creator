{"ast":null,"code":"var tokenizer = require('../../tokenizer');\nvar TYPE = tokenizer.TYPE;\nvar WhiteSpace = TYPE.WhiteSpace;\nvar Semicolon = TYPE.Semicolon;\nvar LeftCurlyBracket = TYPE.LeftCurlyBracket;\nvar Delim = TYPE.Delim;\nvar EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\nfunction getOffsetExcludeWS() {\n  if (this.scanner.tokenIndex > 0) {\n    if (this.scanner.lookupType(-1) === WhiteSpace) {\n      return this.scanner.tokenIndex > 1 ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1) : this.scanner.firstCharOffset;\n    }\n  }\n  return this.scanner.tokenStart;\n}\n\n// 0, 0, false\nfunction balanceEnd() {\n  return 0;\n}\n\n// LEFTCURLYBRACKET, 0, false\nfunction leftCurlyBracket(tokenType) {\n  return tokenType === LeftCurlyBracket ? 1 : 0;\n}\n\n// LEFTCURLYBRACKET, SEMICOLON, false\nfunction leftCurlyBracketOrSemicolon(tokenType) {\n  return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;\n}\n\n// EXCLAMATIONMARK, SEMICOLON, false\nfunction exclamationMarkOrSemicolon(tokenType, source, offset) {\n  if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {\n    return 1;\n  }\n  return tokenType === Semicolon ? 1 : 0;\n}\n\n// 0, SEMICOLON, true\nfunction semicolonIncluded(tokenType) {\n  return tokenType === Semicolon ? 2 : 0;\n}\nmodule.exports = {\n  name: 'Raw',\n  structure: {\n    value: String\n  },\n  parse: function (startToken, mode, excludeWhiteSpace) {\n    var startOffset = this.scanner.getTokenStart(startToken);\n    var endOffset;\n    this.scanner.skip(this.scanner.getRawLength(startToken, mode || balanceEnd));\n    if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {\n      endOffset = getOffsetExcludeWS.call(this);\n    } else {\n      endOffset = this.scanner.tokenStart;\n    }\n    return {\n      type: 'Raw',\n      loc: this.getLocation(startOffset, endOffset),\n      value: this.scanner.source.substring(startOffset, endOffset)\n    };\n  },\n  generate: function (node) {\n    this.chunk(node.value);\n  },\n  mode: {\n    default: balanceEnd,\n    leftCurlyBracket: leftCurlyBracket,\n    leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,\n    exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,\n    semicolonIncluded: semicolonIncluded\n  }\n};","map":{"version":3,"names":["tokenizer","require","TYPE","WhiteSpace","Semicolon","LeftCurlyBracket","Delim","EXCLAMATIONMARK","getOffsetExcludeWS","scanner","tokenIndex","lookupType","getTokenStart","firstCharOffset","tokenStart","balanceEnd","leftCurlyBracket","tokenType","leftCurlyBracketOrSemicolon","exclamationMarkOrSemicolon","source","offset","charCodeAt","semicolonIncluded","module","exports","name","structure","value","String","parse","startToken","mode","excludeWhiteSpace","startOffset","endOffset","skip","getRawLength","call","type","loc","getLocation","substring","generate","node","chunk","default"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/syntax/node/Raw.js"],"sourcesContent":["var tokenizer = require('../../tokenizer');\nvar TYPE = tokenizer.TYPE;\n\nvar WhiteSpace = TYPE.WhiteSpace;\nvar Semicolon = TYPE.Semicolon;\nvar LeftCurlyBracket = TYPE.LeftCurlyBracket;\nvar Delim = TYPE.Delim;\nvar EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\nfunction getOffsetExcludeWS() {\n    if (this.scanner.tokenIndex > 0) {\n        if (this.scanner.lookupType(-1) === WhiteSpace) {\n            return this.scanner.tokenIndex > 1\n                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)\n                : this.scanner.firstCharOffset;\n        }\n    }\n\n    return this.scanner.tokenStart;\n}\n\n// 0, 0, false\nfunction balanceEnd() {\n    return 0;\n}\n\n// LEFTCURLYBRACKET, 0, false\nfunction leftCurlyBracket(tokenType) {\n    return tokenType === LeftCurlyBracket ? 1 : 0;\n}\n\n// LEFTCURLYBRACKET, SEMICOLON, false\nfunction leftCurlyBracketOrSemicolon(tokenType) {\n    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;\n}\n\n// EXCLAMATIONMARK, SEMICOLON, false\nfunction exclamationMarkOrSemicolon(tokenType, source, offset) {\n    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {\n        return 1;\n    }\n\n    return tokenType === Semicolon ? 1 : 0;\n}\n\n// 0, SEMICOLON, true\nfunction semicolonIncluded(tokenType) {\n    return tokenType === Semicolon ? 2 : 0;\n}\n\nmodule.exports = {\n    name: 'Raw',\n    structure: {\n        value: String\n    },\n    parse: function(startToken, mode, excludeWhiteSpace) {\n        var startOffset = this.scanner.getTokenStart(startToken);\n        var endOffset;\n\n        this.scanner.skip(\n            this.scanner.getRawLength(startToken, mode || balanceEnd)\n        );\n\n        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {\n            endOffset = getOffsetExcludeWS.call(this);\n        } else {\n            endOffset = this.scanner.tokenStart;\n        }\n\n        return {\n            type: 'Raw',\n            loc: this.getLocation(startOffset, endOffset),\n            value: this.scanner.source.substring(startOffset, endOffset)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n    },\n\n    mode: {\n        default: balanceEnd,\n        leftCurlyBracket: leftCurlyBracket,\n        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,\n        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,\n        semicolonIncluded: semicolonIncluded\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}