{"ast":null,"code":"import NodeType from './nodes/type';\nfunction isTag(node) {\n  return node && node.nodeType === NodeType.ELEMENT_NODE;\n}\nfunction getAttributeValue(elem, name) {\n  return isTag(elem) ? elem.getAttribute(name) : undefined;\n}\nfunction getName(elem) {\n  return (elem && elem.rawTagName || '').toLowerCase();\n}\nfunction getChildren(node) {\n  return node && node.childNodes;\n}\nfunction getParent(node) {\n  return node ? node.parentNode : null;\n}\nfunction getText(node) {\n  return node.text;\n}\nfunction removeSubsets(nodes) {\n  let idx = nodes.length;\n  let node;\n  let ancestor;\n  let replace;\n  // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n  while (--idx > -1) {\n    node = ancestor = nodes[idx];\n    // Temporarily remove the node under consideration\n    nodes[idx] = null;\n    replace = true;\n    while (ancestor) {\n      if (nodes.indexOf(ancestor) > -1) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n      ancestor = getParent(ancestor);\n    }\n    // If the node has been found to be unique, re-insert it.\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n  return nodes;\n}\nfunction existsOne(test, elems) {\n  return elems.some(elem => {\n    return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;\n  });\n}\nfunction getSiblings(node) {\n  const parent = getParent(node);\n  return parent && getChildren(parent);\n}\nfunction hasAttrib(elem, name) {\n  return getAttributeValue(elem, name) !== undefined;\n}\nfunction findOne(test, elems) {\n  let elem = null;\n  for (let i = 0, l = elems.length; i < l && !elem; i++) {\n    const el = elems[i];\n    if (test(el)) {\n      elem = el;\n    } else {\n      const childs = getChildren(el);\n      if (childs && childs.length > 0) {\n        elem = findOne(test, childs);\n      }\n    }\n  }\n  return elem;\n}\nfunction findAll(test, nodes) {\n  let result = [];\n  for (let i = 0, j = nodes.length; i < j; i++) {\n    if (!isTag(nodes[i])) continue;\n    if (test(nodes[i])) result.push(nodes[i]);\n    const childs = getChildren(nodes[i]);\n    if (childs) result = result.concat(findAll(test, childs));\n  }\n  return result;\n}\nexport default {\n  isTag,\n  getAttributeValue,\n  getName,\n  getChildren,\n  getParent,\n  getText,\n  removeSubsets,\n  existsOne,\n  getSiblings,\n  hasAttrib,\n  findOne,\n  findAll\n};","map":{"version":3,"names":["NodeType","isTag","node","nodeType","ELEMENT_NODE","getAttributeValue","elem","name","getAttribute","undefined","getName","rawTagName","toLowerCase","getChildren","childNodes","getParent","parentNode","getText","text","removeSubsets","nodes","idx","length","ancestor","replace","indexOf","splice","existsOne","test","elems","some","getSiblings","parent","hasAttrib","findOne","i","l","el","childs","findAll","result","j","push","concat"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/node-html-parser/dist/esm/matcher.js"],"sourcesContent":["import NodeType from './nodes/type';\nfunction isTag(node) {\n    return node && node.nodeType === NodeType.ELEMENT_NODE;\n}\nfunction getAttributeValue(elem, name) {\n    return isTag(elem) ? elem.getAttribute(name) : undefined;\n}\nfunction getName(elem) {\n    return ((elem && elem.rawTagName) || '').toLowerCase();\n}\nfunction getChildren(node) {\n    return node && node.childNodes;\n}\nfunction getParent(node) {\n    return node ? node.parentNode : null;\n}\nfunction getText(node) {\n    return node.text;\n}\nfunction removeSubsets(nodes) {\n    let idx = nodes.length;\n    let node;\n    let ancestor;\n    let replace;\n    // Check if each node (or one of its ancestors) is already contained in the\n    // array.\n    while (--idx > -1) {\n        node = ancestor = nodes[idx];\n        // Temporarily remove the node under consideration\n        nodes[idx] = null;\n        replace = true;\n        while (ancestor) {\n            if (nodes.indexOf(ancestor) > -1) {\n                replace = false;\n                nodes.splice(idx, 1);\n                break;\n            }\n            ancestor = getParent(ancestor);\n        }\n        // If the node has been found to be unique, re-insert it.\n        if (replace) {\n            nodes[idx] = node;\n        }\n    }\n    return nodes;\n}\nfunction existsOne(test, elems) {\n    return elems.some((elem) => {\n        return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;\n    });\n}\nfunction getSiblings(node) {\n    const parent = getParent(node);\n    return parent && getChildren(parent);\n}\nfunction hasAttrib(elem, name) {\n    return getAttributeValue(elem, name) !== undefined;\n}\nfunction findOne(test, elems) {\n    let elem = null;\n    for (let i = 0, l = elems.length; i < l && !elem; i++) {\n        const el = elems[i];\n        if (test(el)) {\n            elem = el;\n        }\n        else {\n            const childs = getChildren(el);\n            if (childs && childs.length > 0) {\n                elem = findOne(test, childs);\n            }\n        }\n    }\n    return elem;\n}\nfunction findAll(test, nodes) {\n    let result = [];\n    for (let i = 0, j = nodes.length; i < j; i++) {\n        if (!isTag(nodes[i]))\n            continue;\n        if (test(nodes[i]))\n            result.push(nodes[i]);\n        const childs = getChildren(nodes[i]);\n        if (childs)\n            result = result.concat(findAll(test, childs));\n    }\n    return result;\n}\nexport default {\n    isTag,\n    getAttributeValue,\n    getName,\n    getChildren,\n    getParent,\n    getText,\n    removeSubsets,\n    existsOne,\n    getSiblings,\n    hasAttrib,\n    findOne,\n    findAll\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}