{"ast":null,"code":"var List = require('../common/List');\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isValidNumber(value) {\n  // Number.isInteger(value) && value >= 0\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value && value >= 0;\n}\nfunction isValidLocation(loc) {\n  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);\n}\nfunction createNodeStructureChecker(type, fields) {\n  return function checkNode(node, warn) {\n    if (!node || node.constructor !== Object) {\n      return warn(node, 'Type of node should be an Object');\n    }\n    for (var key in node) {\n      var valid = true;\n      if (hasOwnProperty.call(node, key) === false) {\n        continue;\n      }\n      if (key === 'type') {\n        if (node.type !== type) {\n          warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n        }\n      } else if (key === 'loc') {\n        if (node.loc === null) {\n          continue;\n        } else if (node.loc && node.loc.constructor === Object) {\n          if (typeof node.loc.source !== 'string') {\n            key += '.source';\n          } else if (!isValidLocation(node.loc.start)) {\n            key += '.start';\n          } else if (!isValidLocation(node.loc.end)) {\n            key += '.end';\n          } else {\n            continue;\n          }\n        }\n        valid = false;\n      } else if (fields.hasOwnProperty(key)) {\n        for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {\n          var fieldType = fields[key][i];\n          switch (fieldType) {\n            case String:\n              valid = typeof node[key] === 'string';\n              break;\n            case Boolean:\n              valid = typeof node[key] === 'boolean';\n              break;\n            case null:\n              valid = node[key] === null;\n              break;\n            default:\n              if (typeof fieldType === 'string') {\n                valid = node[key] && node[key].type === fieldType;\n              } else if (Array.isArray(fieldType)) {\n                valid = node[key] instanceof List;\n              }\n          }\n        }\n      } else {\n        warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n      }\n      if (!valid) {\n        warn(node, 'Bad value for `' + type + '.' + key + '`');\n      }\n    }\n    for (var key in fields) {\n      if (hasOwnProperty.call(fields, key) && hasOwnProperty.call(node, key) === false) {\n        warn(node, 'Field `' + type + '.' + key + '` is missed');\n      }\n    }\n  };\n}\nfunction processStructure(name, nodeType) {\n  var structure = nodeType.structure;\n  var fields = {\n    type: String,\n    loc: true\n  };\n  var docs = {\n    type: '\"' + name + '\"'\n  };\n  for (var key in structure) {\n    if (hasOwnProperty.call(structure, key) === false) {\n      continue;\n    }\n    var docsTypes = [];\n    var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];\n    for (var i = 0; i < fieldTypes.length; i++) {\n      var fieldType = fieldTypes[i];\n      if (fieldType === String || fieldType === Boolean) {\n        docsTypes.push(fieldType.name);\n      } else if (fieldType === null) {\n        docsTypes.push('null');\n      } else if (typeof fieldType === 'string') {\n        docsTypes.push('<' + fieldType + '>');\n      } else if (Array.isArray(fieldType)) {\n        docsTypes.push('List'); // TODO: use type enum\n      } else {\n        throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n      }\n    }\n    docs[key] = docsTypes.join(' | ');\n  }\n  return {\n    docs: docs,\n    check: createNodeStructureChecker(name, fields)\n  };\n}\nmodule.exports = {\n  getStructureFromConfig: function (config) {\n    var structure = {};\n    if (config.node) {\n      for (var name in config.node) {\n        if (hasOwnProperty.call(config.node, name)) {\n          var nodeType = config.node[name];\n          if (nodeType.structure) {\n            structure[name] = processStructure(name, nodeType);\n          } else {\n            throw new Error('Missed `structure` field in `' + name + '` node type definition');\n          }\n        }\n      }\n    }\n    return structure;\n  }\n};","map":{"version":3,"names":["List","require","hasOwnProperty","Object","prototype","isValidNumber","value","isFinite","Math","floor","isValidLocation","loc","Boolean","offset","line","column","createNodeStructureChecker","type","fields","checkNode","node","warn","constructor","key","valid","call","source","start","end","i","length","fieldType","String","Array","isArray","processStructure","name","nodeType","structure","docs","docsTypes","fieldTypes","slice","push","Error","join","check","module","exports","getStructureFromConfig","config"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/structure.js"],"sourcesContent":["var List = require('../common/List');\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isValidNumber(value) {\n    // Number.isInteger(value) && value >= 0\n    return (\n        typeof value === 'number' &&\n        isFinite(value) &&\n        Math.floor(value) === value &&\n        value >= 0\n    );\n}\n\nfunction isValidLocation(loc) {\n    return (\n        Boolean(loc) &&\n        isValidNumber(loc.offset) &&\n        isValidNumber(loc.line) &&\n        isValidNumber(loc.column)\n    );\n}\n\nfunction createNodeStructureChecker(type, fields) {\n    return function checkNode(node, warn) {\n        if (!node || node.constructor !== Object) {\n            return warn(node, 'Type of node should be an Object');\n        }\n\n        for (var key in node) {\n            var valid = true;\n\n            if (hasOwnProperty.call(node, key) === false) {\n                continue;\n            }\n\n            if (key === 'type') {\n                if (node.type !== type) {\n                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n                }\n            } else if (key === 'loc') {\n                if (node.loc === null) {\n                    continue;\n                } else if (node.loc && node.loc.constructor === Object) {\n                    if (typeof node.loc.source !== 'string') {\n                        key += '.source';\n                    } else if (!isValidLocation(node.loc.start)) {\n                        key += '.start';\n                    } else if (!isValidLocation(node.loc.end)) {\n                        key += '.end';\n                    } else {\n                        continue;\n                    }\n                }\n\n                valid = false;\n            } else if (fields.hasOwnProperty(key)) {\n                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {\n                    var fieldType = fields[key][i];\n\n                    switch (fieldType) {\n                        case String:\n                            valid = typeof node[key] === 'string';\n                            break;\n\n                        case Boolean:\n                            valid = typeof node[key] === 'boolean';\n                            break;\n\n                        case null:\n                            valid = node[key] === null;\n                            break;\n\n                        default:\n                            if (typeof fieldType === 'string') {\n                                valid = node[key] && node[key].type === fieldType;\n                            } else if (Array.isArray(fieldType)) {\n                                valid = node[key] instanceof List;\n                            }\n                    }\n                }\n            } else {\n                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n            }\n\n            if (!valid) {\n                warn(node, 'Bad value for `' + type + '.' + key + '`');\n            }\n        }\n\n        for (var key in fields) {\n            if (hasOwnProperty.call(fields, key) &&\n                hasOwnProperty.call(node, key) === false) {\n                warn(node, 'Field `' + type + '.' + key + '` is missed');\n            }\n        }\n    };\n}\n\nfunction processStructure(name, nodeType) {\n    var structure = nodeType.structure;\n    var fields = {\n        type: String,\n        loc: true\n    };\n    var docs = {\n        type: '\"' + name + '\"'\n    };\n\n    for (var key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        var docsTypes = [];\n        var fieldTypes = fields[key] = Array.isArray(structure[key])\n            ? structure[key].slice()\n            : [structure[key]];\n\n        for (var i = 0; i < fieldTypes.length; i++) {\n            var fieldType = fieldTypes[i];\n            if (fieldType === String || fieldType === Boolean) {\n                docsTypes.push(fieldType.name);\n            } else if (fieldType === null) {\n                docsTypes.push('null');\n            } else if (typeof fieldType === 'string') {\n                docsTypes.push('<' + fieldType + '>');\n            } else if (Array.isArray(fieldType)) {\n                docsTypes.push('List'); // TODO: use type enum\n            } else {\n                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n            }\n        }\n\n        docs[key] = docsTypes.join(' | ');\n    }\n\n    return {\n        docs: docs,\n        check: createNodeStructureChecker(name, fields)\n    };\n}\n\nmodule.exports = {\n    getStructureFromConfig: function(config) {\n        var structure = {};\n\n        if (config.node) {\n            for (var name in config.node) {\n                if (hasOwnProperty.call(config.node, name)) {\n                    var nodeType = config.node[name];\n\n                    if (nodeType.structure) {\n                        structure[name] = processStructure(name, nodeType);\n                    } else {\n                        throw new Error('Missed `structure` field in `' + name + '` node type definition');\n                    }\n                }\n            }\n        }\n\n        return structure;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}