{"ast":null,"code":"const createCustomError = require('../utils/createCustomError');\nconst generate = require('../definition-syntax/generate');\nconst defaultLoc = {\n  offset: 0,\n  line: 1,\n  column: 1\n};\nfunction locateMismatch(matchResult, node) {\n  const tokens = matchResult.tokens;\n  const longestMatch = matchResult.longestMatch;\n  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n  const badNode = mismatchNode !== node ? mismatchNode : null;\n  let mismatchOffset = 0;\n  let mismatchLength = 0;\n  let entries = 0;\n  let css = '';\n  let start;\n  let end;\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i].value;\n    if (i === longestMatch) {\n      mismatchLength = token.length;\n      mismatchOffset = css.length;\n    }\n    if (badNode !== null && tokens[i].node === badNode) {\n      if (i <= longestMatch) {\n        entries++;\n      } else {\n        entries = 0;\n      }\n    }\n    css += token;\n  }\n  if (longestMatch === tokens.length || entries > 1) {\n    // last\n    start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n    end = buildLoc(start);\n  } else {\n    start = fromLoc(badNode, 'start') || buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n    end = fromLoc(badNode, 'end') || buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n  }\n  return {\n    css,\n    mismatchOffset,\n    mismatchLength,\n    start,\n    end\n  };\n}\nfunction fromLoc(node, point) {\n  const value = node && node.loc && node.loc[point];\n  if (value) {\n    return 'line' in value ? buildLoc(value) : value;\n  }\n  return null;\n}\nfunction buildLoc({\n  offset,\n  line,\n  column\n}, extra) {\n  const loc = {\n    offset,\n    line,\n    column\n  };\n  if (extra) {\n    const lines = extra.split(/\\n|\\r\\n?|\\f/);\n    loc.offset += extra.length;\n    loc.line += lines.length - 1;\n    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n  }\n  return loc;\n}\nconst SyntaxReferenceError = function (type, referenceName) {\n  const error = createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));\n  error.reference = referenceName;\n  return error;\n};\nconst SyntaxMatchError = function (message, syntax, node, matchResult) {\n  const error = createCustomError('SyntaxMatchError', message);\n  const {\n    css,\n    mismatchOffset,\n    mismatchLength,\n    start,\n    end\n  } = locateMismatch(matchResult, node);\n  error.rawMessage = message;\n  error.syntax = syntax ? generate(syntax) : '<generic>';\n  error.css = css;\n  error.mismatchOffset = mismatchOffset;\n  error.mismatchLength = mismatchLength;\n  error.message = message + '\\n' + '  syntax: ' + error.syntax + '\\n' + '   value: ' + (css || '<empty string>') + '\\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n  Object.assign(error, start);\n  error.loc = {\n    source: node && node.loc && node.loc.source || '<unknown>',\n    start,\n    end\n  };\n  return error;\n};\nmodule.exports = {\n  SyntaxReferenceError,\n  SyntaxMatchError\n};","map":{"version":3,"names":["createCustomError","require","generate","defaultLoc","offset","line","column","locateMismatch","matchResult","node","tokens","longestMatch","mismatchNode","length","badNode","mismatchOffset","mismatchLength","entries","css","start","end","i","token","value","fromLoc","buildLoc","slice","substr","point","loc","extra","lines","split","pop","SyntaxReferenceError","type","referenceName","error","reference","SyntaxMatchError","message","syntax","rawMessage","Array","join","Object","assign","source","module","exports"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/error.js"],"sourcesContent":["const createCustomError = require('../utils/createCustomError');\nconst generate = require('../definition-syntax/generate');\nconst defaultLoc = { offset: 0, line: 1, column: 1 };\n\nfunction locateMismatch(matchResult, node) {\n    const tokens = matchResult.tokens;\n    const longestMatch = matchResult.longestMatch;\n    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n    const badNode = mismatchNode !== node ? mismatchNode : null;\n    let mismatchOffset = 0;\n    let mismatchLength = 0;\n    let entries = 0;\n    let css = '';\n    let start;\n    let end;\n\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i].value;\n\n        if (i === longestMatch) {\n            mismatchLength = token.length;\n            mismatchOffset = css.length;\n        }\n\n        if (badNode !== null && tokens[i].node === badNode) {\n            if (i <= longestMatch) {\n                entries++;\n            } else {\n                entries = 0;\n            }\n        }\n\n        css += token;\n    }\n\n    if (longestMatch === tokens.length || entries > 1) { // last\n        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n        end = buildLoc(start);\n    } else {\n        start = fromLoc(badNode, 'start') ||\n            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n        end = fromLoc(badNode, 'end') ||\n            buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n    }\n\n    return {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    };\n}\n\nfunction fromLoc(node, point) {\n    const value = node && node.loc && node.loc[point];\n\n    if (value) {\n        return 'line' in value ? buildLoc(value) : value;\n    }\n\n    return null;\n}\n\nfunction buildLoc({ offset, line, column }, extra) {\n    const loc = {\n        offset,\n        line,\n        column\n    };\n\n    if (extra) {\n        const lines = extra.split(/\\n|\\r\\n?|\\f/);\n\n        loc.offset += extra.length;\n        loc.line += lines.length - 1;\n        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n    }\n\n    return loc;\n}\n\nconst SyntaxReferenceError = function(type, referenceName) {\n    const error = createCustomError(\n        'SyntaxReferenceError',\n        type + (referenceName ? ' `' + referenceName + '`' : '')\n    );\n\n    error.reference = referenceName;\n\n    return error;\n};\n\nconst SyntaxMatchError = function(message, syntax, node, matchResult) {\n    const error = createCustomError('SyntaxMatchError', message);\n    const {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    } = locateMismatch(matchResult, node);\n\n    error.rawMessage = message;\n    error.syntax = syntax ? generate(syntax) : '<generic>';\n    error.css = css;\n    error.mismatchOffset = mismatchOffset;\n    error.mismatchLength = mismatchLength;\n    error.message = message + '\\n' +\n        '  syntax: ' + error.syntax + '\\n' +\n        '   value: ' + (css || '<empty string>') + '\\n' +\n        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n\n    Object.assign(error, start);\n    error.loc = {\n        source: (node && node.loc && node.loc.source) || '<unknown>',\n        start,\n        end\n    };\n\n    return error;\n};\n\nmodule.exports = {\n    SyntaxReferenceError,\n    SyntaxMatchError\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}