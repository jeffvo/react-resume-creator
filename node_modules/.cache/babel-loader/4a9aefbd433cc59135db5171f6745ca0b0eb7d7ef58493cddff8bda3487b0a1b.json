{"ast":null,"code":"function getTrace(node) {\n  function shouldPutToTrace(syntax) {\n    if (syntax === null) {\n      return false;\n    }\n    return syntax.type === 'Type' || syntax.type === 'Property' || syntax.type === 'Keyword';\n  }\n  function hasMatch(matchNode) {\n    if (Array.isArray(matchNode.match)) {\n      // use for-loop for better perfomance\n      for (var i = 0; i < matchNode.match.length; i++) {\n        if (hasMatch(matchNode.match[i])) {\n          if (shouldPutToTrace(matchNode.syntax)) {\n            result.unshift(matchNode.syntax);\n          }\n          return true;\n        }\n      }\n    } else if (matchNode.node === node) {\n      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];\n      return true;\n    }\n    return false;\n  }\n  var result = null;\n  if (this.matched !== null) {\n    hasMatch(this.matched);\n  }\n  return result;\n}\nfunction testNode(match, node, fn) {\n  var trace = getTrace.call(match, node);\n  if (trace === null) {\n    return false;\n  }\n  return trace.some(fn);\n}\nfunction isType(node, type) {\n  return testNode(this, node, function (matchNode) {\n    return matchNode.type === 'Type' && matchNode.name === type;\n  });\n}\nfunction isProperty(node, property) {\n  return testNode(this, node, function (matchNode) {\n    return matchNode.type === 'Property' && matchNode.name === property;\n  });\n}\nfunction isKeyword(node) {\n  return testNode(this, node, function (matchNode) {\n    return matchNode.type === 'Keyword';\n  });\n}\nmodule.exports = {\n  getTrace: getTrace,\n  isType: isType,\n  isProperty: isProperty,\n  isKeyword: isKeyword\n};","map":{"version":3,"names":["getTrace","node","shouldPutToTrace","syntax","type","hasMatch","matchNode","Array","isArray","match","i","length","result","unshift","matched","testNode","fn","trace","call","some","isType","name","isProperty","property","isKeyword","module","exports"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/trace.js"],"sourcesContent":["function getTrace(node) {\n    function shouldPutToTrace(syntax) {\n        if (syntax === null) {\n            return false;\n        }\n\n        return (\n            syntax.type === 'Type' ||\n            syntax.type === 'Property' ||\n            syntax.type === 'Keyword'\n        );\n    }\n\n    function hasMatch(matchNode) {\n        if (Array.isArray(matchNode.match)) {\n            // use for-loop for better perfomance\n            for (var i = 0; i < matchNode.match.length; i++) {\n                if (hasMatch(matchNode.match[i])) {\n                    if (shouldPutToTrace(matchNode.syntax)) {\n                        result.unshift(matchNode.syntax);\n                    }\n\n                    return true;\n                }\n            }\n        } else if (matchNode.node === node) {\n            result = shouldPutToTrace(matchNode.syntax)\n                ? [matchNode.syntax]\n                : [];\n\n            return true;\n        }\n\n        return false;\n    }\n\n    var result = null;\n\n    if (this.matched !== null) {\n        hasMatch(this.matched);\n    }\n\n    return result;\n}\n\nfunction testNode(match, node, fn) {\n    var trace = getTrace.call(match, node);\n\n    if (trace === null) {\n        return false;\n    }\n\n    return trace.some(fn);\n}\n\nfunction isType(node, type) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Type' && matchNode.name === type;\n    });\n}\n\nfunction isProperty(node, property) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Property' && matchNode.name === property;\n    });\n}\n\nfunction isKeyword(node) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Keyword';\n    });\n}\n\nmodule.exports = {\n    getTrace: getTrace,\n    isType: isType,\n    isProperty: isProperty,\n    isKeyword: isKeyword\n};\n"],"mappings":"AAAA,SAASA,QAAQA,CAACC,IAAI,EAAE;EACpB,SAASC,gBAAgBA,CAACC,MAAM,EAAE;IAC9B,IAAIA,MAAM,KAAK,IAAI,EAAE;MACjB,OAAO,KAAK;IAChB;IAEA,OACIA,MAAM,CAACC,IAAI,KAAK,MAAM,IACtBD,MAAM,CAACC,IAAI,KAAK,UAAU,IAC1BD,MAAM,CAACC,IAAI,KAAK,SAAS;EAEjC;EAEA,SAASC,QAAQA,CAACC,SAAS,EAAE;IACzB,IAAIC,KAAK,CAACC,OAAO,CAACF,SAAS,CAACG,KAAK,CAAC,EAAE;MAChC;MACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,SAAS,CAACG,KAAK,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;QAC7C,IAAIL,QAAQ,CAACC,SAAS,CAACG,KAAK,CAACC,CAAC,CAAC,CAAC,EAAE;UAC9B,IAAIR,gBAAgB,CAACI,SAAS,CAACH,MAAM,CAAC,EAAE;YACpCS,MAAM,CAACC,OAAO,CAACP,SAAS,CAACH,MAAM,CAAC;UACpC;UAEA,OAAO,IAAI;QACf;MACJ;IACJ,CAAC,MAAM,IAAIG,SAAS,CAACL,IAAI,KAAKA,IAAI,EAAE;MAChCW,MAAM,GAAGV,gBAAgB,CAACI,SAAS,CAACH,MAAM,CAAC,GACrC,CAACG,SAAS,CAACH,MAAM,CAAC,GAClB,EAAE;MAER,OAAO,IAAI;IACf;IAEA,OAAO,KAAK;EAChB;EAEA,IAAIS,MAAM,GAAG,IAAI;EAEjB,IAAI,IAAI,CAACE,OAAO,KAAK,IAAI,EAAE;IACvBT,QAAQ,CAAC,IAAI,CAACS,OAAO,CAAC;EAC1B;EAEA,OAAOF,MAAM;AACjB;AAEA,SAASG,QAAQA,CAACN,KAAK,EAAER,IAAI,EAAEe,EAAE,EAAE;EAC/B,IAAIC,KAAK,GAAGjB,QAAQ,CAACkB,IAAI,CAACT,KAAK,EAAER,IAAI,CAAC;EAEtC,IAAIgB,KAAK,KAAK,IAAI,EAAE;IAChB,OAAO,KAAK;EAChB;EAEA,OAAOA,KAAK,CAACE,IAAI,CAACH,EAAE,CAAC;AACzB;AAEA,SAASI,MAAMA,CAACnB,IAAI,EAAEG,IAAI,EAAE;EACxB,OAAOW,QAAQ,CAAC,IAAI,EAAEd,IAAI,EAAE,UAASK,SAAS,EAAE;IAC5C,OAAOA,SAAS,CAACF,IAAI,KAAK,MAAM,IAAIE,SAAS,CAACe,IAAI,KAAKjB,IAAI;EAC/D,CAAC,CAAC;AACN;AAEA,SAASkB,UAAUA,CAACrB,IAAI,EAAEsB,QAAQ,EAAE;EAChC,OAAOR,QAAQ,CAAC,IAAI,EAAEd,IAAI,EAAE,UAASK,SAAS,EAAE;IAC5C,OAAOA,SAAS,CAACF,IAAI,KAAK,UAAU,IAAIE,SAAS,CAACe,IAAI,KAAKE,QAAQ;EACvE,CAAC,CAAC;AACN;AAEA,SAASC,SAASA,CAACvB,IAAI,EAAE;EACrB,OAAOc,QAAQ,CAAC,IAAI,EAAEd,IAAI,EAAE,UAASK,SAAS,EAAE;IAC5C,OAAOA,SAAS,CAACF,IAAI,KAAK,SAAS;EACvC,CAAC,CAAC;AACN;AAEAqB,MAAM,CAACC,OAAO,GAAG;EACb1B,QAAQ,EAAEA,QAAQ;EAClBoB,MAAM,EAAEA,MAAM;EACdE,UAAU,EAAEA,UAAU;EACtBE,SAAS,EAAEA;AACf,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}