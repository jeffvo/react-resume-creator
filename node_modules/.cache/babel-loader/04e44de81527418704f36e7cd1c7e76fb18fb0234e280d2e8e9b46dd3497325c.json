{"ast":null,"code":"var SyntaxReferenceError = require('./error').SyntaxReferenceError;\nvar SyntaxMatchError = require('./error').SyntaxMatchError;\nvar names = require('../utils/names');\nvar generic = require('./generic');\nvar parse = require('../definition-syntax/parse');\nvar generate = require('../definition-syntax/generate');\nvar walk = require('../definition-syntax/walk');\nvar prepareTokens = require('./prepare-tokens');\nvar buildMatchGraph = require('./match-graph').buildMatchGraph;\nvar matchAsTree = require('./match').matchAsTree;\nvar trace = require('./trace');\nvar search = require('./search');\nvar getStructureFromConfig = require('./structure').getStructureFromConfig;\nvar cssWideKeywords = buildMatchGraph('inherit | initial | unset');\nvar cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n  var result = {};\n  for (var name in map) {\n    if (map[name].syntax) {\n      result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, {\n        compact: compact\n      });\n    }\n  }\n  return result;\n}\nfunction dumpAtruleMapSyntax(map, compact, syntaxAsAst) {\n  const result = {};\n  for (const [name, atrule] of Object.entries(map)) {\n    result[name] = {\n      prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, {\n        compact\n      })),\n      descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)\n    };\n  }\n  return result;\n}\nfunction valueHasVar(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].value.toLowerCase() === 'var(') {\n      return true;\n    }\n  }\n  return false;\n}\nfunction buildMatchResult(match, error, iterations) {\n  return {\n    matched: match,\n    iterations: iterations,\n    error: error,\n    getTrace: trace.getTrace,\n    isType: trace.isType,\n    isProperty: trace.isProperty,\n    isKeyword: trace.isKeyword\n  };\n}\nfunction matchSyntax(lexer, syntax, value, useCommon) {\n  var tokens = prepareTokens(value, lexer.syntax);\n  var result;\n  if (valueHasVar(tokens)) {\n    return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n  }\n  if (useCommon) {\n    result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);\n  }\n  if (!useCommon || !result.match) {\n    result = matchAsTree(tokens, syntax.match, lexer);\n    if (!result.match) {\n      return buildMatchResult(null, new SyntaxMatchError(result.reason, syntax.syntax, value, result), result.iterations);\n    }\n  }\n  return buildMatchResult(result.match, null, result.iterations);\n}\nvar Lexer = function (config, syntax, structure) {\n  this.valueCommonSyntax = cssWideKeywords;\n  this.syntax = syntax;\n  this.generic = false;\n  this.atrules = {};\n  this.properties = {};\n  this.types = {};\n  this.structure = structure || getStructureFromConfig(config);\n  if (config) {\n    if (config.types) {\n      for (var name in config.types) {\n        this.addType_(name, config.types[name]);\n      }\n    }\n    if (config.generic) {\n      this.generic = true;\n      for (var name in generic) {\n        this.addType_(name, generic[name]);\n      }\n    }\n    if (config.atrules) {\n      for (var name in config.atrules) {\n        this.addAtrule_(name, config.atrules[name]);\n      }\n    }\n    if (config.properties) {\n      for (var name in config.properties) {\n        this.addProperty_(name, config.properties[name]);\n      }\n    }\n  }\n};\nLexer.prototype = {\n  structure: {},\n  checkStructure: function (ast) {\n    function collectWarning(node, message) {\n      warns.push({\n        node: node,\n        message: message\n      });\n    }\n    var structure = this.structure;\n    var warns = [];\n    this.syntax.walk(ast, function (node) {\n      if (structure.hasOwnProperty(node.type)) {\n        structure[node.type].check(node, collectWarning);\n      } else {\n        collectWarning(node, 'Unknown node type `' + node.type + '`');\n      }\n    });\n    return warns.length ? warns : false;\n  },\n  createDescriptor: function (syntax, type, name, parent = null) {\n    var ref = {\n      type: type,\n      name: name\n    };\n    var descriptor = {\n      type: type,\n      name: name,\n      parent: parent,\n      syntax: null,\n      match: null\n    };\n    if (typeof syntax === 'function') {\n      descriptor.match = buildMatchGraph(syntax, ref);\n    } else {\n      if (typeof syntax === 'string') {\n        // lazy parsing on first access\n        Object.defineProperty(descriptor, 'syntax', {\n          get: function () {\n            Object.defineProperty(descriptor, 'syntax', {\n              value: parse(syntax)\n            });\n            return descriptor.syntax;\n          }\n        });\n      } else {\n        descriptor.syntax = syntax;\n      }\n\n      // lazy graph build on first access\n      Object.defineProperty(descriptor, 'match', {\n        get: function () {\n          Object.defineProperty(descriptor, 'match', {\n            value: buildMatchGraph(descriptor.syntax, ref)\n          });\n          return descriptor.match;\n        }\n      });\n    }\n    return descriptor;\n  },\n  addAtrule_: function (name, syntax) {\n    if (!syntax) {\n      return;\n    }\n    this.atrules[name] = {\n      type: 'Atrule',\n      name: name,\n      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((res, descName) => {\n        res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);\n        return res;\n      }, {}) : null\n    };\n  },\n  addProperty_: function (name, syntax) {\n    if (!syntax) {\n      return;\n    }\n    this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n  },\n  addType_: function (name, syntax) {\n    if (!syntax) {\n      return;\n    }\n    this.types[name] = this.createDescriptor(syntax, 'Type', name);\n    if (syntax === generic['-ms-legacy-expression']) {\n      this.valueCommonSyntax = cssWideKeywordsWithExpression;\n    }\n  },\n  checkAtruleName: function (atruleName) {\n    if (!this.getAtrule(atruleName)) {\n      return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);\n    }\n  },\n  checkAtrulePrelude: function (atruleName, prelude) {\n    let error = this.checkAtruleName(atruleName);\n    if (error) {\n      return error;\n    }\n    var atrule = this.getAtrule(atruleName);\n    if (!atrule.prelude && prelude) {\n      return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');\n    }\n    if (atrule.prelude && !prelude) {\n      return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');\n    }\n  },\n  checkAtruleDescriptorName: function (atruleName, descriptorName) {\n    let error = this.checkAtruleName(atruleName);\n    if (error) {\n      return error;\n    }\n    var atrule = this.getAtrule(atruleName);\n    var descriptor = names.keyword(descriptorName);\n    if (!atrule.descriptors) {\n      return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');\n    }\n    if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {\n      return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);\n    }\n  },\n  checkPropertyName: function (propertyName) {\n    var property = names.property(propertyName);\n\n    // don't match syntax for a custom property\n    if (property.custom) {\n      return new Error('Lexer matching doesn\\'t applicable for custom properties');\n    }\n    if (!this.getProperty(propertyName)) {\n      return new SyntaxReferenceError('Unknown property', propertyName);\n    }\n  },\n  matchAtrulePrelude: function (atruleName, prelude) {\n    var error = this.checkAtrulePrelude(atruleName, prelude);\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n    if (!prelude) {\n      return buildMatchResult(null, null);\n    }\n    return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);\n  },\n  matchAtruleDescriptor: function (atruleName, descriptorName, value) {\n    var error = this.checkAtruleDescriptorName(atruleName, descriptorName);\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n    var atrule = this.getAtrule(atruleName);\n    var descriptor = names.keyword(descriptorName);\n    return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);\n  },\n  matchDeclaration: function (node) {\n    if (node.type !== 'Declaration') {\n      return buildMatchResult(null, new Error('Not a Declaration node'));\n    }\n    return this.matchProperty(node.property, node.value);\n  },\n  matchProperty: function (propertyName, value) {\n    var error = this.checkPropertyName(propertyName);\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n    return matchSyntax(this, this.getProperty(propertyName), value, true);\n  },\n  matchType: function (typeName, value) {\n    var typeSyntax = this.getType(typeName);\n    if (!typeSyntax) {\n      return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n    }\n    return matchSyntax(this, typeSyntax, value, false);\n  },\n  match: function (syntax, value) {\n    if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n      return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n    }\n    if (typeof syntax === 'string' || !syntax.match) {\n      syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n    }\n    return matchSyntax(this, syntax, value, false);\n  },\n  findValueFragments: function (propertyName, value, type, name) {\n    return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n  },\n  findDeclarationValueFragments: function (declaration, type, name) {\n    return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n  },\n  findAllFragments: function (ast, type, name) {\n    var result = [];\n    this.syntax.walk(ast, {\n      visit: 'Declaration',\n      enter: function (declaration) {\n        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n      }.bind(this)\n    });\n    return result;\n  },\n  getAtrule: function (atruleName, fallbackBasename = true) {\n    var atrule = names.keyword(atruleName);\n    var atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];\n    return atruleEntry || null;\n  },\n  getAtrulePrelude: function (atruleName, fallbackBasename = true) {\n    const atrule = this.getAtrule(atruleName, fallbackBasename);\n    return atrule && atrule.prelude || null;\n  },\n  getAtruleDescriptor: function (atruleName, name) {\n    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;\n  },\n  getProperty: function (propertyName, fallbackBasename = true) {\n    var property = names.property(propertyName);\n    var propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];\n    return propertyEntry || null;\n  },\n  getType: function (name) {\n    return this.types.hasOwnProperty(name) ? this.types[name] : null;\n  },\n  validate: function () {\n    function validate(syntax, name, broken, descriptor) {\n      if (broken.hasOwnProperty(name)) {\n        return broken[name];\n      }\n      broken[name] = false;\n      if (descriptor.syntax !== null) {\n        walk(descriptor.syntax, function (node) {\n          if (node.type !== 'Type' && node.type !== 'Property') {\n            return;\n          }\n          var map = node.type === 'Type' ? syntax.types : syntax.properties;\n          var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n          if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n            broken[name] = true;\n          }\n        }, this);\n      }\n    }\n    var brokenTypes = {};\n    var brokenProperties = {};\n    for (var key in this.types) {\n      validate(this, key, brokenTypes, this.types[key]);\n    }\n    for (var key in this.properties) {\n      validate(this, key, brokenProperties, this.properties[key]);\n    }\n    brokenTypes = Object.keys(brokenTypes).filter(function (name) {\n      return brokenTypes[name];\n    });\n    brokenProperties = Object.keys(brokenProperties).filter(function (name) {\n      return brokenProperties[name];\n    });\n    if (brokenTypes.length || brokenProperties.length) {\n      return {\n        types: brokenTypes,\n        properties: brokenProperties\n      };\n    }\n    return null;\n  },\n  dump: function (syntaxAsAst, pretty) {\n    return {\n      generic: this.generic,\n      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),\n      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)\n    };\n  },\n  toString: function () {\n    return JSON.stringify(this.dump());\n  }\n};\nmodule.exports = Lexer;","map":{"version":3,"names":["SyntaxReferenceError","require","SyntaxMatchError","names","generic","parse","generate","walk","prepareTokens","buildMatchGraph","matchAsTree","trace","search","getStructureFromConfig","cssWideKeywords","cssWideKeywordsWithExpression","dumpMapSyntax","map","compact","syntaxAsAst","result","name","syntax","dumpAtruleMapSyntax","atrule","Object","entries","prelude","descriptors","valueHasVar","tokens","i","length","value","toLowerCase","buildMatchResult","match","error","iterations","matched","getTrace","isType","isProperty","isKeyword","matchSyntax","lexer","useCommon","Error","valueCommonSyntax","reason","Lexer","config","structure","atrules","properties","types","addType_","addAtrule_","addProperty_","prototype","checkStructure","ast","collectWarning","node","message","warns","push","hasOwnProperty","type","check","createDescriptor","parent","ref","descriptor","defineProperty","get","keys","reduce","res","descName","checkAtruleName","atruleName","getAtrule","checkAtrulePrelude","SyntaxError","checkAtruleDescriptorName","descriptorName","keyword","basename","checkPropertyName","propertyName","property","custom","getProperty","matchAtrulePrelude","matchAtruleDescriptor","matchDeclaration","matchProperty","matchType","typeName","typeSyntax","getType","findValueFragments","matchFragments","findDeclarationValueFragments","declaration","findAllFragments","visit","enter","apply","bind","fallbackBasename","atruleEntry","vendor","getAtrulePrelude","getAtruleDescriptor","declarators","propertyEntry","validate","broken","brokenMap","brokenTypes","brokenProperties","key","filter","dump","pretty","toString","JSON","stringify","module","exports"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/Lexer.js"],"sourcesContent":["var SyntaxReferenceError = require('./error').SyntaxReferenceError;\nvar SyntaxMatchError = require('./error').SyntaxMatchError;\nvar names = require('../utils/names');\nvar generic = require('./generic');\nvar parse = require('../definition-syntax/parse');\nvar generate = require('../definition-syntax/generate');\nvar walk = require('../definition-syntax/walk');\nvar prepareTokens = require('./prepare-tokens');\nvar buildMatchGraph = require('./match-graph').buildMatchGraph;\nvar matchAsTree = require('./match').matchAsTree;\nvar trace = require('./trace');\nvar search = require('./search');\nvar getStructureFromConfig = require('./structure').getStructureFromConfig;\nvar cssWideKeywords = buildMatchGraph('inherit | initial | unset');\nvar cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');\n\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n    var result = {};\n\n    for (var name in map) {\n        if (map[name].syntax) {\n            result[name] = syntaxAsAst\n                ? map[name].syntax\n                : generate(map[name].syntax, { compact: compact });\n        }\n    }\n\n    return result;\n}\n\nfunction dumpAtruleMapSyntax(map, compact, syntaxAsAst) {\n    const result = {};\n\n    for (const [name, atrule] of Object.entries(map)) {\n        result[name] = {\n            prelude: atrule.prelude && (\n                syntaxAsAst\n                    ? atrule.prelude.syntax\n                    : generate(atrule.prelude.syntax, { compact })\n            ),\n            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)\n        };\n    }\n\n    return result;\n}\n\nfunction valueHasVar(tokens) {\n    for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i].value.toLowerCase() === 'var(') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction buildMatchResult(match, error, iterations) {\n    return {\n        matched: match,\n        iterations: iterations,\n        error: error,\n        getTrace: trace.getTrace,\n        isType: trace.isType,\n        isProperty: trace.isProperty,\n        isKeyword: trace.isKeyword\n    };\n}\n\nfunction matchSyntax(lexer, syntax, value, useCommon) {\n    var tokens = prepareTokens(value, lexer.syntax);\n    var result;\n\n    if (valueHasVar(tokens)) {\n        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n    }\n\n    if (useCommon) {\n        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);\n    }\n\n    if (!useCommon || !result.match) {\n        result = matchAsTree(tokens, syntax.match, lexer);\n        if (!result.match) {\n            return buildMatchResult(\n                null,\n                new SyntaxMatchError(result.reason, syntax.syntax, value, result),\n                result.iterations\n            );\n        }\n    }\n\n    return buildMatchResult(result.match, null, result.iterations);\n}\n\nvar Lexer = function(config, syntax, structure) {\n    this.valueCommonSyntax = cssWideKeywords;\n    this.syntax = syntax;\n    this.generic = false;\n    this.atrules = {};\n    this.properties = {};\n    this.types = {};\n    this.structure = structure || getStructureFromConfig(config);\n\n    if (config) {\n        if (config.types) {\n            for (var name in config.types) {\n                this.addType_(name, config.types[name]);\n            }\n        }\n\n        if (config.generic) {\n            this.generic = true;\n            for (var name in generic) {\n                this.addType_(name, generic[name]);\n            }\n        }\n\n        if (config.atrules) {\n            for (var name in config.atrules) {\n                this.addAtrule_(name, config.atrules[name]);\n            }\n        }\n\n        if (config.properties) {\n            for (var name in config.properties) {\n                this.addProperty_(name, config.properties[name]);\n            }\n        }\n    }\n};\n\nLexer.prototype = {\n    structure: {},\n    checkStructure: function(ast) {\n        function collectWarning(node, message) {\n            warns.push({\n                node: node,\n                message: message\n            });\n        }\n\n        var structure = this.structure;\n        var warns = [];\n\n        this.syntax.walk(ast, function(node) {\n            if (structure.hasOwnProperty(node.type)) {\n                structure[node.type].check(node, collectWarning);\n            } else {\n                collectWarning(node, 'Unknown node type `' + node.type + '`');\n            }\n        });\n\n        return warns.length ? warns : false;\n    },\n\n    createDescriptor: function(syntax, type, name, parent = null) {\n        var ref = {\n            type: type,\n            name: name\n        };\n        var descriptor = {\n            type: type,\n            name: name,\n            parent: parent,\n            syntax: null,\n            match: null\n        };\n\n        if (typeof syntax === 'function') {\n            descriptor.match = buildMatchGraph(syntax, ref);\n        } else {\n            if (typeof syntax === 'string') {\n                // lazy parsing on first access\n                Object.defineProperty(descriptor, 'syntax', {\n                    get: function() {\n                        Object.defineProperty(descriptor, 'syntax', {\n                            value: parse(syntax)\n                        });\n\n                        return descriptor.syntax;\n                    }\n                });\n            } else {\n                descriptor.syntax = syntax;\n            }\n\n            // lazy graph build on first access\n            Object.defineProperty(descriptor, 'match', {\n                get: function() {\n                    Object.defineProperty(descriptor, 'match', {\n                        value: buildMatchGraph(descriptor.syntax, ref)\n                    });\n\n                    return descriptor.match;\n                }\n            });\n        }\n\n        return descriptor;\n    },\n    addAtrule_: function(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.atrules[name] = {\n            type: 'Atrule',\n            name: name,\n            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n            descriptors: syntax.descriptors\n                ? Object.keys(syntax.descriptors).reduce((res, descName) => {\n                    res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);\n                    return res;\n                }, {})\n                : null\n        };\n    },\n    addProperty_: function(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n    },\n    addType_: function(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.types[name] = this.createDescriptor(syntax, 'Type', name);\n\n        if (syntax === generic['-ms-legacy-expression']) {\n            this.valueCommonSyntax = cssWideKeywordsWithExpression;\n        }\n    },\n\n    checkAtruleName: function(atruleName) {\n        if (!this.getAtrule(atruleName)) {\n            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);\n        }\n    },\n    checkAtrulePrelude: function(atruleName, prelude) {\n        let error = this.checkAtruleName(atruleName);\n\n        if (error) {\n            return error;\n        }\n\n        var atrule = this.getAtrule(atruleName);\n\n        if (!atrule.prelude && prelude) {\n            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');\n        }\n\n        if (atrule.prelude && !prelude) {\n            return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');\n        }\n    },\n    checkAtruleDescriptorName: function(atruleName, descriptorName) {\n        let error = this.checkAtruleName(atruleName);\n\n        if (error) {\n            return error;\n        }\n\n        var atrule = this.getAtrule(atruleName);\n        var descriptor = names.keyword(descriptorName);\n\n        if (!atrule.descriptors) {\n            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');\n        }\n\n        if (!atrule.descriptors[descriptor.name] &&\n            !atrule.descriptors[descriptor.basename]) {\n            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);\n        }\n    },\n    checkPropertyName: function(propertyName) {\n        var property = names.property(propertyName);\n\n        // don't match syntax for a custom property\n        if (property.custom) {\n            return new Error('Lexer matching doesn\\'t applicable for custom properties');\n        }\n\n        if (!this.getProperty(propertyName)) {\n            return new SyntaxReferenceError('Unknown property', propertyName);\n        }\n    },\n\n    matchAtrulePrelude: function(atruleName, prelude) {\n        var error = this.checkAtrulePrelude(atruleName, prelude);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        if (!prelude) {\n            return buildMatchResult(null, null);\n        }\n\n        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);\n    },\n    matchAtruleDescriptor: function(atruleName, descriptorName, value) {\n        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        var atrule = this.getAtrule(atruleName);\n        var descriptor = names.keyword(descriptorName);\n\n        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);\n    },\n    matchDeclaration: function(node) {\n        if (node.type !== 'Declaration') {\n            return buildMatchResult(null, new Error('Not a Declaration node'));\n        }\n\n        return this.matchProperty(node.property, node.value);\n    },\n    matchProperty: function(propertyName, value) {\n        var error = this.checkPropertyName(propertyName);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        return matchSyntax(this, this.getProperty(propertyName), value, true);\n    },\n    matchType: function(typeName, value) {\n        var typeSyntax = this.getType(typeName);\n\n        if (!typeSyntax) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n        }\n\n        return matchSyntax(this, typeSyntax, value, false);\n    },\n    match: function(syntax, value) {\n        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n        }\n\n        if (typeof syntax === 'string' || !syntax.match) {\n            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n        }\n\n        return matchSyntax(this, syntax, value, false);\n    },\n\n    findValueFragments: function(propertyName, value, type, name) {\n        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n    },\n    findDeclarationValueFragments: function(declaration, type, name) {\n        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n    },\n    findAllFragments: function(ast, type, name) {\n        var result = [];\n\n        this.syntax.walk(ast, {\n            visit: 'Declaration',\n            enter: function(declaration) {\n                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n            }.bind(this)\n        });\n\n        return result;\n    },\n\n    getAtrule: function(atruleName, fallbackBasename = true) {\n        var atrule = names.keyword(atruleName);\n        var atruleEntry = atrule.vendor && fallbackBasename\n            ? this.atrules[atrule.name] || this.atrules[atrule.basename]\n            : this.atrules[atrule.name];\n\n        return atruleEntry || null;\n    },\n    getAtrulePrelude: function(atruleName, fallbackBasename = true) {\n        const atrule = this.getAtrule(atruleName, fallbackBasename);\n\n        return atrule && atrule.prelude || null;\n    },\n    getAtruleDescriptor: function(atruleName, name) {\n        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators\n            ? this.atrules[atruleName].declarators[name] || null\n            : null;\n    },\n    getProperty: function(propertyName, fallbackBasename = true) {\n        var property = names.property(propertyName);\n        var propertyEntry = property.vendor && fallbackBasename\n            ? this.properties[property.name] || this.properties[property.basename]\n            : this.properties[property.name];\n\n        return propertyEntry || null;\n    },\n    getType: function(name) {\n        return this.types.hasOwnProperty(name) ? this.types[name] : null;\n    },\n\n    validate: function() {\n        function validate(syntax, name, broken, descriptor) {\n            if (broken.hasOwnProperty(name)) {\n                return broken[name];\n            }\n\n            broken[name] = false;\n            if (descriptor.syntax !== null) {\n                walk(descriptor.syntax, function(node) {\n                    if (node.type !== 'Type' && node.type !== 'Property') {\n                        return;\n                    }\n\n                    var map = node.type === 'Type' ? syntax.types : syntax.properties;\n                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n                        broken[name] = true;\n                    }\n                }, this);\n            }\n        }\n\n        var brokenTypes = {};\n        var brokenProperties = {};\n\n        for (var key in this.types) {\n            validate(this, key, brokenTypes, this.types[key]);\n        }\n\n        for (var key in this.properties) {\n            validate(this, key, brokenProperties, this.properties[key]);\n        }\n\n        brokenTypes = Object.keys(brokenTypes).filter(function(name) {\n            return brokenTypes[name];\n        });\n        brokenProperties = Object.keys(brokenProperties).filter(function(name) {\n            return brokenProperties[name];\n        });\n\n        if (brokenTypes.length || brokenProperties.length) {\n            return {\n                types: brokenTypes,\n                properties: brokenProperties\n            };\n        }\n\n        return null;\n    },\n    dump: function(syntaxAsAst, pretty) {\n        return {\n            generic: this.generic,\n            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),\n            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)\n        };\n    },\n    toString: function() {\n        return JSON.stringify(this.dump());\n    }\n};\n\nmodule.exports = Lexer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}