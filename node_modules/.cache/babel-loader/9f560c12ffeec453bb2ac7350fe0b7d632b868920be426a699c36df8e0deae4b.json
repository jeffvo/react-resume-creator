{"ast":null,"code":"import he from 'he';\nimport { selectAll, selectOne } from 'css-select';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\n// const { decode } = he;\nfunction decode(val) {\n  // clone string\n  return JSON.parse(JSON.stringify(he.decode(val)));\n}\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst kBlockElements = new Set();\nkBlockElements.add('address');\nkBlockElements.add('ADDRESS');\nkBlockElements.add('article');\nkBlockElements.add('ARTICLE');\nkBlockElements.add('aside');\nkBlockElements.add('ASIDE');\nkBlockElements.add('blockquote');\nkBlockElements.add('BLOCKQUOTE');\nkBlockElements.add('br');\nkBlockElements.add('BR');\nkBlockElements.add('details');\nkBlockElements.add('DETAILS');\nkBlockElements.add('dialog');\nkBlockElements.add('DIALOG');\nkBlockElements.add('dd');\nkBlockElements.add('DD');\nkBlockElements.add('div');\nkBlockElements.add('DIV');\nkBlockElements.add('dl');\nkBlockElements.add('DL');\nkBlockElements.add('dt');\nkBlockElements.add('DT');\nkBlockElements.add('fieldset');\nkBlockElements.add('FIELDSET');\nkBlockElements.add('figcaption');\nkBlockElements.add('FIGCAPTION');\nkBlockElements.add('figure');\nkBlockElements.add('FIGURE');\nkBlockElements.add('footer');\nkBlockElements.add('FOOTER');\nkBlockElements.add('form');\nkBlockElements.add('FORM');\nkBlockElements.add('h1');\nkBlockElements.add('H1');\nkBlockElements.add('h2');\nkBlockElements.add('H2');\nkBlockElements.add('h3');\nkBlockElements.add('H3');\nkBlockElements.add('h4');\nkBlockElements.add('H4');\nkBlockElements.add('h5');\nkBlockElements.add('H5');\nkBlockElements.add('h6');\nkBlockElements.add('H6');\nkBlockElements.add('header');\nkBlockElements.add('HEADER');\nkBlockElements.add('hgroup');\nkBlockElements.add('HGROUP');\nkBlockElements.add('hr');\nkBlockElements.add('HR');\nkBlockElements.add('li');\nkBlockElements.add('LI');\nkBlockElements.add('main');\nkBlockElements.add('MAIN');\nkBlockElements.add('nav');\nkBlockElements.add('NAV');\nkBlockElements.add('ol');\nkBlockElements.add('OL');\nkBlockElements.add('p');\nkBlockElements.add('P');\nkBlockElements.add('pre');\nkBlockElements.add('PRE');\nkBlockElements.add('section');\nkBlockElements.add('SECTION');\nkBlockElements.add('table');\nkBlockElements.add('TABLE');\nkBlockElements.add('td');\nkBlockElements.add('TD');\nkBlockElements.add('tr');\nkBlockElements.add('TR');\nkBlockElements.add('ul');\nkBlockElements.add('UL');\nclass DOMTokenList {\n  constructor(valuesInit = [], afterUpdate = () => null) {\n    this._set = new Set(valuesInit);\n    this._afterUpdate = afterUpdate;\n  }\n  _validate(c) {\n    if (/\\s/.test(c)) {\n      throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);\n    }\n  }\n  add(c) {\n    this._validate(c);\n    this._set.add(c);\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n  replace(c1, c2) {\n    this._validate(c2);\n    this._set.delete(c1);\n    this._set.add(c2);\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n  remove(c) {\n    this._set.delete(c) && this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n  toggle(c) {\n    this._validate(c);\n    if (this._set.has(c)) this._set.delete(c);else this._set.add(c);\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n  contains(c) {\n    return this._set.has(c);\n  }\n  get length() {\n    return this._set.size;\n  }\n  values() {\n    return this._set.values();\n  }\n  get value() {\n    return Array.from(this._set.values());\n  }\n  toString() {\n    return Array.from(this._set.values()).join(' ');\n  }\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nexport default class HTMLElement extends Node {\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  constructor(tagName, keyAttrs, rawAttrs = '', parentNode) {\n    super(parentNode);\n    this.rawAttrs = rawAttrs;\n    /**\n     * Node Type declaration.\n     */\n    this.nodeType = NodeType.ELEMENT_NODE;\n    this.rawTagName = tagName;\n    this.rawAttrs = rawAttrs || '';\n    this.id = keyAttrs.id || '';\n    this.childNodes = [];\n    this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], classList => this.setAttribute('class', classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    );\n    if (keyAttrs.id) {\n      if (!rawAttrs) {\n        this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n      }\n    }\n    if (keyAttrs.class) {\n      if (!rawAttrs) {\n        const cls = `class=\"${this.classList.toString()}\"`;\n        if (this.rawAttrs) {\n          this.rawAttrs += ` ${cls}`;\n        } else {\n          this.rawAttrs = cls;\n        }\n      }\n    }\n  }\n  /**\n   * Quote attribute values\n   * @param attr attribute value\n   * @returns {string} quoted value\n   */\n  quoteAttribute(attr) {\n    if (attr === null) {\n      return \"null\";\n    }\n    return JSON.stringify(attr.replace(/\"/g, '&quot;'));\n  }\n  /**\n   * Remove current element\n   */\n  remove() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      this.parentNode.childNodes = children.filter(child => {\n        return this !== child;\n      });\n    }\n  }\n  /**\n   * Remove Child element from childNodes array\n   * @param {HTMLElement} node     node to remove\n   */\n  removeChild(node) {\n    this.childNodes = this.childNodes.filter(child => {\n      return child !== node;\n    });\n  }\n  /**\n   * Exchanges given child with new child\n   * @param {HTMLElement} oldNode     node to exchange\n   * @param {HTMLElement} newNode     new node\n   */\n  exchangeChild(oldNode, newNode) {\n    const children = this.childNodes;\n    this.childNodes = children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n      return child;\n    });\n  }\n  get tagName() {\n    return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n  }\n  get localName() {\n    return this.rawTagName.toLowerCase();\n  }\n  /**\n   * Get escpaed (as-it) text value of current node and its children.\n   * @return {string} text content\n   */\n  get rawText() {\n    return this.childNodes.reduce((pre, cur) => {\n      return pre += cur.rawText;\n    }, '');\n  }\n  get textContent() {\n    return this.rawText;\n  }\n  set textContent(val) {\n    const content = [new TextNode(val, this)];\n    this.childNodes = content;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n  get text() {\n    return decode(this.rawText);\n  }\n  /**\n   * Get structured Text (with '\\n' etc.)\n   * @return {string} structured text\n   */\n  get structuredText() {\n    let currentBlock = [];\n    const blocks = [currentBlock];\n    function dfs(node) {\n      if (node.nodeType === NodeType.ELEMENT_NODE) {\n        if (kBlockElements.has(node.rawTagName)) {\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n          node.childNodes.forEach(dfs);\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n        } else {\n          node.childNodes.forEach(dfs);\n        }\n      } else if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          // Whitespace node, postponed output\n          currentBlock.prependWhitespace = true;\n        } else {\n          let text = node.trimmedText;\n          if (currentBlock.prependWhitespace) {\n            text = ` ${text}`;\n            currentBlock.prependWhitespace = false;\n          }\n          currentBlock.push(text);\n        }\n      }\n    }\n    dfs(this);\n    return blocks.map(block => {\n      // Normalize each line's whitespace\n      return block.join('').replace(/\\s{2,}/g, ' ');\n    }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n  }\n  toString() {\n    const tag = this.rawTagName;\n    if (tag) {\n      // const void_tags = new Set('area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr'.split('|'));\n      // const is_void = void_tags.has(tag);\n      const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n      const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n      if (is_void) {\n        return `<${tag}${attrs}>`;\n      }\n      return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n    }\n    return this.innerHTML;\n  }\n  get innerHTML() {\n    return this.childNodes.map(child => {\n      return child.toString();\n    }).join('');\n  }\n  set innerHTML(content) {\n    //const r = parse(content, global.options); // TODO global.options ?\n    const r = parse(content);\n    this.childNodes = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n  }\n  set_content(content, options = {}) {\n    if (content instanceof Node) {\n      content = [content];\n    } else if (typeof content == 'string') {\n      const r = parse(content, options);\n      content = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n    }\n    this.childNodes = content;\n  }\n  replaceWith(...nodes) {\n    const content = nodes.map(node => {\n      if (node instanceof Node) {\n        return [node];\n      } else if (typeof node == 'string') {\n        // const r = parse(content, global.options); // TODO global.options ?\n        const r = parse(node);\n        return r.childNodes.length ? r.childNodes : [new TextNode(node, this)];\n      }\n      return [];\n    }).flat();\n    const idx = this.parentNode.childNodes.findIndex(child => {\n      return child === this;\n    });\n    this.parentNode.childNodes = [...this.parentNode.childNodes.slice(0, idx), ...content, ...this.parentNode.childNodes.slice(idx + 1)];\n  }\n  get outerHTML() {\n    return this.toString();\n  }\n  /**\n   * Trim element from right (in block) after seeing pattern in a TextNode.\n   * @param  {RegExp} pattern pattern to find\n   * @return {HTMLElement}    reference to current node\n   */\n  trimRight(pattern) {\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const childNode = this.childNodes[i];\n      if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n        childNode.trimRight(pattern);\n      } else {\n        const index = childNode.rawText.search(pattern);\n        if (index > -1) {\n          childNode.rawText = childNode.rawText.substr(0, index);\n          // trim all following nodes.\n          this.childNodes.length = i + 1;\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Get DOM structure\n   * @return {string} strucutre\n   */\n  get structure() {\n    const res = [];\n    let indention = 0;\n    function write(str) {\n      res.push('  '.repeat(indention) + str);\n    }\n    function dfs(node) {\n      const idStr = node.id ? `#${node.id}` : '';\n      const classStr = node.classList.length ? `.${node.classList.value.join('.')}` : ''; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\n      write(`${node.rawTagName}${idStr}${classStr}`);\n      indention++;\n      node.childNodes.forEach(childNode => {\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          dfs(childNode);\n        } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n          if (!childNode.isWhitespace) {\n            write('#text');\n          }\n        }\n      });\n      indention--;\n    }\n    dfs(this);\n    return res.join('\\n');\n  }\n  /**\n   * Remove whitespaces in this sub tree.\n   * @return {HTMLElement} pointer to this\n   */\n  removeWhitespace() {\n    let o = 0;\n    this.childNodes.forEach(node => {\n      if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          return;\n        }\n        node.rawText = node.trimmedText;\n      } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n        node.removeWhitespace();\n      }\n      this.childNodes[o++] = node;\n    });\n    this.childNodes.length = o;\n    return this;\n  }\n  /**\n   * Query CSS selector to find matching nodes.\n   * @param  {string}         selector Simplified CSS selector\n   * @return {HTMLElement[]}  matching elements\n   */\n  querySelectorAll(selector) {\n    return selectAll(selector, this, {\n      xmlMode: true,\n      adapter: Matcher\n    });\n    // let matcher: Matcher;\n    // if (selector instanceof Matcher) {\n    // \tmatcher = selector;\n    // \tmatcher.reset();\n    // } else {\n    // \tif (selector.includes(',')) {\n    // \t\tconst selectors = selector.split(',');\n    // \t\treturn Array.from(selectors.reduce((pre, cur) => {\n    // \t\t\tconst result = this.querySelectorAll(cur.trim());\n    // \t\t\treturn result.reduce((p, c) => {\n    // \t\t\t\treturn p.add(c);\n    // \t\t\t}, pre);\n    // \t\t}, new Set<HTMLElement>()));\n    // \t}\n    // \tmatcher = new Matcher(selector);\n    // }\n    // interface IStack {\n    // \t0: Node;\t// node\n    // \t1: number;\t// children\n    // \t2: boolean;\t// found flag\n    // }\n    // const stack = [] as IStack[];\n    // return this.childNodes.reduce((res, cur) => {\n    // \tstack.push([cur, 0, false]);\n    // \twhile (stack.length) {\n    // \t\tconst state = arr_back(stack);\t// get last element\n    // \t\tconst el = state[0];\n    // \t\tif (state[1] === 0) {\n    // \t\t\t// Seen for first time.\n    // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n    // \t\t\t\tstack.pop();\n    // \t\t\t\tcontinue;\n    // \t\t\t}\n    // \t\t\tconst html_el = el as HTMLElement;\n    // \t\t\tstate[2] = matcher.advance(html_el);\n    // \t\t\tif (state[2]) {\n    // \t\t\t\tif (matcher.matched) {\n    // \t\t\t\t\tres.push(html_el);\n    // \t\t\t\t\tres.push(...(html_el.querySelectorAll(selector)));\n    // \t\t\t\t\t// no need to go further.\n    // \t\t\t\t\tmatcher.rewind();\n    // \t\t\t\t\tstack.pop();\n    // \t\t\t\t\tcontinue;\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t}\n    // \t\tif (state[1] < el.childNodes.length) {\n    // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n    // \t\t} else {\n    // \t\t\tif (state[2]) {\n    // \t\t\t\tmatcher.rewind();\n    // \t\t\t}\n    // \t\t\tstack.pop();\n    // \t\t}\n    // \t}\n    // \treturn res;\n    // }, [] as HTMLElement[]);\n  }\n  /**\n   * Query CSS Selector to find matching node.\n   * @param  {string}         selector Simplified CSS selector\n   * @return {HTMLElement}    matching node\n   */\n  querySelector(selector) {\n    return selectOne(selector, this, {\n      xmlMode: true,\n      adapter: Matcher\n    });\n    // let matcher: Matcher;\n    // if (selector instanceof Matcher) {\n    // \tmatcher = selector;\n    // \tmatcher.reset();\n    // } else {\n    // \tmatcher = new Matcher(selector);\n    // }\n    // const stack = [] as { 0: Node; 1: 0 | 1; 2: boolean }[];\n    // for (const node of this.childNodes) {\n    // \tstack.push([node, 0, false]);\n    // \twhile (stack.length) {\n    // \t\tconst state = arr_back(stack);\n    // \t\tconst el = state[0];\n    // \t\tif (state[1] === 0) {\n    // \t\t\t// Seen for first time.\n    // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n    // \t\t\t\tstack.pop();\n    // \t\t\t\tcontinue;\n    // \t\t\t}\n    // \t\t\tstate[2] = matcher.advance(el as HTMLElement);\n    // \t\t\tif (state[2]) {\n    // \t\t\t\tif (matcher.matched) {\n    // \t\t\t\t\treturn el as HTMLElement;\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t}\n    // \t\tif (state[1] < el.childNodes.length) {\n    // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n    // \t\t} else {\n    // \t\t\tif (state[2]) {\n    // \t\t\t\tmatcher.rewind();\n    // \t\t\t}\n    // \t\t\tstack.pop();\n    // \t\t}\n    // \t}\n    // }\n    // return null;\n  }\n  /**\n   * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n   * @param selector a DOMString containing a selector list\n   */\n  closest(selector) {\n    const mapChild = new Map();\n    let el = this;\n    let old = null;\n    function findOne(test, elems) {\n      let elem = null;\n      for (let i = 0, l = elems.length; i < l && !elem; i++) {\n        const el = elems[i];\n        if (test(el)) {\n          elem = el;\n        } else {\n          const child = mapChild.get(el);\n          if (child) {\n            elem = findOne(test, [child]);\n          }\n        }\n      }\n      return elem;\n    }\n    while (el) {\n      mapChild.set(el, old);\n      old = el;\n      el = el.parentNode;\n    }\n    el = this;\n    while (el) {\n      const e = selectOne(selector, el, {\n        xmlMode: true,\n        adapter: {\n          ...Matcher,\n          getChildren(node) {\n            const child = mapChild.get(node);\n            return child && [child];\n          },\n          getSiblings(node) {\n            return [node];\n          },\n          findOne,\n          findAll() {\n            return [];\n          }\n        }\n      });\n      if (e) {\n        return e;\n      }\n      el = el.parentNode;\n    }\n    return null;\n  }\n  /**\n   * Append a child node to childNodes\n   * @param  {Node} node node to append\n   * @return {Node}      node appended\n   */\n  appendChild(node) {\n    // node.parentNode = this;\n    this.childNodes.push(node);\n    node.parentNode = this;\n    return node;\n  }\n  /**\n   * Get first child node\n   * @return {Node} first child node\n   */\n  get firstChild() {\n    return this.childNodes[0];\n  }\n  /**\n   * Get last child node\n   * @return {Node} last child node\n   */\n  get lastChild() {\n    return arr_back(this.childNodes);\n  }\n  /**\n   * Get attributes\n   * @access private\n   * @return {Object} parsed and unescaped attributes\n   */\n  get attrs() {\n    if (this._attrs) {\n      return this._attrs;\n    }\n    this._attrs = {};\n    const attrs = this.rawAttributes;\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      this._attrs[key.toLowerCase()] = decode(val);\n    }\n    return this._attrs;\n  }\n  get attributes() {\n    const ret_attrs = {};\n    const attrs = this.rawAttributes;\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      ret_attrs[key] = decode(val);\n    }\n    return ret_attrs;\n  }\n  /**\n   * Get escaped (as-it) attributes\n   * @return {Object} parsed attributes\n   */\n  get rawAttributes() {\n    if (this._rawAttrs) {\n      return this._rawAttrs;\n    }\n    const attrs = {};\n    if (this.rawAttrs) {\n      const re = /\\b([a-z][a-z0-9-_:]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n      let match;\n      while (match = re.exec(this.rawAttrs)) {\n        attrs[match[1]] = match[2] || match[3] || match[4] || null;\n      }\n    }\n    this._rawAttrs = attrs;\n    return attrs;\n  }\n  removeAttribute(key) {\n    const attrs = this.rawAttributes;\n    delete attrs[key];\n    // Update this.attribute\n    if (this._attrs) {\n      delete this._attrs[key];\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = JSON.stringify(attrs[name]);\n      if (val === undefined || val === 'null') {\n        return name;\n      }\n      return `${name}=${val}`;\n    }).join(' ');\n    // Update this.id\n    if (key === 'id') {\n      this.id = '';\n    }\n  }\n  hasAttribute(key) {\n    return key.toLowerCase() in this.attrs;\n  }\n  /**\n   * Get an attribute\n   * @return {string} value of the attribute\n   */\n  getAttribute(key) {\n    return this.attrs[key.toLowerCase()];\n  }\n  /**\n   * Set an attribute value to the HTMLElement\n   * @param {string} key The attribute name\n   * @param {string} value The value to set, or null / undefined to remove an attribute\n   */\n  setAttribute(key, value) {\n    if (arguments.length < 2) {\n      throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n    }\n    const k2 = key.toLowerCase();\n    const attrs = this.rawAttributes;\n    for (const k in attrs) {\n      if (k.toLowerCase() === k2) {\n        key = k;\n        break;\n      }\n    }\n    attrs[key] = String(value);\n    // update this.attrs\n    if (this._attrs) {\n      this._attrs[k2] = decode(attrs[key]);\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = this.quoteAttribute(attrs[name]);\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n      return `${name}=${val}`;\n    }).join(' ');\n    // Update this.id\n    if (key === 'id') {\n      this.id = value;\n    }\n  }\n  /**\n   * Replace all the attributes of the HTMLElement by the provided attributes\n   * @param {Attributes} attributes the new attribute set\n   */\n  setAttributes(attributes) {\n    // Invalidate current this.attributes\n    if (this._attrs) {\n      delete this._attrs;\n    }\n    // Invalidate current this.rawAttributes\n    if (this._rawAttrs) {\n      delete this._rawAttrs;\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attributes).map(name => {\n      const val = attributes[name];\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n      return `${name}=${this.quoteAttribute(String(val))}`;\n    }).join(' ');\n  }\n  insertAdjacentHTML(where, html) {\n    if (arguments.length < 2) {\n      throw new Error('2 arguments required');\n    }\n    const p = parse(html);\n    if (where === 'afterend') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else if (where === 'afterbegin') {\n      this.childNodes.unshift(...p.childNodes);\n    } else if (where === 'beforeend') {\n      p.childNodes.forEach(n => {\n        this.appendChild(n);\n      });\n    } else if (where === 'beforebegin') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else {\n      throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n    }\n    // if (!where || html === undefined || html === null) {\n    // \treturn;\n    // }\n  }\n  get nextSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      while (i < children.length) {\n        const child = children[i++];\n        if (this === child) {\n          return children[i] || null;\n        }\n      }\n      return null;\n    }\n  }\n  get nextElementSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      let find = false;\n      while (i < children.length) {\n        const child = children[i++];\n        if (find) {\n          if (child instanceof HTMLElement) {\n            return child || null;\n          }\n        } else if (this === child) {\n          find = true;\n        }\n      }\n      return null;\n    }\n  }\n  get classNames() {\n    return this.classList.toString();\n  }\n}\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]*)\"|'([^']*)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n  area: true,\n  AREA: true,\n  base: true,\n  BASE: true,\n  br: true,\n  BR: true,\n  col: true,\n  COL: true,\n  hr: true,\n  HR: true,\n  img: true,\n  IMG: true,\n  input: true,\n  INPUT: true,\n  link: true,\n  LINK: true,\n  meta: true,\n  META: true,\n  source: true,\n  SOURCE: true,\n  embed: true,\n  EMBED: true,\n  param: true,\n  PARAM: true,\n  track: true,\n  TRACK: true,\n  wbr: true,\n  WBR: true\n};\nconst kElementsClosedByOpening = {\n  li: {\n    li: true,\n    LI: true\n  },\n  LI: {\n    li: true,\n    LI: true\n  },\n  p: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  P: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TD: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  th: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TH: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  h1: {\n    h1: true,\n    H1: true\n  },\n  H1: {\n    h1: true,\n    H1: true\n  },\n  h2: {\n    h2: true,\n    H2: true\n  },\n  H2: {\n    h2: true,\n    H2: true\n  },\n  h3: {\n    h3: true,\n    H3: true\n  },\n  H3: {\n    h3: true,\n    H3: true\n  },\n  h4: {\n    h4: true,\n    H4: true\n  },\n  H4: {\n    h4: true,\n    H4: true\n  },\n  h5: {\n    h5: true,\n    H5: true\n  },\n  H5: {\n    h5: true,\n    H5: true\n  },\n  h6: {\n    h6: true,\n    H6: true\n  },\n  H6: {\n    h6: true,\n    H6: true\n  }\n};\nconst kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  LI: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  a: {\n    div: true,\n    DIV: true\n  },\n  A: {\n    div: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  i: {\n    div: true,\n    DIV: true\n  },\n  I: {\n    div: true,\n    DIV: true\n  },\n  p: {\n    div: true,\n    DIV: true\n  },\n  P: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TD: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  th: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TH: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  }\n};\nconst frameflag = 'documentfragmentcontainer';\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\nexport function base_parse(data, options = {\n  lowerCaseTagName: false,\n  comment: false\n}) {\n  const elements = options.blockTextElements || {\n    script: true,\n    noscript: true,\n    style: true,\n    pre: true\n  };\n  const element_names = Object.keys(elements);\n  const kBlockTextElements = element_names.map(it => {\n    return new RegExp(it, 'i');\n  });\n  const kIgnoreElements = element_names.filter(it => {\n    return elements[it];\n  }).map(it => {\n    return new RegExp(it, 'i');\n  });\n  function element_should_be_ignore(tag) {\n    return kIgnoreElements.some(it => {\n      return it.test(tag);\n    });\n  }\n  function is_block_text_element(tag) {\n    return kBlockTextElements.some(it => {\n      return it.test(tag);\n    });\n  }\n  const root = new HTMLElement(null, {}, '', null);\n  let currentParent = root;\n  const stack = [root];\n  let lastTextPos = -1;\n  let match;\n  // https://github.com/taoqf/node-html-parser/issues/38\n  data = `<${frameflag}>${data}</${frameflag}>`;\n  while (match = kMarkupPattern.exec(data)) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text, currentParent));\n      }\n    }\n    lastTextPos = kMarkupPattern.lastIndex;\n    if (match[2] === frameflag) {\n      continue;\n    }\n    if (match[0][1] === '!') {\n      // this is a comment\n      if (options.comment) {\n        // Only keep what is in between <!-- and -->\n        const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n        currentParent.appendChild(new CommentNode(text, currentParent));\n      }\n      continue;\n    }\n    if (options.lowerCaseTagName) {\n      match[2] = match[2].toLowerCase();\n    }\n    if (!match[1]) {\n      // not </ tags\n      const attrs = {};\n      for (let attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n      const tagName = currentParent.rawTagName;\n      if (!match[4] && kElementsClosedByOpening[tagName]) {\n        if (kElementsClosedByOpening[tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      }\n      // ignore container tag we add above\n      // https://github.com/taoqf/node-html-parser/issues/38\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3], null));\n      stack.push(currentParent);\n      if (is_block_text_element(match[2])) {\n        // a little test to find next </script> or </style> ...\n        const closeMarkup = `</${match[2]}>`;\n        const index = (() => {\n          if (options.lowerCaseTagName) {\n            return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n          }\n          return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n        })();\n        if (element_should_be_ignore(match[2])) {\n          let text;\n          if (index === -1) {\n            // there is no matching ending for the text element.\n            text = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            text = data.substring(kMarkupPattern.lastIndex, index);\n          }\n          if (text.length > 0) {\n            currentParent.appendChild(new TextNode(text, currentParent));\n          }\n        }\n        if (index === -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.rawTagName === match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          const tagName = currentParent.tagName;\n          // Trying to close current tag, and move on\n          if (kElementsClosedByClosing[tagName]) {\n            if (kElementsClosedByClosing[tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          }\n          // Use aggressive strategy to handle unmatching markups.\n          break;\n        }\n      }\n    }\n  }\n  return stack;\n}\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */\nexport function parse(data, options = {\n  lowerCaseTagName: false,\n  comment: false\n}) {\n  const stack = base_parse(data, options);\n  const [root] = stack;\n  while (stack.length > 1) {\n    // Handle each error elements.\n    const last = stack.pop();\n    const oneBefore = arr_back(stack);\n    if (last.parentNode && last.parentNode.parentNode) {\n      if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n        // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n        oneBefore.removeChild(last);\n        last.childNodes.forEach(child => {\n          oneBefore.parentNode.appendChild(child);\n        });\n        stack.pop();\n      } else {\n        // Single error  <div> <h3> </div> handle: Just removes <h3>\n        oneBefore.removeChild(last);\n        last.childNodes.forEach(child => {\n          oneBefore.appendChild(child);\n        });\n      }\n    } else {\n      // If it's final element just skip.\n    }\n  }\n  // response.childNodes.forEach((node) => {\n  // \tif (node instanceof HTMLElement) {\n  // \t\tnode.parentNode = null;\n  // \t}\n  // });\n  return root;\n}","map":{"version":3,"names":["he","selectAll","selectOne","Node","NodeType","TextNode","Matcher","arr_back","CommentNode","decode","val","JSON","parse","stringify","kBlockElements","Set","add","DOMTokenList","constructor","valuesInit","afterUpdate","_set","_afterUpdate","_validate","c","test","Error","replace","c1","c2","delete","remove","toggle","has","contains","length","size","values","value","Array","from","toString","join","HTMLElement","tagName","keyAttrs","rawAttrs","parentNode","nodeType","ELEMENT_NODE","rawTagName","id","childNodes","classList","class","split","setAttribute","cls","quoteAttribute","attr","children","filter","child","removeChild","node","exchangeChild","oldNode","newNode","map","toUpperCase","localName","toLowerCase","rawText","reduce","pre","cur","textContent","content","text","structuredText","currentBlock","blocks","dfs","push","forEach","TEXT_NODE","isWhitespace","prependWhitespace","trimmedText","block","tag","is_void","attrs","innerHTML","r","set_content","options","replaceWith","nodes","flat","idx","findIndex","slice","outerHTML","trimRight","pattern","i","childNode","index","search","substr","structure","res","indention","write","str","repeat","idStr","classStr","removeWhitespace","o","querySelectorAll","selector","xmlMode","adapter","querySelector","closest","mapChild","Map","el","old","findOne","elems","elem","l","get","set","e","getChildren","getSiblings","findAll","appendChild","firstChild","lastChild","_attrs","rawAttributes","key","attributes","ret_attrs","_rawAttrs","re","match","exec","removeAttribute","Object","keys","name","undefined","hasAttribute","getAttribute","arguments","k2","k","String","setAttributes","insertAdjacentHTML","where","html","p","splice","n","unshift","nextSibling","nextElementSibling","find","classNames","kMarkupPattern","kAttributePattern","kSelfClosingElements","area","AREA","base","BASE","br","BR","col","COL","hr","HR","img","IMG","input","INPUT","link","LINK","meta","META","source","SOURCE","embed","EMBED","param","PARAM","track","TRACK","wbr","WBR","kElementsClosedByOpening","li","LI","div","P","DIV","b","B","td","th","TD","TH","h1","H1","h2","H2","h3","H3","h4","H4","h5","H5","h6","H6","kElementsClosedByClosing","ul","ol","UL","OL","a","A","I","tr","table","TR","TABLE","frameflag","base_parse","data","lowerCaseTagName","comment","elements","blockTextElements","script","noscript","style","element_names","kBlockTextElements","it","RegExp","kIgnoreElements","element_should_be_ignore","some","is_block_text_element","root","currentParent","stack","lastTextPos","lastIndex","substring","attMatch","pop","closeMarkup","toLocaleLowerCase","indexOf","last","oneBefore"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/node-html-parser/dist/esm/nodes/html.js"],"sourcesContent":["import he from 'he';\nimport { selectAll, selectOne } from 'css-select';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\n// const { decode } = he;\nfunction decode(val) {\n    // clone string\n    return JSON.parse(JSON.stringify(he.decode(val)));\n}\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst kBlockElements = new Set();\nkBlockElements.add('address');\nkBlockElements.add('ADDRESS');\nkBlockElements.add('article');\nkBlockElements.add('ARTICLE');\nkBlockElements.add('aside');\nkBlockElements.add('ASIDE');\nkBlockElements.add('blockquote');\nkBlockElements.add('BLOCKQUOTE');\nkBlockElements.add('br');\nkBlockElements.add('BR');\nkBlockElements.add('details');\nkBlockElements.add('DETAILS');\nkBlockElements.add('dialog');\nkBlockElements.add('DIALOG');\nkBlockElements.add('dd');\nkBlockElements.add('DD');\nkBlockElements.add('div');\nkBlockElements.add('DIV');\nkBlockElements.add('dl');\nkBlockElements.add('DL');\nkBlockElements.add('dt');\nkBlockElements.add('DT');\nkBlockElements.add('fieldset');\nkBlockElements.add('FIELDSET');\nkBlockElements.add('figcaption');\nkBlockElements.add('FIGCAPTION');\nkBlockElements.add('figure');\nkBlockElements.add('FIGURE');\nkBlockElements.add('footer');\nkBlockElements.add('FOOTER');\nkBlockElements.add('form');\nkBlockElements.add('FORM');\nkBlockElements.add('h1');\nkBlockElements.add('H1');\nkBlockElements.add('h2');\nkBlockElements.add('H2');\nkBlockElements.add('h3');\nkBlockElements.add('H3');\nkBlockElements.add('h4');\nkBlockElements.add('H4');\nkBlockElements.add('h5');\nkBlockElements.add('H5');\nkBlockElements.add('h6');\nkBlockElements.add('H6');\nkBlockElements.add('header');\nkBlockElements.add('HEADER');\nkBlockElements.add('hgroup');\nkBlockElements.add('HGROUP');\nkBlockElements.add('hr');\nkBlockElements.add('HR');\nkBlockElements.add('li');\nkBlockElements.add('LI');\nkBlockElements.add('main');\nkBlockElements.add('MAIN');\nkBlockElements.add('nav');\nkBlockElements.add('NAV');\nkBlockElements.add('ol');\nkBlockElements.add('OL');\nkBlockElements.add('p');\nkBlockElements.add('P');\nkBlockElements.add('pre');\nkBlockElements.add('PRE');\nkBlockElements.add('section');\nkBlockElements.add('SECTION');\nkBlockElements.add('table');\nkBlockElements.add('TABLE');\nkBlockElements.add('td');\nkBlockElements.add('TD');\nkBlockElements.add('tr');\nkBlockElements.add('TR');\nkBlockElements.add('ul');\nkBlockElements.add('UL');\nclass DOMTokenList {\n    constructor(valuesInit = [], afterUpdate = (() => null)) {\n        this._set = new Set(valuesInit);\n        this._afterUpdate = afterUpdate;\n    }\n    _validate(c) {\n        if (/\\s/.test(c)) {\n            throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);\n        }\n    }\n    add(c) {\n        this._validate(c);\n        this._set.add(c);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    replace(c1, c2) {\n        this._validate(c2);\n        this._set.delete(c1);\n        this._set.add(c2);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    remove(c) {\n        this._set.delete(c) &&\n            this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    toggle(c) {\n        this._validate(c);\n        if (this._set.has(c))\n            this._set.delete(c);\n        else\n            this._set.add(c);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    contains(c) {\n        return this._set.has(c);\n    }\n    get length() {\n        return this._set.size;\n    }\n    values() {\n        return this._set.values();\n    }\n    get value() {\n        return Array.from(this._set.values());\n    }\n    toString() {\n        return Array.from(this._set.values()).join(' ');\n    }\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nexport default class HTMLElement extends Node {\n    /**\n     * Creates an instance of HTMLElement.\n     * @param keyAttrs\tid and class attribute\n     * @param [rawAttrs]\tattributes in string\n     *\n     * @memberof HTMLElement\n     */\n    constructor(tagName, keyAttrs, rawAttrs = '', parentNode) {\n        super(parentNode);\n        this.rawAttrs = rawAttrs;\n        /**\n         * Node Type declaration.\n         */\n        this.nodeType = NodeType.ELEMENT_NODE;\n        this.rawTagName = tagName;\n        this.rawAttrs = rawAttrs || '';\n        this.id = keyAttrs.id || '';\n        this.childNodes = [];\n        this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], (classList) => (this.setAttribute('class', classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        ));\n        if (keyAttrs.id) {\n            if (!rawAttrs) {\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n            }\n        }\n        if (keyAttrs.class) {\n            if (!rawAttrs) {\n                const cls = `class=\"${this.classList.toString()}\"`;\n                if (this.rawAttrs) {\n                    this.rawAttrs += ` ${cls}`;\n                }\n                else {\n                    this.rawAttrs = cls;\n                }\n            }\n        }\n    }\n    /**\n     * Quote attribute values\n     * @param attr attribute value\n     * @returns {string} quoted value\n     */\n    quoteAttribute(attr) {\n        if (attr === null) {\n            return \"null\";\n        }\n        return JSON.stringify(attr.replace(/\"/g, '&quot;'));\n    }\n    /**\n     * Remove current element\n     */\n    remove() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            this.parentNode.childNodes = children.filter((child) => {\n                return this !== child;\n            });\n        }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n    removeChild(node) {\n        this.childNodes = this.childNodes.filter((child) => {\n            return (child !== node);\n        });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n    exchangeChild(oldNode, newNode) {\n        const children = this.childNodes;\n        this.childNodes = children.map((child) => {\n            if (child === oldNode) {\n                return newNode;\n            }\n            return child;\n        });\n    }\n    get tagName() {\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    get localName() {\n        return this.rawTagName.toLowerCase();\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n    get rawText() {\n        return this.childNodes.reduce((pre, cur) => {\n            return (pre += cur.rawText);\n        }, '');\n    }\n    get textContent() {\n        return this.rawText;\n    }\n    set textContent(val) {\n        const content = [new TextNode(val, this)];\n        this.childNodes = content;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n    get structuredText() {\n        let currentBlock = [];\n        const blocks = [currentBlock];\n        function dfs(node) {\n            if (node.nodeType === NodeType.ELEMENT_NODE) {\n                if (kBlockElements.has(node.rawTagName)) {\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                    node.childNodes.forEach(dfs);\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                }\n                else {\n                    node.childNodes.forEach(dfs);\n                }\n            }\n            else if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    // Whitespace node, postponed output\n                    currentBlock.prependWhitespace = true;\n                }\n                else {\n                    let text = node.trimmedText;\n                    if (currentBlock.prependWhitespace) {\n                        text = ` ${text}`;\n                        currentBlock.prependWhitespace = false;\n                    }\n                    currentBlock.push(text);\n                }\n            }\n        }\n        dfs(this);\n        return blocks.map((block) => {\n            // Normalize each line's whitespace\n            return block.join('').replace(/\\s{2,}/g, ' ');\n        })\n            .join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n    toString() {\n        const tag = this.rawTagName;\n        if (tag) {\n            // const void_tags = new Set('area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr'.split('|'));\n            // const is_void = void_tags.has(tag);\n            const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n            if (is_void) {\n                return `<${tag}${attrs}>`;\n            }\n            return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n        }\n        return this.innerHTML;\n    }\n    get innerHTML() {\n        return this.childNodes.map((child) => {\n            return child.toString();\n        }).join('');\n    }\n    set innerHTML(content) {\n        //const r = parse(content, global.options); // TODO global.options ?\n        const r = parse(content);\n        this.childNodes = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n    }\n    set_content(content, options = {}) {\n        if (content instanceof Node) {\n            content = [content];\n        }\n        else if (typeof content == 'string') {\n            const r = parse(content, options);\n            content = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n        }\n        this.childNodes = content;\n    }\n    replaceWith(...nodes) {\n        const content = nodes.map((node) => {\n            if (node instanceof Node) {\n                return [node];\n            }\n            else if (typeof node == 'string') {\n                // const r = parse(content, global.options); // TODO global.options ?\n                const r = parse(node);\n                return r.childNodes.length ? r.childNodes : [new TextNode(node, this)];\n            }\n            return [];\n        }).flat();\n        const idx = this.parentNode.childNodes.findIndex((child) => {\n            return child === this;\n        });\n        this.parentNode.childNodes = [\n            ...this.parentNode.childNodes.slice(0, idx),\n            ...content,\n            ...this.parentNode.childNodes.slice(idx + 1),\n        ];\n    }\n    get outerHTML() {\n        return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    trimRight(pattern) {\n        for (let i = 0; i < this.childNodes.length; i++) {\n            const childNode = this.childNodes[i];\n            if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                childNode.trimRight(pattern);\n            }\n            else {\n                const index = childNode.rawText.search(pattern);\n                if (index > -1) {\n                    childNode.rawText = childNode.rawText.substr(0, index);\n                    // trim all following nodes.\n                    this.childNodes.length = i + 1;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n    get structure() {\n        const res = [];\n        let indention = 0;\n        function write(str) {\n            res.push('  '.repeat(indention) + str);\n        }\n        function dfs(node) {\n            const idStr = node.id ? (`#${node.id}`) : '';\n            const classStr = node.classList.length ? (`.${node.classList.value.join('.')}`) : ''; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\n            write(`${node.rawTagName}${idStr}${classStr}`);\n            indention++;\n            node.childNodes.forEach((childNode) => {\n                if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                    dfs(childNode);\n                }\n                else if (childNode.nodeType === NodeType.TEXT_NODE) {\n                    if (!childNode.isWhitespace) {\n                        write('#text');\n                    }\n                }\n            });\n            indention--;\n        }\n        dfs(this);\n        return res.join('\\n');\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    removeWhitespace() {\n        let o = 0;\n        this.childNodes.forEach((node) => {\n            if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    return;\n                }\n                node.rawText = node.trimmedText;\n            }\n            else if (node.nodeType === NodeType.ELEMENT_NODE) {\n                node.removeWhitespace();\n            }\n            this.childNodes[o++] = node;\n        });\n        this.childNodes.length = o;\n        return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {HTMLElement[]}  matching elements\n     */\n    querySelectorAll(selector) {\n        return selectAll(selector, this, {\n            xmlMode: true,\n            adapter: Matcher\n        });\n        // let matcher: Matcher;\n        // if (selector instanceof Matcher) {\n        // \tmatcher = selector;\n        // \tmatcher.reset();\n        // } else {\n        // \tif (selector.includes(',')) {\n        // \t\tconst selectors = selector.split(',');\n        // \t\treturn Array.from(selectors.reduce((pre, cur) => {\n        // \t\t\tconst result = this.querySelectorAll(cur.trim());\n        // \t\t\treturn result.reduce((p, c) => {\n        // \t\t\t\treturn p.add(c);\n        // \t\t\t}, pre);\n        // \t\t}, new Set<HTMLElement>()));\n        // \t}\n        // \tmatcher = new Matcher(selector);\n        // }\n        // interface IStack {\n        // \t0: Node;\t// node\n        // \t1: number;\t// children\n        // \t2: boolean;\t// found flag\n        // }\n        // const stack = [] as IStack[];\n        // return this.childNodes.reduce((res, cur) => {\n        // \tstack.push([cur, 0, false]);\n        // \twhile (stack.length) {\n        // \t\tconst state = arr_back(stack);\t// get last element\n        // \t\tconst el = state[0];\n        // \t\tif (state[1] === 0) {\n        // \t\t\t// Seen for first time.\n        // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n        // \t\t\t\tstack.pop();\n        // \t\t\t\tcontinue;\n        // \t\t\t}\n        // \t\t\tconst html_el = el as HTMLElement;\n        // \t\t\tstate[2] = matcher.advance(html_el);\n        // \t\t\tif (state[2]) {\n        // \t\t\t\tif (matcher.matched) {\n        // \t\t\t\t\tres.push(html_el);\n        // \t\t\t\t\tres.push(...(html_el.querySelectorAll(selector)));\n        // \t\t\t\t\t// no need to go further.\n        // \t\t\t\t\tmatcher.rewind();\n        // \t\t\t\t\tstack.pop();\n        // \t\t\t\t\tcontinue;\n        // \t\t\t\t}\n        // \t\t\t}\n        // \t\t}\n        // \t\tif (state[1] < el.childNodes.length) {\n        // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n        // \t\t} else {\n        // \t\t\tif (state[2]) {\n        // \t\t\t\tmatcher.rewind();\n        // \t\t\t}\n        // \t\t\tstack.pop();\n        // \t\t}\n        // \t}\n        // \treturn res;\n        // }, [] as HTMLElement[]);\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {HTMLElement}    matching node\n     */\n    querySelector(selector) {\n        return selectOne(selector, this, {\n            xmlMode: true,\n            adapter: Matcher\n        });\n        // let matcher: Matcher;\n        // if (selector instanceof Matcher) {\n        // \tmatcher = selector;\n        // \tmatcher.reset();\n        // } else {\n        // \tmatcher = new Matcher(selector);\n        // }\n        // const stack = [] as { 0: Node; 1: 0 | 1; 2: boolean }[];\n        // for (const node of this.childNodes) {\n        // \tstack.push([node, 0, false]);\n        // \twhile (stack.length) {\n        // \t\tconst state = arr_back(stack);\n        // \t\tconst el = state[0];\n        // \t\tif (state[1] === 0) {\n        // \t\t\t// Seen for first time.\n        // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n        // \t\t\t\tstack.pop();\n        // \t\t\t\tcontinue;\n        // \t\t\t}\n        // \t\t\tstate[2] = matcher.advance(el as HTMLElement);\n        // \t\t\tif (state[2]) {\n        // \t\t\t\tif (matcher.matched) {\n        // \t\t\t\t\treturn el as HTMLElement;\n        // \t\t\t\t}\n        // \t\t\t}\n        // \t\t}\n        // \t\tif (state[1] < el.childNodes.length) {\n        // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n        // \t\t} else {\n        // \t\t\tif (state[2]) {\n        // \t\t\t\tmatcher.rewind();\n        // \t\t\t}\n        // \t\t\tstack.pop();\n        // \t\t}\n        // \t}\n        // }\n        // return null;\n    }\n    /**\n     * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n     * @param selector a DOMString containing a selector list\n     */\n    closest(selector) {\n        const mapChild = new Map();\n        let el = this;\n        let old = null;\n        function findOne(test, elems) {\n            let elem = null;\n            for (let i = 0, l = elems.length; i < l && !elem; i++) {\n                const el = elems[i];\n                if (test(el)) {\n                    elem = el;\n                }\n                else {\n                    const child = mapChild.get(el);\n                    if (child) {\n                        elem = findOne(test, [child]);\n                    }\n                }\n            }\n            return elem;\n        }\n        while (el) {\n            mapChild.set(el, old);\n            old = el;\n            el = el.parentNode;\n        }\n        el = this;\n        while (el) {\n            const e = selectOne(selector, el, {\n                xmlMode: true,\n                adapter: {\n                    ...Matcher,\n                    getChildren(node) {\n                        const child = mapChild.get(node);\n                        return child && [child];\n                    },\n                    getSiblings(node) {\n                        return [node];\n                    },\n                    findOne,\n                    findAll() {\n                        return [];\n                    }\n                }\n            });\n            if (e) {\n                return e;\n            }\n            el = el.parentNode;\n        }\n        return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n    appendChild(node) {\n        // node.parentNode = this;\n        this.childNodes.push(node);\n        node.parentNode = this;\n        return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n    get firstChild() {\n        return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n    get lastChild() {\n        return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @access private\n     * @return {Object} parsed and unescaped attributes\n     */\n    get attrs() {\n        if (this._attrs) {\n            return this._attrs;\n        }\n        this._attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            this._attrs[key.toLowerCase()] = decode(val);\n        }\n        return this._attrs;\n    }\n    get attributes() {\n        const ret_attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            ret_attrs[key] = decode(val);\n        }\n        return ret_attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n    get rawAttributes() {\n        if (this._rawAttrs) {\n            return this._rawAttrs;\n        }\n        const attrs = {};\n        if (this.rawAttrs) {\n            const re = /\\b([a-z][a-z0-9-_:]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n            let match;\n            while ((match = re.exec(this.rawAttrs))) {\n                attrs[match[1]] = match[2] || match[3] || match[4] || null;\n            }\n        }\n        this._rawAttrs = attrs;\n        return attrs;\n    }\n    removeAttribute(key) {\n        const attrs = this.rawAttributes;\n        delete attrs[key];\n        // Update this.attribute\n        if (this._attrs) {\n            delete this._attrs[key];\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === undefined || val === 'null') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n        // Update this.id\n        if (key === 'id') {\n            this.id = '';\n        }\n    }\n    hasAttribute(key) {\n        return key.toLowerCase() in this.attrs;\n    }\n    /**\n     * Get an attribute\n     * @return {string} value of the attribute\n     */\n    getAttribute(key) {\n        return this.attrs[key.toLowerCase()];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n    setAttribute(key, value) {\n        if (arguments.length < 2) {\n            throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n        }\n        const k2 = key.toLowerCase();\n        const attrs = this.rawAttributes;\n        for (const k in attrs) {\n            if (k.toLowerCase() === k2) {\n                key = k;\n                break;\n            }\n        }\n        attrs[key] = String(value);\n        // update this.attrs\n        if (this._attrs) {\n            this._attrs[k2] = decode(attrs[key]);\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = this.quoteAttribute(attrs[name]);\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n        // Update this.id\n        if (key === 'id') {\n            this.id = value;\n        }\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n    setAttributes(attributes) {\n        // Invalidate current this.attributes\n        if (this._attrs) {\n            delete this._attrs;\n        }\n        // Invalidate current this.rawAttributes\n        if (this._rawAttrs) {\n            delete this._rawAttrs;\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attributes).map((name) => {\n            const val = attributes[name];\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${this.quoteAttribute(String(val))}`;\n        }).join(' ');\n    }\n    insertAdjacentHTML(where, html) {\n        if (arguments.length < 2) {\n            throw new Error('2 arguments required');\n        }\n        const p = parse(html);\n        if (where === 'afterend') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else if (where === 'afterbegin') {\n            this.childNodes.unshift(...p.childNodes);\n        }\n        else if (where === 'beforeend') {\n            p.childNodes.forEach((n) => {\n                this.appendChild(n);\n            });\n        }\n        else if (where === 'beforebegin') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else {\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n        }\n        // if (!where || html === undefined || html === null) {\n        // \treturn;\n        // }\n    }\n    get nextSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            while (i < children.length) {\n                const child = children[i++];\n                if (this === child) {\n                    return children[i] || null;\n                }\n            }\n            return null;\n        }\n    }\n    get nextElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            let find = false;\n            while (i < children.length) {\n                const child = children[i++];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                }\n                else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n    get classNames() {\n        return this.classList.toString();\n    }\n}\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]*)\"|'([^']*)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n    area: true,\n    AREA: true,\n    base: true,\n    BASE: true,\n    br: true,\n    BR: true,\n    col: true,\n    COL: true,\n    hr: true,\n    HR: true,\n    img: true,\n    IMG: true,\n    input: true,\n    INPUT: true,\n    link: true,\n    LINK: true,\n    meta: true,\n    META: true,\n    source: true,\n    SOURCE: true,\n    embed: true,\n    EMBED: true,\n    param: true,\n    PARAM: true,\n    track: true,\n    TRACK: true,\n    wbr: true,\n    WBR: true\n};\nconst kElementsClosedByOpening = {\n    li: { li: true, LI: true },\n    LI: { li: true, LI: true },\n    p: { p: true, div: true, P: true, DIV: true },\n    P: { p: true, div: true, P: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    td: { td: true, th: true, TD: true, TH: true },\n    TD: { td: true, th: true, TD: true, TH: true },\n    th: { td: true, th: true, TD: true, TH: true },\n    TH: { td: true, th: true, TD: true, TH: true },\n    h1: { h1: true, H1: true },\n    H1: { h1: true, H1: true },\n    h2: { h2: true, H2: true },\n    H2: { h2: true, H2: true },\n    h3: { h3: true, H3: true },\n    H3: { h3: true, H3: true },\n    h4: { h4: true, H4: true },\n    H4: { h4: true, H4: true },\n    h5: { h5: true, H5: true },\n    H5: { h5: true, H5: true },\n    h6: { h6: true, H6: true },\n    H6: { h6: true, H6: true }\n};\nconst kElementsClosedByClosing = {\n    li: { ul: true, ol: true, UL: true, OL: true },\n    LI: { ul: true, ol: true, UL: true, OL: true },\n    a: { div: true, DIV: true },\n    A: { div: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    i: { div: true, DIV: true },\n    I: { div: true, DIV: true },\n    p: { div: true, DIV: true },\n    P: { div: true, DIV: true },\n    td: { tr: true, table: true, TR: true, TABLE: true },\n    TD: { tr: true, table: true, TR: true, TABLE: true },\n    th: { tr: true, table: true, TR: true, TABLE: true },\n    TH: { tr: true, table: true, TR: true, TABLE: true }\n};\nconst frameflag = 'documentfragmentcontainer';\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\nexport function base_parse(data, options = { lowerCaseTagName: false, comment: false }) {\n    const elements = options.blockTextElements || {\n        script: true,\n        noscript: true,\n        style: true,\n        pre: true\n    };\n    const element_names = Object.keys(elements);\n    const kBlockTextElements = element_names.map((it) => {\n        return new RegExp(it, 'i');\n    });\n    const kIgnoreElements = element_names.filter((it) => {\n        return elements[it];\n    }).map((it) => {\n        return new RegExp(it, 'i');\n    });\n    function element_should_be_ignore(tag) {\n        return kIgnoreElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    function is_block_text_element(tag) {\n        return kBlockTextElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    const root = new HTMLElement(null, {}, '', null);\n    let currentParent = root;\n    const stack = [root];\n    let lastTextPos = -1;\n    let match;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    data = `<${frameflag}>${data}</${frameflag}>`;\n    while ((match = kMarkupPattern.exec(data))) {\n        if (lastTextPos > -1) {\n            if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n                // if has content\n                const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n                currentParent.appendChild(new TextNode(text, currentParent));\n            }\n        }\n        lastTextPos = kMarkupPattern.lastIndex;\n        if (match[2] === frameflag) {\n            continue;\n        }\n        if (match[0][1] === '!') {\n            // this is a comment\n            if (options.comment) {\n                // Only keep what is in between <!-- and -->\n                const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n                currentParent.appendChild(new CommentNode(text, currentParent));\n            }\n            continue;\n        }\n        if (options.lowerCaseTagName) {\n            match[2] = match[2].toLowerCase();\n        }\n        if (!match[1]) {\n            // not </ tags\n            const attrs = {};\n            for (let attMatch; (attMatch = kAttributePattern.exec(match[3]));) {\n                attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n            }\n            const tagName = currentParent.rawTagName;\n            if (!match[4] && kElementsClosedByOpening[tagName]) {\n                if (kElementsClosedByOpening[tagName][match[2]]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                }\n            }\n            // ignore container tag we add above\n            // https://github.com/taoqf/node-html-parser/issues/38\n            currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3], null));\n            stack.push(currentParent);\n            if (is_block_text_element(match[2])) {\n                // a little test to find next </script> or </style> ...\n                const closeMarkup = `</${match[2]}>`;\n                const index = (() => {\n                    if (options.lowerCaseTagName) {\n                        return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                    }\n                    return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                })();\n                if (element_should_be_ignore(match[2])) {\n                    let text;\n                    if (index === -1) {\n                        // there is no matching ending for the text element.\n                        text = data.substr(kMarkupPattern.lastIndex);\n                    }\n                    else {\n                        text = data.substring(kMarkupPattern.lastIndex, index);\n                    }\n                    if (text.length > 0) {\n                        currentParent.appendChild(new TextNode(text, currentParent));\n                    }\n                }\n                if (index === -1) {\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n                }\n                else {\n                    lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n                    match[1] = 'true';\n                }\n            }\n        }\n        if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n            // </ or /> or <br> etc.\n            while (true) {\n                if (currentParent.rawTagName === match[2]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                    break;\n                }\n                else {\n                    const tagName = currentParent.tagName;\n                    // Trying to close current tag, and move on\n                    if (kElementsClosedByClosing[tagName]) {\n                        if (kElementsClosedByClosing[tagName][match[2]]) {\n                            stack.pop();\n                            currentParent = arr_back(stack);\n                            continue;\n                        }\n                    }\n                    // Use aggressive strategy to handle unmatching markups.\n                    break;\n                }\n            }\n        }\n    }\n    return stack;\n}\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */\nexport function parse(data, options = { lowerCaseTagName: false, comment: false }) {\n    const stack = base_parse(data, options);\n    const [root] = stack;\n    while (stack.length > 1) {\n        // Handle each error elements.\n        const last = stack.pop();\n        const oneBefore = arr_back(stack);\n        if (last.parentNode && last.parentNode.parentNode) {\n            if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n                // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n                oneBefore.removeChild(last);\n                last.childNodes.forEach((child) => {\n                    oneBefore.parentNode.appendChild(child);\n                });\n                stack.pop();\n            }\n            else {\n                // Single error  <div> <h3> </div> handle: Just removes <h3>\n                oneBefore.removeChild(last);\n                last.childNodes.forEach((child) => {\n                    oneBefore.appendChild(child);\n                });\n            }\n        }\n        else {\n            // If it's final element just skip.\n        }\n    }\n    // response.childNodes.forEach((node) => {\n    // \tif (node instanceof HTMLElement) {\n    // \t\tnode.parentNode = null;\n    // \t}\n    // });\n    return root;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}