{"ast":null,"code":"var OffsetToLocation = require('../common/OffsetToLocation');\nvar SyntaxError = require('../common/SyntaxError');\nvar TokenStream = require('../common/TokenStream');\nvar List = require('../common/List');\nvar tokenize = require('../tokenizer');\nvar constants = require('../tokenizer/const');\nvar {\n  findWhiteSpaceStart,\n  cmpStr\n} = require('../tokenizer/utils');\nvar sequence = require('./sequence');\nvar noop = function () {};\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar HASH = TYPE.Hash;\nvar PERCENTAGE = TYPE.Percentage;\nvar NUMBER = TYPE.Number;\nvar NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)\nvar NULL = 0;\nfunction createParseContext(name) {\n  return function () {\n    return this[name]();\n  };\n}\nfunction processConfig(config) {\n  var parserConfig = {\n    context: {},\n    scope: {},\n    atrule: {},\n    pseudo: {}\n  };\n  if (config.parseContext) {\n    for (var name in config.parseContext) {\n      switch (typeof config.parseContext[name]) {\n        case 'function':\n          parserConfig.context[name] = config.parseContext[name];\n          break;\n        case 'string':\n          parserConfig.context[name] = createParseContext(config.parseContext[name]);\n          break;\n      }\n    }\n  }\n  if (config.scope) {\n    for (var name in config.scope) {\n      parserConfig.scope[name] = config.scope[name];\n    }\n  }\n  if (config.atrule) {\n    for (var name in config.atrule) {\n      var atrule = config.atrule[name];\n      if (atrule.parse) {\n        parserConfig.atrule[name] = atrule.parse;\n      }\n    }\n  }\n  if (config.pseudo) {\n    for (var name in config.pseudo) {\n      var pseudo = config.pseudo[name];\n      if (pseudo.parse) {\n        parserConfig.pseudo[name] = pseudo.parse;\n      }\n    }\n  }\n  if (config.node) {\n    for (var name in config.node) {\n      parserConfig[name] = config.node[name].parse;\n    }\n  }\n  return parserConfig;\n}\nmodule.exports = function createParser(config) {\n  var parser = {\n    scanner: new TokenStream(),\n    locationMap: new OffsetToLocation(),\n    filename: '<unknown>',\n    needPositions: false,\n    onParseError: noop,\n    onParseErrorThrow: false,\n    parseAtrulePrelude: true,\n    parseRulePrelude: true,\n    parseValue: true,\n    parseCustomProperty: false,\n    readSequence: sequence,\n    createList: function () {\n      return new List();\n    },\n    createSingleNodeList: function (node) {\n      return new List().appendData(node);\n    },\n    getFirstListNode: function (list) {\n      return list && list.first();\n    },\n    getLastListNode: function (list) {\n      return list.last();\n    },\n    parseWithFallback: function (consumer, fallback) {\n      var startToken = this.scanner.tokenIndex;\n      try {\n        return consumer.call(this);\n      } catch (e) {\n        if (this.onParseErrorThrow) {\n          throw e;\n        }\n        var fallbackNode = fallback.call(this, startToken);\n        this.onParseErrorThrow = true;\n        this.onParseError(e, fallbackNode);\n        this.onParseErrorThrow = false;\n        return fallbackNode;\n      }\n    },\n    lookupNonWSType: function (offset) {\n      do {\n        var type = this.scanner.lookupType(offset++);\n        if (type !== WHITESPACE) {\n          return type;\n        }\n      } while (type !== NULL);\n      return NULL;\n    },\n    eat: function (tokenType) {\n      if (this.scanner.tokenType !== tokenType) {\n        var offset = this.scanner.tokenStart;\n        var message = NAME[tokenType] + ' is expected';\n\n        // tweak message and offset\n        switch (tokenType) {\n          case IDENT:\n            // when identifier is expected but there is a function or url\n            if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {\n              offset = this.scanner.tokenEnd - 1;\n              message = 'Identifier is expected but function found';\n            } else {\n              message = 'Identifier is expected';\n            }\n            break;\n          case HASH:\n            if (this.scanner.isDelim(NUMBERSIGN)) {\n              this.scanner.next();\n              offset++;\n              message = 'Name is expected';\n            }\n            break;\n          case PERCENTAGE:\n            if (this.scanner.tokenType === NUMBER) {\n              offset = this.scanner.tokenEnd;\n              message = 'Percent sign is expected';\n            }\n            break;\n          default:\n            // when test type is part of another token show error for current position + 1\n            // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {\n              offset = offset + 1;\n            }\n        }\n        this.error(message, offset);\n      }\n      this.scanner.next();\n    },\n    consume: function (tokenType) {\n      var value = this.scanner.getTokenValue();\n      this.eat(tokenType);\n      return value;\n    },\n    consumeFunctionName: function () {\n      var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);\n      this.eat(FUNCTION);\n      return name;\n    },\n    getLocation: function (start, end) {\n      if (this.needPositions) {\n        return this.locationMap.getLocationRange(start, end, this.filename);\n      }\n      return null;\n    },\n    getLocationFromList: function (list) {\n      if (this.needPositions) {\n        var head = this.getFirstListNode(list);\n        var tail = this.getLastListNode(list);\n        return this.locationMap.getLocationRange(head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart, tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart, this.filename);\n      }\n      return null;\n    },\n    error: function (message, offset) {\n      var location = typeof offset !== 'undefined' && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);\n      throw new SyntaxError(message || 'Unexpected input', this.scanner.source, location.offset, location.line, location.column);\n    }\n  };\n  config = processConfig(config || {});\n  for (var key in config) {\n    parser[key] = config[key];\n  }\n  return function (source, options) {\n    options = options || {};\n    var context = options.context || 'default';\n    var onComment = options.onComment;\n    var ast;\n    tokenize(source, parser.scanner);\n    parser.locationMap.setSource(source, options.offset, options.line, options.column);\n    parser.filename = options.filename || '<unknown>';\n    parser.needPositions = Boolean(options.positions);\n    parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;\n    parser.onParseErrorThrow = false;\n    parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n    parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n    parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n    parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n    if (!parser.context.hasOwnProperty(context)) {\n      throw new Error('Unknown context `' + context + '`');\n    }\n    if (typeof onComment === 'function') {\n      parser.scanner.forEachToken((type, start, end) => {\n        if (type === COMMENT) {\n          const loc = parser.getLocation(start, end);\n          const value = cmpStr(source, end - 2, end, '*/') ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);\n          onComment(value, loc);\n        }\n      });\n    }\n    ast = parser.context[context].call(parser, options);\n    if (!parser.scanner.eof) {\n      parser.error();\n    }\n    return ast;\n  };\n};","map":{"version":3,"names":["OffsetToLocation","require","SyntaxError","TokenStream","List","tokenize","constants","findWhiteSpaceStart","cmpStr","sequence","noop","TYPE","NAME","WHITESPACE","WhiteSpace","COMMENT","Comment","IDENT","Ident","FUNCTION","Function","URL","Url","HASH","Hash","PERCENTAGE","Percentage","NUMBER","Number","NUMBERSIGN","NULL","createParseContext","name","processConfig","config","parserConfig","context","scope","atrule","pseudo","parseContext","parse","node","module","exports","createParser","parser","scanner","locationMap","filename","needPositions","onParseError","onParseErrorThrow","parseAtrulePrelude","parseRulePrelude","parseValue","parseCustomProperty","readSequence","createList","createSingleNodeList","appendData","getFirstListNode","list","first","getLastListNode","last","parseWithFallback","consumer","fallback","startToken","tokenIndex","call","e","fallbackNode","lookupNonWSType","offset","type","lookupType","eat","tokenType","tokenStart","message","tokenEnd","isDelim","next","source","charCodeAt","error","consume","value","getTokenValue","consumeFunctionName","substring","getLocation","start","end","getLocationRange","getLocationFromList","head","tail","loc","startOffset","location","length","eof","line","column","key","options","onComment","ast","setSource","Boolean","positions","hasOwnProperty","Error","forEachToken","slice"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/parser/create.js"],"sourcesContent":["var OffsetToLocation = require('../common/OffsetToLocation');\nvar SyntaxError = require('../common/SyntaxError');\nvar TokenStream = require('../common/TokenStream');\nvar List = require('../common/List');\nvar tokenize = require('../tokenizer');\nvar constants = require('../tokenizer/const');\nvar { findWhiteSpaceStart, cmpStr } = require('../tokenizer/utils');\nvar sequence = require('./sequence');\nvar noop = function() {};\n\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar HASH = TYPE.Hash;\nvar PERCENTAGE = TYPE.Percentage;\nvar NUMBER = TYPE.Number;\nvar NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)\nvar NULL = 0;\n\nfunction createParseContext(name) {\n    return function() {\n        return this[name]();\n    };\n}\n\nfunction processConfig(config) {\n    var parserConfig = {\n        context: {},\n        scope: {},\n        atrule: {},\n        pseudo: {}\n    };\n\n    if (config.parseContext) {\n        for (var name in config.parseContext) {\n            switch (typeof config.parseContext[name]) {\n                case 'function':\n                    parserConfig.context[name] = config.parseContext[name];\n                    break;\n\n                case 'string':\n                    parserConfig.context[name] = createParseContext(config.parseContext[name]);\n                    break;\n            }\n        }\n    }\n\n    if (config.scope) {\n        for (var name in config.scope) {\n            parserConfig.scope[name] = config.scope[name];\n        }\n    }\n\n    if (config.atrule) {\n        for (var name in config.atrule) {\n            var atrule = config.atrule[name];\n\n            if (atrule.parse) {\n                parserConfig.atrule[name] = atrule.parse;\n            }\n        }\n    }\n\n    if (config.pseudo) {\n        for (var name in config.pseudo) {\n            var pseudo = config.pseudo[name];\n\n            if (pseudo.parse) {\n                parserConfig.pseudo[name] = pseudo.parse;\n            }\n        }\n    }\n\n    if (config.node) {\n        for (var name in config.node) {\n            parserConfig[name] = config.node[name].parse;\n        }\n    }\n\n    return parserConfig;\n}\n\nmodule.exports = function createParser(config) {\n    var parser = {\n        scanner: new TokenStream(),\n        locationMap: new OffsetToLocation(),\n\n        filename: '<unknown>',\n        needPositions: false,\n        onParseError: noop,\n        onParseErrorThrow: false,\n        parseAtrulePrelude: true,\n        parseRulePrelude: true,\n        parseValue: true,\n        parseCustomProperty: false,\n\n        readSequence: sequence,\n\n        createList: function() {\n            return new List();\n        },\n        createSingleNodeList: function(node) {\n            return new List().appendData(node);\n        },\n        getFirstListNode: function(list) {\n            return list && list.first();\n        },\n        getLastListNode: function(list) {\n            return list.last();\n        },\n\n        parseWithFallback: function(consumer, fallback) {\n            var startToken = this.scanner.tokenIndex;\n\n            try {\n                return consumer.call(this);\n            } catch (e) {\n                if (this.onParseErrorThrow) {\n                    throw e;\n                }\n\n                var fallbackNode = fallback.call(this, startToken);\n\n                this.onParseErrorThrow = true;\n                this.onParseError(e, fallbackNode);\n                this.onParseErrorThrow = false;\n\n                return fallbackNode;\n            }\n        },\n\n        lookupNonWSType: function(offset) {\n            do {\n                var type = this.scanner.lookupType(offset++);\n                if (type !== WHITESPACE) {\n                    return type;\n                }\n            } while (type !== NULL);\n\n            return NULL;\n        },\n\n        eat: function(tokenType) {\n            if (this.scanner.tokenType !== tokenType) {\n                var offset = this.scanner.tokenStart;\n                var message = NAME[tokenType] + ' is expected';\n\n                // tweak message and offset\n                switch (tokenType) {\n                    case IDENT:\n                        // when identifier is expected but there is a function or url\n                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {\n                            offset = this.scanner.tokenEnd - 1;\n                            message = 'Identifier is expected but function found';\n                        } else {\n                            message = 'Identifier is expected';\n                        }\n                        break;\n\n                    case HASH:\n                        if (this.scanner.isDelim(NUMBERSIGN)) {\n                            this.scanner.next();\n                            offset++;\n                            message = 'Name is expected';\n                        }\n                        break;\n\n                    case PERCENTAGE:\n                        if (this.scanner.tokenType === NUMBER) {\n                            offset = this.scanner.tokenEnd;\n                            message = 'Percent sign is expected';\n                        }\n                        break;\n\n                    default:\n                        // when test type is part of another token show error for current position + 1\n                        // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {\n                            offset = offset + 1;\n                        }\n                }\n\n                this.error(message, offset);\n            }\n\n            this.scanner.next();\n        },\n\n        consume: function(tokenType) {\n            var value = this.scanner.getTokenValue();\n\n            this.eat(tokenType);\n\n            return value;\n        },\n        consumeFunctionName: function() {\n            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);\n\n            this.eat(FUNCTION);\n\n            return name;\n        },\n\n        getLocation: function(start, end) {\n            if (this.needPositions) {\n                return this.locationMap.getLocationRange(\n                    start,\n                    end,\n                    this.filename\n                );\n            }\n\n            return null;\n        },\n        getLocationFromList: function(list) {\n            if (this.needPositions) {\n                var head = this.getFirstListNode(list);\n                var tail = this.getLastListNode(list);\n                return this.locationMap.getLocationRange(\n                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                    this.filename\n                );\n            }\n\n            return null;\n        },\n\n        error: function(message, offset) {\n            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length\n                ? this.locationMap.getLocation(offset)\n                : this.scanner.eof\n                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))\n                    : this.locationMap.getLocation(this.scanner.tokenStart);\n\n            throw new SyntaxError(\n                message || 'Unexpected input',\n                this.scanner.source,\n                location.offset,\n                location.line,\n                location.column\n            );\n        }\n    };\n\n    config = processConfig(config || {});\n    for (var key in config) {\n        parser[key] = config[key];\n    }\n\n    return function(source, options) {\n        options = options || {};\n\n        var context = options.context || 'default';\n        var onComment = options.onComment;\n        var ast;\n\n        tokenize(source, parser.scanner);\n        parser.locationMap.setSource(\n            source,\n            options.offset,\n            options.line,\n            options.column\n        );\n\n        parser.filename = options.filename || '<unknown>';\n        parser.needPositions = Boolean(options.positions);\n        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;\n        parser.onParseErrorThrow = false;\n        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n        if (!parser.context.hasOwnProperty(context)) {\n            throw new Error('Unknown context `' + context + '`');\n        }\n\n        if (typeof onComment === 'function') {\n            parser.scanner.forEachToken((type, start, end) => {\n                if (type === COMMENT) {\n                    const loc = parser.getLocation(start, end);\n                    const value = cmpStr(source, end - 2, end, '*/')\n                        ? source.slice(start + 2, end - 2)\n                        : source.slice(start + 2, end);\n\n                    onComment(value, loc);\n                }\n            });\n        }\n\n        ast = parser.context[context].call(parser, options);\n\n        if (!parser.scanner.eof) {\n            parser.error();\n        }\n\n        return ast;\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}