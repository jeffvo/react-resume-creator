{"ast":null,"code":"var parse = require('../definition-syntax/parse');\nvar MATCH = {\n  type: 'Match'\n};\nvar MISMATCH = {\n  type: 'Mismatch'\n};\nvar DISALLOW_EMPTY = {\n  type: 'DisallowEmpty'\n};\nvar LEFTPARENTHESIS = 40; // (\nvar RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n  // reduce node count\n  if (thenBranch === MATCH && elseBranch === MISMATCH) {\n    return match;\n  }\n  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n    return match;\n  }\n  if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n    thenBranch = match.then;\n    match = match.match;\n  }\n  return {\n    type: 'If',\n    match: match,\n    then: thenBranch,\n    else: elseBranch\n  };\n}\nfunction isFunctionType(name) {\n  return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;\n}\nfunction isEnumCapatible(term) {\n  return term.type === 'Keyword' || term.type === 'AtKeyword' || term.type === 'Function' || term.type === 'Type' && isFunctionType(term.name);\n}\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n  switch (combinator) {\n    case ' ':\n      // Juxtaposing components means that all of them must occur, in the given order.\n      //\n      // a b c\n      // =\n      // match a\n      //   then match b\n      //     then match c\n      //       then MATCH\n      //       else MISMATCH\n      //     else MISMATCH\n      //   else MISMATCH\n      var result = MATCH;\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        result = createCondition(term, result, MISMATCH);\n      }\n      ;\n      return result;\n    case '|':\n      // A bar (|) separates two or more alternatives: exactly one of them must occur.\n      //\n      // a | b | c\n      // =\n      // match a\n      //   then MATCH\n      //   else match b\n      //     then MATCH\n      //     else match c\n      //       then MATCH\n      //       else MISMATCH\n\n      var result = MISMATCH;\n      var map = null;\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n\n        // reduce sequence of keywords into a Enum\n        if (isEnumCapatible(term)) {\n          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n            map = Object.create(null);\n            result = createCondition({\n              type: 'Enum',\n              map: map\n            }, MATCH, result);\n          }\n          if (map !== null) {\n            var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n            if (key in map === false) {\n              map[key] = term;\n              continue;\n            }\n          }\n        }\n        map = null;\n\n        // create a new conditonal node\n        result = createCondition(term, MATCH, result);\n      }\n      ;\n      return result;\n    case '&&':\n      // A double ampersand (&&) separates two or more components,\n      // all of which must occur, in any order.\n\n      // Use MatchOnce for groups with a large number of terms,\n      // since &&-groups produces at least N!-node trees\n      if (terms.length > 5) {\n        return {\n          type: 'MatchOnce',\n          terms: terms,\n          all: true\n        };\n      }\n\n      // Use a combination tree for groups with small number of terms\n      //\n      // a && b && c\n      // =\n      // match a\n      //   then [b && c]\n      //   else match b\n      //     then [a && c]\n      //     else match c\n      //       then [a && b]\n      //       else MISMATCH\n      //\n      // a && b\n      // =\n      // match a\n      //   then match b\n      //     then MATCH\n      //     else MISMATCH\n      //   else match b\n      //     then match a\n      //       then MATCH\n      //       else MISMATCH\n      //     else MISMATCH\n      var result = MISMATCH;\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        var thenClause;\n        if (terms.length > 1) {\n          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {\n            return newGroupTerm !== term;\n          }), false);\n        } else {\n          thenClause = MATCH;\n        }\n        result = createCondition(term, thenClause, result);\n      }\n      ;\n      return result;\n    case '||':\n      // A double bar (||) separates two or more options:\n      // one or more of them must occur, in any order.\n\n      // Use MatchOnce for groups with a large number of terms,\n      // since ||-groups produces at least N!-node trees\n      if (terms.length > 5) {\n        return {\n          type: 'MatchOnce',\n          terms: terms,\n          all: false\n        };\n      }\n\n      // Use a combination tree for groups with small number of terms\n      //\n      // a || b || c\n      // =\n      // match a\n      //   then [b || c]\n      //   else match b\n      //     then [a || c]\n      //     else match c\n      //       then [a || b]\n      //       else MISMATCH\n      //\n      // a || b\n      // =\n      // match a\n      //   then match b\n      //     then MATCH\n      //     else MATCH\n      //   else match b\n      //     then match a\n      //       then MATCH\n      //       else MATCH\n      //     else MISMATCH\n      var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        var thenClause;\n        if (terms.length > 1) {\n          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {\n            return newGroupTerm !== term;\n          }), true);\n        } else {\n          thenClause = MATCH;\n        }\n        result = createCondition(term, thenClause, result);\n      }\n      ;\n      return result;\n  }\n}\nfunction buildMultiplierMatchGraph(node) {\n  var result = MATCH;\n  var matchTerm = buildMatchGraph(node.term);\n  if (node.max === 0) {\n    // disable repeating of empty match to prevent infinite loop\n    matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);\n\n    // an occurrence count is not limited, make a cycle;\n    // to collect more terms on each following matching mismatch\n    result = createCondition(matchTerm, null,\n    // will be a loop\n    MISMATCH);\n    result.then = createCondition(MATCH, MATCH, result // make a loop\n    );\n    if (node.comma) {\n      result.then.else = createCondition({\n        type: 'Comma',\n        syntax: node\n      }, result, MISMATCH);\n    }\n  } else {\n    // create a match node chain for [min .. max] interval with optional matches\n    for (var i = node.min || 1; i <= node.max; i++) {\n      if (node.comma && result !== MATCH) {\n        result = createCondition({\n          type: 'Comma',\n          syntax: node\n        }, result, MISMATCH);\n      }\n      result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);\n    }\n  }\n  if (node.min === 0) {\n    // allow zero match\n    result = createCondition(MATCH, MATCH, result);\n  } else {\n    // create a match node chain to collect [0 ... min - 1] required matches\n    for (var i = 0; i < node.min - 1; i++) {\n      if (node.comma && result !== MATCH) {\n        result = createCondition({\n          type: 'Comma',\n          syntax: node\n        }, result, MISMATCH);\n      }\n      result = createCondition(matchTerm, result, MISMATCH);\n    }\n  }\n  return result;\n}\nfunction buildMatchGraph(node) {\n  if (typeof node === 'function') {\n    return {\n      type: 'Generic',\n      fn: node\n    };\n  }\n  switch (node.type) {\n    case 'Group':\n      var result = buildGroupMatchGraph(node.combinator, node.terms.map(buildMatchGraph), false);\n      if (node.disallowEmpty) {\n        result = createCondition(result, DISALLOW_EMPTY, MISMATCH);\n      }\n      return result;\n    case 'Multiplier':\n      return buildMultiplierMatchGraph(node);\n    case 'Type':\n    case 'Property':\n      return {\n        type: node.type,\n        name: node.name,\n        syntax: node\n      };\n    case 'Keyword':\n      return {\n        type: node.type,\n        name: node.name.toLowerCase(),\n        syntax: node\n      };\n    case 'AtKeyword':\n      return {\n        type: node.type,\n        name: '@' + node.name.toLowerCase(),\n        syntax: node\n      };\n    case 'Function':\n      return {\n        type: node.type,\n        name: node.name.toLowerCase() + '(',\n        syntax: node\n      };\n    case 'String':\n      // convert a one char length String to a Token\n      if (node.value.length === 3) {\n        return {\n          type: 'Token',\n          value: node.value.charAt(1),\n          syntax: node\n        };\n      }\n\n      // otherwise use it as is\n      return {\n        type: node.type,\n        value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n        syntax: node\n      };\n    case 'Token':\n      return {\n        type: node.type,\n        value: node.value,\n        syntax: node\n      };\n    case 'Comma':\n      return {\n        type: node.type,\n        syntax: node\n      };\n    default:\n      throw new Error('Unknown node type:', node.type);\n  }\n}\nmodule.exports = {\n  MATCH: MATCH,\n  MISMATCH: MISMATCH,\n  DISALLOW_EMPTY: DISALLOW_EMPTY,\n  buildMatchGraph: function (syntaxTree, ref) {\n    if (typeof syntaxTree === 'string') {\n      syntaxTree = parse(syntaxTree);\n    }\n    return {\n      type: 'MatchGraph',\n      match: buildMatchGraph(syntaxTree),\n      syntax: ref || null,\n      source: syntaxTree\n    };\n  }\n};","map":{"version":3,"names":["parse","require","MATCH","type","MISMATCH","DISALLOW_EMPTY","LEFTPARENTHESIS","RIGHTPARENTHESIS","createCondition","match","thenBranch","elseBranch","else","then","isFunctionType","name","length","charCodeAt","isEnumCapatible","term","buildGroupMatchGraph","combinator","terms","atLeastOneTermMatched","result","i","map","Object","create","key","slice","toLowerCase","all","thenClause","filter","newGroupTerm","buildMultiplierMatchGraph","node","matchTerm","buildMatchGraph","max","comma","syntax","min","fn","disallowEmpty","value","charAt","substr","replace","Error","module","exports","syntaxTree","ref","source"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/match-graph.js"],"sourcesContent":["var parse = require('../definition-syntax/parse');\n\nvar MATCH = { type: 'Match' };\nvar MISMATCH = { type: 'Mismatch' };\nvar DISALLOW_EMPTY = { type: 'DisallowEmpty' };\nvar LEFTPARENTHESIS = 40;  // (\nvar RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n    // reduce node count\n    if (thenBranch === MATCH && elseBranch === MISMATCH) {\n        return match;\n    }\n\n    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n        return match;\n    }\n\n    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n        thenBranch = match.then;\n        match = match.match;\n    }\n\n    return {\n        type: 'If',\n        match: match,\n        then: thenBranch,\n        else: elseBranch\n    };\n}\n\nfunction isFunctionType(name) {\n    return (\n        name.length > 2 &&\n        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&\n        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS\n    );\n}\n\nfunction isEnumCapatible(term) {\n    return (\n        term.type === 'Keyword' ||\n        term.type === 'AtKeyword' ||\n        term.type === 'Function' ||\n        term.type === 'Type' && isFunctionType(term.name)\n    );\n}\n\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n    switch (combinator) {\n        case ' ':\n            // Juxtaposing components means that all of them must occur, in the given order.\n            //\n            // a b c\n            // =\n            // match a\n            //   then match b\n            //     then match c\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            //   else MISMATCH\n            var result = MATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n\n                result = createCondition(\n                    term,\n                    result,\n                    MISMATCH\n                );\n            };\n\n            return result;\n\n        case '|':\n            // A bar (|) separates two or more alternatives: exactly one of them must occur.\n            //\n            // a | b | c\n            // =\n            // match a\n            //   then MATCH\n            //   else match b\n            //     then MATCH\n            //     else match c\n            //       then MATCH\n            //       else MISMATCH\n\n            var result = MISMATCH;\n            var map = null;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n\n                // reduce sequence of keywords into a Enum\n                if (isEnumCapatible(term)) {\n                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n                        map = Object.create(null);\n                        result = createCondition(\n                            {\n                                type: 'Enum',\n                                map: map\n                            },\n                            MATCH,\n                            result\n                        );\n                    }\n\n                    if (map !== null) {\n                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n                        if (key in map === false) {\n                            map[key] = term;\n                            continue;\n                        }\n                    }\n                }\n\n                map = null;\n\n                // create a new conditonal node\n                result = createCondition(\n                    term,\n                    MATCH,\n                    result\n                );\n            };\n\n            return result;\n\n        case '&&':\n            // A double ampersand (&&) separates two or more components,\n            // all of which must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since &&-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms: terms,\n                    all: true\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a && b && c\n            // =\n            // match a\n            //   then [b && c]\n            //   else match b\n            //     then [a && c]\n            //     else match c\n            //       then [a && b]\n            //       else MISMATCH\n            //\n            // a && b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MISMATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            var result = MISMATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n                var thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        false\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n\n        case '||':\n            // A double bar (||) separates two or more options:\n            // one or more of them must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since ||-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms: terms,\n                    all: false\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a || b || c\n            // =\n            // match a\n            //   then [b || c]\n            //   else match b\n            //     then [a || c]\n            //     else match c\n            //       then [a || b]\n            //       else MISMATCH\n            //\n            // a || b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MATCH\n            //     else MISMATCH\n            var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n                var thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        true\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n    }\n}\n\nfunction buildMultiplierMatchGraph(node) {\n    var result = MATCH;\n    var matchTerm = buildMatchGraph(node.term);\n\n    if (node.max === 0) {\n        // disable repeating of empty match to prevent infinite loop\n        matchTerm = createCondition(\n            matchTerm,\n            DISALLOW_EMPTY,\n            MISMATCH\n        );\n\n        // an occurrence count is not limited, make a cycle;\n        // to collect more terms on each following matching mismatch\n        result = createCondition(\n            matchTerm,\n            null, // will be a loop\n            MISMATCH\n        );\n\n        result.then = createCondition(\n            MATCH,\n            MATCH,\n            result // make a loop\n        );\n\n        if (node.comma) {\n            result.then.else = createCondition(\n                { type: 'Comma', syntax: node },\n                result,\n                MISMATCH\n            );\n        }\n    } else {\n        // create a match node chain for [min .. max] interval with optional matches\n        for (var i = node.min || 1; i <= node.max; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                createCondition(\n                    MATCH,\n                    MATCH,\n                    result\n                ),\n                MISMATCH\n            );\n        }\n    }\n\n    if (node.min === 0) {\n        // allow zero match\n        result = createCondition(\n            MATCH,\n            MATCH,\n            result\n        );\n    } else {\n        // create a match node chain to collect [0 ... min - 1] required matches\n        for (var i = 0; i < node.min - 1; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                result,\n                MISMATCH\n            );\n        }\n    }\n\n    return result;\n}\n\nfunction buildMatchGraph(node) {\n    if (typeof node === 'function') {\n        return {\n            type: 'Generic',\n            fn: node\n        };\n    }\n\n    switch (node.type) {\n        case 'Group':\n            var result = buildGroupMatchGraph(\n                node.combinator,\n                node.terms.map(buildMatchGraph),\n                false\n            );\n\n            if (node.disallowEmpty) {\n                result = createCondition(\n                    result,\n                    DISALLOW_EMPTY,\n                    MISMATCH\n                );\n            }\n\n            return result;\n\n        case 'Multiplier':\n            return buildMultiplierMatchGraph(node);\n\n        case 'Type':\n        case 'Property':\n            return {\n                type: node.type,\n                name: node.name,\n                syntax: node\n            };\n\n        case 'Keyword':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'AtKeyword':\n            return {\n                type: node.type,\n                name: '@' + node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'Function':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase() + '(',\n                syntax: node\n            };\n\n        case 'String':\n            // convert a one char length String to a Token\n            if (node.value.length === 3) {\n                return {\n                    type: 'Token',\n                    value: node.value.charAt(1),\n                    syntax: node\n                };\n            }\n\n            // otherwise use it as is\n            return {\n                type: node.type,\n                value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n                syntax: node\n            };\n\n        case 'Token':\n            return {\n                type: node.type,\n                value: node.value,\n                syntax: node\n            };\n\n        case 'Comma':\n            return {\n                type: node.type,\n                syntax: node\n            };\n\n        default:\n            throw new Error('Unknown node type:', node.type);\n    }\n}\n\nmodule.exports = {\n    MATCH: MATCH,\n    MISMATCH: MISMATCH,\n    DISALLOW_EMPTY: DISALLOW_EMPTY,\n    buildMatchGraph: function(syntaxTree, ref) {\n        if (typeof syntaxTree === 'string') {\n            syntaxTree = parse(syntaxTree);\n        }\n\n        return {\n            type: 'MatchGraph',\n            match: buildMatchGraph(syntaxTree),\n            syntax: ref || null,\n            source: syntaxTree\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}