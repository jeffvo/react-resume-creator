{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { getQueryHandlerAndSelector } from '../common/GetQueryHandler.js';\nimport { LazyArg } from '../common/LazyArg.js';\nimport { isString, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { AsyncIterableUtil } from '../util/AsyncIterableUtil.js';\nimport { throwIfDisposed } from '../util/decorators.js';\nimport { _isElementHandle } from './ElementHandleSymbol.js';\nimport { JSHandle } from './JSHandle.js';\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nlet ElementHandle = (() => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;\n  let _classSuper = JSHandle;\n  let _instanceExtraInitializers = [];\n  let _getProperty_decorators;\n  let _getProperties_decorators;\n  let _jsonValue_decorators;\n  let _$_decorators;\n  let _$$_decorators;\n  let _waitForSelector_decorators;\n  let _isVisible_decorators;\n  let _isHidden_decorators;\n  let _toElement_decorators;\n  let _clickablePoint_decorators;\n  let _hover_decorators;\n  let _click_decorators;\n  let _drag_decorators;\n  let _dragEnter_decorators;\n  let _dragOver_decorators;\n  let _drop_decorators;\n  let _dragAndDrop_decorators;\n  let _select_decorators;\n  let _tap_decorators;\n  let _touchStart_decorators;\n  let _touchMove_decorators;\n  let _touchEnd_decorators;\n  let _focus_decorators;\n  let _type_decorators;\n  let _press_decorators;\n  let _boundingBox_decorators;\n  let _boxModel_decorators;\n  let _screenshot_decorators;\n  let _isIntersectingViewport_decorators;\n  let _scrollIntoView_decorators;\n  return class ElementHandle extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      _getProperty_decorators = [throwIfDisposed(), (_a = ElementHandle).bindIsolatedHandle.bind(_a)];\n      _getProperties_decorators = [throwIfDisposed(), (_b = ElementHandle).bindIsolatedHandle.bind(_b)];\n      _jsonValue_decorators = [throwIfDisposed(), (_c = ElementHandle).bindIsolatedHandle.bind(_c)];\n      _$_decorators = [throwIfDisposed(), (_d = ElementHandle).bindIsolatedHandle.bind(_d)];\n      _$$_decorators = [throwIfDisposed(), (_e = ElementHandle).bindIsolatedHandle.bind(_e)];\n      _waitForSelector_decorators = [throwIfDisposed(), (_f = ElementHandle).bindIsolatedHandle.bind(_f)];\n      _isVisible_decorators = [throwIfDisposed(), (_g = ElementHandle).bindIsolatedHandle.bind(_g)];\n      _isHidden_decorators = [throwIfDisposed(), (_h = ElementHandle).bindIsolatedHandle.bind(_h)];\n      _toElement_decorators = [throwIfDisposed(), (_j = ElementHandle).bindIsolatedHandle.bind(_j)];\n      _clickablePoint_decorators = [throwIfDisposed(), (_k = ElementHandle).bindIsolatedHandle.bind(_k)];\n      _hover_decorators = [throwIfDisposed(), (_l = ElementHandle).bindIsolatedHandle.bind(_l)];\n      _click_decorators = [throwIfDisposed(), (_m = ElementHandle).bindIsolatedHandle.bind(_m)];\n      _drag_decorators = [throwIfDisposed(), (_o = ElementHandle).bindIsolatedHandle.bind(_o)];\n      _dragEnter_decorators = [throwIfDisposed(), (_p = ElementHandle).bindIsolatedHandle.bind(_p)];\n      _dragOver_decorators = [throwIfDisposed(), (_q = ElementHandle).bindIsolatedHandle.bind(_q)];\n      _drop_decorators = [throwIfDisposed(), (_r = ElementHandle).bindIsolatedHandle.bind(_r)];\n      _dragAndDrop_decorators = [throwIfDisposed(), (_s = ElementHandle).bindIsolatedHandle.bind(_s)];\n      _select_decorators = [throwIfDisposed(), (_t = ElementHandle).bindIsolatedHandle.bind(_t)];\n      _tap_decorators = [throwIfDisposed(), (_u = ElementHandle).bindIsolatedHandle.bind(_u)];\n      _touchStart_decorators = [throwIfDisposed(), (_v = ElementHandle).bindIsolatedHandle.bind(_v)];\n      _touchMove_decorators = [throwIfDisposed(), (_w = ElementHandle).bindIsolatedHandle.bind(_w)];\n      _touchEnd_decorators = [throwIfDisposed(), (_x = ElementHandle).bindIsolatedHandle.bind(_x)];\n      _focus_decorators = [throwIfDisposed(), (_y = ElementHandle).bindIsolatedHandle.bind(_y)];\n      _type_decorators = [throwIfDisposed(), (_z = ElementHandle).bindIsolatedHandle.bind(_z)];\n      _press_decorators = [throwIfDisposed(), (_0 = ElementHandle).bindIsolatedHandle.bind(_0)];\n      _boundingBox_decorators = [throwIfDisposed(), (_1 = ElementHandle).bindIsolatedHandle.bind(_1)];\n      _boxModel_decorators = [throwIfDisposed(), (_2 = ElementHandle).bindIsolatedHandle.bind(_2)];\n      _screenshot_decorators = [throwIfDisposed(), (_3 = ElementHandle).bindIsolatedHandle.bind(_3)];\n      _isIntersectingViewport_decorators = [throwIfDisposed(), (_4 = ElementHandle).bindIsolatedHandle.bind(_4)];\n      _scrollIntoView_decorators = [throwIfDisposed(), (_5 = ElementHandle).bindIsolatedHandle.bind(_5)];\n      __esDecorate(this, null, _getProperty_decorators, {\n        kind: \"method\",\n        name: \"getProperty\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperty\" in obj,\n          get: obj => obj.getProperty\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _getProperties_decorators, {\n        kind: \"method\",\n        name: \"getProperties\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperties\" in obj,\n          get: obj => obj.getProperties\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _jsonValue_decorators, {\n        kind: \"method\",\n        name: \"jsonValue\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"jsonValue\" in obj,\n          get: obj => obj.jsonValue\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$_decorators, {\n        kind: \"method\",\n        name: \"$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$\" in obj,\n          get: obj => obj.$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$$_decorators, {\n        kind: \"method\",\n        name: \"$$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$$\" in obj,\n          get: obj => obj.$$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForSelector_decorators, {\n        kind: \"method\",\n        name: \"waitForSelector\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForSelector\" in obj,\n          get: obj => obj.waitForSelector\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isVisible_decorators, {\n        kind: \"method\",\n        name: \"isVisible\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isVisible\" in obj,\n          get: obj => obj.isVisible\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isHidden_decorators, {\n        kind: \"method\",\n        name: \"isHidden\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isHidden\" in obj,\n          get: obj => obj.isHidden\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _toElement_decorators, {\n        kind: \"method\",\n        name: \"toElement\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"toElement\" in obj,\n          get: obj => obj.toElement\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _clickablePoint_decorators, {\n        kind: \"method\",\n        name: \"clickablePoint\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"clickablePoint\" in obj,\n          get: obj => obj.clickablePoint\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _hover_decorators, {\n        kind: \"method\",\n        name: \"hover\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"hover\" in obj,\n          get: obj => obj.hover\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _click_decorators, {\n        kind: \"method\",\n        name: \"click\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"click\" in obj,\n          get: obj => obj.click\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _drag_decorators, {\n        kind: \"method\",\n        name: \"drag\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"drag\" in obj,\n          get: obj => obj.drag\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragEnter_decorators, {\n        kind: \"method\",\n        name: \"dragEnter\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragEnter\" in obj,\n          get: obj => obj.dragEnter\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragOver_decorators, {\n        kind: \"method\",\n        name: \"dragOver\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragOver\" in obj,\n          get: obj => obj.dragOver\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _drop_decorators, {\n        kind: \"method\",\n        name: \"drop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"drop\" in obj,\n          get: obj => obj.drop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragAndDrop_decorators, {\n        kind: \"method\",\n        name: \"dragAndDrop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragAndDrop\" in obj,\n          get: obj => obj.dragAndDrop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _select_decorators, {\n        kind: \"method\",\n        name: \"select\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"select\" in obj,\n          get: obj => obj.select\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _tap_decorators, {\n        kind: \"method\",\n        name: \"tap\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"tap\" in obj,\n          get: obj => obj.tap\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchStart_decorators, {\n        kind: \"method\",\n        name: \"touchStart\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchStart\" in obj,\n          get: obj => obj.touchStart\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchMove_decorators, {\n        kind: \"method\",\n        name: \"touchMove\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchMove\" in obj,\n          get: obj => obj.touchMove\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchEnd_decorators, {\n        kind: \"method\",\n        name: \"touchEnd\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchEnd\" in obj,\n          get: obj => obj.touchEnd\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _focus_decorators, {\n        kind: \"method\",\n        name: \"focus\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"focus\" in obj,\n          get: obj => obj.focus\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _type_decorators, {\n        kind: \"method\",\n        name: \"type\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"type\" in obj,\n          get: obj => obj.type\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _press_decorators, {\n        kind: \"method\",\n        name: \"press\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"press\" in obj,\n          get: obj => obj.press\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _boundingBox_decorators, {\n        kind: \"method\",\n        name: \"boundingBox\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"boundingBox\" in obj,\n          get: obj => obj.boundingBox\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _boxModel_decorators, {\n        kind: \"method\",\n        name: \"boxModel\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"boxModel\" in obj,\n          get: obj => obj.boxModel\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _screenshot_decorators, {\n        kind: \"method\",\n        name: \"screenshot\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"screenshot\" in obj,\n          get: obj => obj.screenshot\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isIntersectingViewport_decorators, {\n        kind: \"method\",\n        name: \"isIntersectingViewport\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isIntersectingViewport\" in obj,\n          get: obj => obj.isIntersectingViewport\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _scrollIntoView_decorators, {\n        kind: \"method\",\n        name: \"scrollIntoView\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"scrollIntoView\" in obj,\n          get: obj => obj.scrollIntoView\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    /**\n     * A given method will have it's `this` replaced with an isolated version of\n     * `this` when decorated with this decorator.\n     *\n     * All changes of isolated `this` are reflected on the actual `this`.\n     *\n     * @internal\n     */\n    static bindIsolatedHandle(target, _) {\n      return async function (...args) {\n        const env_1 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          // If the handle is already isolated, then we don't need to adopt it\n          // again.\n          if (this.realm === this.frame.isolatedRealm()) {\n            return await target.call(this, ...args);\n          }\n          const adoptedThis = __addDisposableResource(env_1, await this.frame.isolatedRealm().adoptHandle(this), false);\n          const result = await target.call(adoptedThis, ...args);\n          // If the function returns `adoptedThis`, then we return `this`.\n          if (result === adoptedThis) {\n            return this;\n          }\n          // If the function returns a handle, transfer it into the current realm.\n          if (result instanceof JSHandle) {\n            return await this.realm.transferHandle(result);\n          }\n          // If the function returns an array of handlers, transfer them into the\n          // current realm.\n          if (Array.isArray(result)) {\n            await Promise.all(result.map(async (item, index, result) => {\n              if (item instanceof JSHandle) {\n                result[index] = await this.realm.transferHandle(item);\n              }\n            }));\n          }\n          if (result instanceof Map) {\n            await Promise.all([...result.entries()].map(async ([key, value]) => {\n              if (value instanceof JSHandle) {\n                result.set(key, await this.realm.transferHandle(value));\n              }\n            }));\n          }\n          return result;\n        } catch (e_1) {\n          env_1.error = e_1;\n          env_1.hasError = true;\n        } finally {\n          __disposeResources(env_1);\n        }\n      };\n    }\n    /**\n     * @internal\n     */\n    handle = (__runInitializers(this, _instanceExtraInitializers), void 0);\n    /**\n     * @internal\n     */\n    constructor(handle) {\n      super();\n      this.handle = handle;\n      this[_isElementHandle] = true;\n    }\n    /**\n     * @internal\n     */\n    get id() {\n      return this.handle.id;\n    }\n    /**\n     * @internal\n     */\n    get disposed() {\n      return this.handle.disposed;\n    }\n    /**\n     * @internal\n     */\n    async getProperty(propertyName) {\n      return await this.handle.getProperty(propertyName);\n    }\n    /**\n     * @internal\n     */\n    async getProperties() {\n      return await this.handle.getProperties();\n    }\n    /**\n     * @internal\n     */\n    async evaluate(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      return await this.handle.evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async evaluateHandle(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      return await this.handle.evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async jsonValue() {\n      return await this.handle.jsonValue();\n    }\n    /**\n     * @internal\n     */\n    toString() {\n      return this.handle.toString();\n    }\n    /**\n     * @internal\n     */\n    remoteObject() {\n      return this.handle.remoteObject();\n    }\n    /**\n     * @internal\n     */\n    dispose() {\n      return this.handle.dispose();\n    }\n    /**\n     * @internal\n     */\n    asElement() {\n      return this;\n    }\n    /**\n     * Queries the current element for an element matching the given selector.\n     *\n     * @param selector - The selector to query for.\n     * @returns A {@link ElementHandle | element handle} to the first element\n     * matching the given selector. Otherwise, `null`.\n     */\n    async $(selector) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.queryOne(this, updatedSelector);\n    }\n    /**\n     * Queries the current element for all elements matching the given selector.\n     *\n     * @param selector - The selector to query for.\n     * @returns An array of {@link ElementHandle | element handles} that point to\n     * elements matching the given selector.\n     */\n    async $$(selector) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));\n    }\n    /**\n     * Runs the given function on the first element matching the given selector in\n     * the current element.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     *\n     * ```ts\n     * const tweetHandle = await page.$('.tweet');\n     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n     *   '100'\n     * );\n     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n     *   '10'\n     * );\n     * ```\n     *\n     * @param selector - The selector to query for.\n     * @param pageFunction - The function to be evaluated in this element's page's\n     * context. The first element matching the selector will be passed in as the\n     * first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $eval(selector, pageFunction, ...args) {\n      const env_2 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n        const elementHandle = __addDisposableResource(env_2, await this.$(selector), false);\n        if (!elementHandle) {\n          throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n        }\n        return await elementHandle.evaluate(pageFunction, ...args);\n      } catch (e_2) {\n        env_2.error = e_2;\n        env_2.hasError = true;\n      } finally {\n        __disposeResources(env_2);\n      }\n    }\n    /**\n     * Runs the given function on an array of elements matching the given selector\n     * in the current element.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     * HTML:\n     *\n     * ```html\n     * <div class=\"feed\">\n     *   <div class=\"tweet\">Hello!</div>\n     *   <div class=\"tweet\">Hi!</div>\n     * </div>\n     * ```\n     *\n     * JavaScript:\n     *\n     * ```ts\n     * const feedHandle = await page.$('.feed');\n     * expect(\n     *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))\n     * ).toEqual(['Hello!', 'Hi!']);\n     * ```\n     *\n     * @param selector - The selector to query for.\n     * @param pageFunction - The function to be evaluated in the element's page's\n     * context. An array of elements matching the given selector will be passed to\n     * the function as its first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $$eval(selector, pageFunction, ...args) {\n      const env_3 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n        const results = await this.$$(selector);\n        const elements = __addDisposableResource(env_3, await this.evaluateHandle((_, ...elements) => {\n          return elements;\n        }, ...results), false);\n        const [result] = await Promise.all([elements.evaluate(pageFunction, ...args), ...results.map(results => {\n          return results.dispose();\n        })]);\n        return result;\n      } catch (e_3) {\n        env_3.error = e_3;\n        env_3.hasError = true;\n      } finally {\n        __disposeResources(env_3);\n      }\n    }\n    /**\n     * Wait for an element matching the given selector to appear in the current\n     * element.\n     *\n     * Unlike {@link Frame.waitForSelector}, this method does not work across\n     * navigations or if the element is detached from DOM.\n     *\n     * @example\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .mainFrame()\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - The selector to query and wait for.\n     * @param options - Options for customizing waiting behavior.\n     * @returns An element matching the given selector.\n     * @throws Throws if an element matching the given selector doesn't appear.\n     */\n    async waitForSelector(selector, options = {}) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.waitFor(this, updatedSelector, options);\n    }\n    async #checkVisibility(visibility) {\n      return await this.evaluate(async (element, PuppeteerUtil, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      }, LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }), visibility);\n    }\n    /**\n     * Checks if an element is visible using the same mechanism as\n     * {@link ElementHandle.waitForSelector}.\n     */\n    async isVisible() {\n      return await this.#checkVisibility(true);\n    }\n    /**\n     * Checks if an element is hidden using the same mechanism as\n     * {@link ElementHandle.waitForSelector}.\n     */\n    async isHidden() {\n      return await this.#checkVisibility(false);\n    }\n    /**\n     * Converts the current handle to the given element type.\n     *\n     * @example\n     *\n     * ```ts\n     * const element: ElementHandle<Element> = await page.$(\n     *   '.class-name-of-anchor'\n     * );\n     * // DO NOT DISPOSE `element`, this will be always be the same handle.\n     * const anchor: ElementHandle<HTMLAnchorElement> =\n     *   await element.toElement('a');\n     * ```\n     *\n     * @param tagName - The tag name of the desired element type.\n     * @throws An error if the handle does not match. **The handle will not be\n     * automatically disposed.**\n     */\n    async toElement(tagName) {\n      const isMatchingTagName = await this.evaluate((node, tagName) => {\n        return node.nodeName === tagName.toUpperCase();\n      }, tagName);\n      if (!isMatchingTagName) {\n        throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n      }\n      return this;\n    }\n    /**\n     * Returns the middle point within an element unless a specific offset is provided.\n     */\n    async clickablePoint(offset) {\n      const box = await this.#clickableBox();\n      if (!box) {\n        throw new Error('Node is either not clickable or not an Element');\n      }\n      if (offset !== undefined) {\n        return {\n          x: box.x + offset.x,\n          y: box.y + offset.y\n        };\n      }\n      return {\n        x: box.x + box.width / 2,\n        y: box.y + box.height / 2\n      };\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page} to hover over the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async hover() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().mouse.move(x, y);\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page | Page.mouse} to click in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async click(options = {}) {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint(options.offset);\n      await this.frame.page().mouse.click(x, y, options);\n    }\n    /**\n     * Drags an element over the given element or point.\n     *\n     * @returns DEPRECATED. When drag interception is enabled, the drag payload is\n     * returned.\n     */\n    async drag(target) {\n      await this.scrollIntoViewIfNeeded();\n      const page = this.frame.page();\n      if (page.isDragInterceptionEnabled()) {\n        const source = await this.clickablePoint();\n        if (target instanceof ElementHandle) {\n          target = await target.clickablePoint();\n        }\n        return await page.mouse.drag(source, target);\n      }\n      try {\n        if (!page._isDragging) {\n          page._isDragging = true;\n          await this.hover();\n          await page.mouse.down();\n        }\n        if (target instanceof ElementHandle) {\n          await target.hover();\n        } else {\n          await page.mouse.move(target.x, target.y);\n        }\n      } catch (error) {\n        page._isDragging = false;\n        throw error;\n      }\n    }\n    /**\n     * @deprecated Do not use. `dragenter` will automatically be performed during dragging.\n     */\n    async dragEnter(data = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      await this.scrollIntoViewIfNeeded();\n      const target = await this.clickablePoint();\n      await page.mouse.dragEnter(target, data);\n    }\n    /**\n     * @deprecated Do not use. `dragover` will automatically be performed during dragging.\n     */\n    async dragOver(data = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      await this.scrollIntoViewIfNeeded();\n      const target = await this.clickablePoint();\n      await page.mouse.dragOver(target, data);\n    }\n    /**\n     * @internal\n     */\n    async drop(dataOrElement = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      if ('items' in dataOrElement) {\n        await this.scrollIntoViewIfNeeded();\n        const destination = await this.clickablePoint();\n        await page.mouse.drop(destination, dataOrElement);\n      } else {\n        // Note if the rest errors, we still want dragging off because the errors\n        // is most likely something implying the mouse is no longer dragging.\n        await dataOrElement.drag(this);\n        page._isDragging = false;\n        await page.mouse.up();\n      }\n    }\n    /**\n     * @deprecated Use `ElementHandle.drop` instead.\n     */\n    async dragAndDrop(target, options) {\n      const page = this.frame.page();\n      assert(page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');\n      await this.scrollIntoViewIfNeeded();\n      const startPoint = await this.clickablePoint();\n      const targetPoint = await target.clickablePoint();\n      await page.mouse.dragAndDrop(startPoint, targetPoint, options);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     *\n     * ```ts\n     * handle.select('blue'); // single selection\n     * handle.select('red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param values - Values of options to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     */\n    async select(...values) {\n      for (const value of values) {\n        assert(isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + typeof value + '\"');\n      }\n      return await this.evaluate((element, vals) => {\n        const values = new Set(vals);\n        if (!(element instanceof HTMLSelectElement)) {\n          throw new Error('Element is not a <select> element.');\n        }\n        const selectedValues = new Set();\n        if (!element.multiple) {\n          for (const option of element.options) {\n            option.selected = false;\n          }\n          for (const option of element.options) {\n            if (values.has(option.value)) {\n              option.selected = true;\n              selectedValues.add(option.value);\n              break;\n            }\n          }\n        } else {\n          for (const option of element.options) {\n            option.selected = values.has(option.value);\n            if (option.selected) {\n              selectedValues.add(option.value);\n            }\n          }\n        }\n        element.dispatchEvent(new Event('input', {\n          bubbles: true\n        }));\n        element.dispatchEvent(new Event('change', {\n          bubbles: true\n        }));\n        return [...selectedValues.values()];\n      }, values);\n    }\n    /**\n     * This method scrolls element into view if needed, and then uses\n     * {@link Touchscreen.tap} to tap in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async tap() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.tap(x, y);\n    }\n    async touchStart() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.touchStart(x, y);\n    }\n    async touchMove() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.touchMove(x, y);\n    }\n    async touchEnd() {\n      await this.scrollIntoViewIfNeeded();\n      await this.frame.page().touchscreen.touchEnd();\n    }\n    /**\n     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n     */\n    async focus() {\n      await this.evaluate(element => {\n        if (!(element instanceof HTMLElement)) {\n          throw new Error('Cannot focus non-HTMLElement');\n        }\n        return element.focus();\n      });\n    }\n    /**\n     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n     * `keyup` event for each character in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`,\n     * use {@link ElementHandle.press}.\n     *\n     * @example\n     *\n     * ```ts\n     * await elementHandle.type('Hello'); // Types instantly\n     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @example\n     * An example of typing into a text field and then submitting the form:\n     *\n     * ```ts\n     * const elementHandle = await page.$('input');\n     * await elementHandle.type('some text');\n     * await elementHandle.press('Enter');\n     * ```\n     *\n     * @param options - Delay in milliseconds. Defaults to 0.\n     */\n    async type(text, options) {\n      await this.focus();\n      await this.frame.page().keyboard.type(text, options);\n    }\n    /**\n     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n     *\n     * @remarks\n     * If `key` is a single character and no modifier keys besides `Shift`\n     * are being held down, a `keypress`/`input` event will also be generated.\n     * The `text` option can be specified to force an input event to be generated.\n     *\n     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n     * will type the text in upper case.\n     *\n     * @param key - Name of key to press, such as `ArrowLeft`.\n     * See {@link KeyInput} for a list of all key names.\n     */\n    async press(key, options) {\n      await this.focus();\n      await this.frame.page().keyboard.press(key, options);\n    }\n    async #clickableBox() {\n      const boxes = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        return [...element.getClientRects()].map(rect => {\n          return {\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n          };\n        });\n      });\n      if (!boxes?.length) {\n        return null;\n      }\n      await this.#intersectBoundingBoxesWithFrame(boxes);\n      let frame = this.frame;\n      let parentFrame;\n      while (parentFrame = frame?.parentFrame()) {\n        const env_4 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_4, await frame.frameElement(), false);\n          if (!handle) {\n            throw new Error('Unsupported frame type');\n          }\n          const parentBox = await handle.evaluate(element => {\n            // Element is not visible.\n            if (element.getClientRects().length === 0) {\n              return null;\n            }\n            const rect = element.getBoundingClientRect();\n            const style = window.getComputedStyle(element);\n            return {\n              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),\n              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)\n            };\n          });\n          if (!parentBox) {\n            return null;\n          }\n          for (const box of boxes) {\n            box.x += parentBox.left;\n            box.y += parentBox.top;\n          }\n          await handle.#intersectBoundingBoxesWithFrame(boxes);\n          frame = parentFrame;\n        } catch (e_4) {\n          env_4.error = e_4;\n          env_4.hasError = true;\n        } finally {\n          __disposeResources(env_4);\n        }\n      }\n      const box = boxes.find(box => {\n        return box.width >= 1 && box.height >= 1;\n      });\n      if (!box) {\n        return null;\n      }\n      return {\n        x: box.x,\n        y: box.y,\n        height: box.height,\n        width: box.width\n      };\n    }\n    async #intersectBoundingBoxesWithFrame(boxes) {\n      const {\n        documentWidth,\n        documentHeight\n      } = await this.frame.isolatedRealm().evaluate(() => {\n        return {\n          documentWidth: document.documentElement.clientWidth,\n          documentHeight: document.documentElement.clientHeight\n        };\n      });\n      for (const box of boxes) {\n        intersectBoundingBox(box, documentWidth, documentHeight);\n      }\n    }\n    /**\n     * This method returns the bounding box of the element (relative to the main frame),\n     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n     * (example: `display: none`).\n     */\n    async boundingBox() {\n      const box = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        return {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      });\n      if (!box) {\n        return null;\n      }\n      const offset = await this.#getTopLeftCornerOfFrame();\n      if (!offset) {\n        return null;\n      }\n      return {\n        x: box.x + offset.x,\n        y: box.y + offset.y,\n        height: box.height,\n        width: box.width\n      };\n    }\n    /**\n     * This method returns boxes of the element,\n     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n     * (example: `display: none`).\n     *\n     * @remarks\n     *\n     * Boxes are represented as an array of points;\n     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n     */\n    async boxModel() {\n      const model = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        const offsets = {\n          padding: {\n            left: parseInt(style.paddingLeft, 10),\n            top: parseInt(style.paddingTop, 10),\n            right: parseInt(style.paddingRight, 10),\n            bottom: parseInt(style.paddingBottom, 10)\n          },\n          margin: {\n            left: -parseInt(style.marginLeft, 10),\n            top: -parseInt(style.marginTop, 10),\n            right: -parseInt(style.marginRight, 10),\n            bottom: -parseInt(style.marginBottom, 10)\n          },\n          border: {\n            left: parseInt(style.borderLeft, 10),\n            top: parseInt(style.borderTop, 10),\n            right: parseInt(style.borderRight, 10),\n            bottom: parseInt(style.borderBottom, 10)\n          }\n        };\n        const border = [{\n          x: rect.left,\n          y: rect.top\n        }, {\n          x: rect.left + rect.width,\n          y: rect.top\n        }, {\n          x: rect.left + rect.width,\n          y: rect.top + rect.bottom\n        }, {\n          x: rect.left,\n          y: rect.top + rect.bottom\n        }];\n        const padding = transformQuadWithOffsets(border, offsets.border);\n        const content = transformQuadWithOffsets(padding, offsets.padding);\n        const margin = transformQuadWithOffsets(border, offsets.margin);\n        return {\n          content,\n          padding,\n          border,\n          margin,\n          width: rect.width,\n          height: rect.height\n        };\n        function transformQuadWithOffsets(quad, offsets) {\n          return [{\n            x: quad[0].x + offsets.left,\n            y: quad[0].y + offsets.top\n          }, {\n            x: quad[1].x - offsets.right,\n            y: quad[1].y + offsets.top\n          }, {\n            x: quad[2].x - offsets.right,\n            y: quad[2].y - offsets.bottom\n          }, {\n            x: quad[3].x + offsets.left,\n            y: quad[3].y - offsets.bottom\n          }];\n        }\n      });\n      if (!model) {\n        return null;\n      }\n      const offset = await this.#getTopLeftCornerOfFrame();\n      if (!offset) {\n        return null;\n      }\n      for (const attribute of ['content', 'padding', 'border', 'margin']) {\n        for (const point of model[attribute]) {\n          point.x += offset.x;\n          point.y += offset.y;\n        }\n      }\n      return model;\n    }\n    async #getTopLeftCornerOfFrame() {\n      const point = {\n        x: 0,\n        y: 0\n      };\n      let frame = this.frame;\n      let parentFrame;\n      while (parentFrame = frame?.parentFrame()) {\n        const env_5 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_5, await frame.frameElement(), false);\n          if (!handle) {\n            throw new Error('Unsupported frame type');\n          }\n          const parentBox = await handle.evaluate(element => {\n            // Element is not visible.\n            if (element.getClientRects().length === 0) {\n              return null;\n            }\n            const rect = element.getBoundingClientRect();\n            const style = window.getComputedStyle(element);\n            return {\n              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),\n              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)\n            };\n          });\n          if (!parentBox) {\n            return null;\n          }\n          point.x += parentBox.left;\n          point.y += parentBox.top;\n          frame = parentFrame;\n        } catch (e_5) {\n          env_5.error = e_5;\n          env_5.hasError = true;\n        } finally {\n          __disposeResources(env_5);\n        }\n      }\n      return point;\n    }\n    async screenshot(options = {}) {\n      const {\n        scrollIntoView = true\n      } = options;\n      let clip = await this.#nonEmptyVisibleBoundingBox();\n      const page = this.frame.page();\n      // Only scroll the element into view if the user wants it.\n      if (scrollIntoView) {\n        await this.scrollIntoViewIfNeeded();\n        // We measure again just in case.\n        clip = await this.#nonEmptyVisibleBoundingBox();\n      }\n      const [pageLeft, pageTop] = await this.evaluate(() => {\n        if (!window.visualViewport) {\n          throw new Error('window.visualViewport is not supported.');\n        }\n        return [window.visualViewport.pageLeft, window.visualViewport.pageTop];\n      });\n      clip.x += pageLeft;\n      clip.y += pageTop;\n      return await page.screenshot({\n        ...options,\n        clip\n      });\n    }\n    async #nonEmptyVisibleBoundingBox() {\n      const box = await this.boundingBox();\n      assert(box, 'Node is either not visible or not an HTMLElement');\n      assert(box.width !== 0, 'Node has 0 width.');\n      assert(box.height !== 0, 'Node has 0 height.');\n      return box;\n    }\n    /**\n     * @internal\n     */\n    async assertConnectedElement() {\n      const error = await this.evaluate(async element => {\n        if (!element.isConnected) {\n          return 'Node is detached from document';\n        }\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n          return 'Node is not of type HTMLElement';\n        }\n        return;\n      });\n      if (error) {\n        throw new Error(error);\n      }\n    }\n    /**\n     * @internal\n     */\n    async scrollIntoViewIfNeeded() {\n      if (await this.isIntersectingViewport({\n        threshold: 1\n      })) {\n        return;\n      }\n      await this.scrollIntoView();\n    }\n    /**\n     * Resolves to true if the element is visible in the current viewport. If an\n     * element is an SVG, we check if the svg owner element is in the viewport\n     * instead. See https://crbug.com/963246.\n     *\n     * @param options - Threshold for the intersection between 0 (no intersection) and 1\n     * (full intersection). Defaults to 1.\n     */\n    async isIntersectingViewport(options = {}) {\n      const env_6 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        await this.assertConnectedElement();\n        // eslint-disable-next-line rulesdir/use-using -- Returns `this`.\n        const handle = await this.#asSVGElementHandle();\n        const target = __addDisposableResource(env_6, handle && (await handle.#getOwnerSVGElement()), false);\n        return await (target ?? this).evaluate(async (element, threshold) => {\n          const visibleRatio = await new Promise(resolve => {\n            const observer = new IntersectionObserver(entries => {\n              resolve(entries[0].intersectionRatio);\n              observer.disconnect();\n            });\n            observer.observe(element);\n          });\n          return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n        }, options.threshold ?? 0);\n      } catch (e_6) {\n        env_6.error = e_6;\n        env_6.hasError = true;\n      } finally {\n        __disposeResources(env_6);\n      }\n    }\n    /**\n     * Scrolls the element into view using either the automation protocol client\n     * or by calling element.scrollIntoView.\n     */\n    async scrollIntoView() {\n      await this.assertConnectedElement();\n      await this.evaluate(async element => {\n        element.scrollIntoView({\n          block: 'center',\n          inline: 'center',\n          behavior: 'instant'\n        });\n      });\n    }\n    /**\n     * Returns true if an element is an SVGElement (included svg, path, rect\n     * etc.).\n     */\n    async #asSVGElementHandle() {\n      if (await this.evaluate(element => {\n        return element instanceof SVGElement;\n      })) {\n        return this;\n      } else {\n        return null;\n      }\n    }\n    async #getOwnerSVGElement() {\n      // SVGSVGElement.ownerSVGElement === null.\n      return await this.evaluateHandle(element => {\n        if (element instanceof SVGSVGElement) {\n          return element;\n        }\n        return element.ownerSVGElement;\n      });\n    }\n  };\n})();\nexport { ElementHandle };\nfunction intersectBoundingBox(box, width, height) {\n  box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);\n  box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);\n}","map":{"version":3,"names":["getQueryHandlerAndSelector","LazyArg","isString","withSourcePuppeteerURLIfNone","assert","AsyncIterableUtil","throwIfDisposed","_isElementHandle","JSHandle","ElementHandle","_classSuper","_a","bindIsolatedHandle","bind","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","_u","_v","_w","_x","_y","_z","_0","_1","_2","_3","_4","_5","__esDecorate","_getProperty_decorators","kind","name","static","private","access","has","obj","get","getProperty","metadata","_metadata","_instanceExtraInitializers","_getProperties_decorators","getProperties","_jsonValue_decorators","jsonValue","_$_decorators","$","_$$_decorators","$$","_waitForSelector_decorators","waitForSelector","_isVisible_decorators","isVisible","_isHidden_decorators","isHidden","_toElement_decorators","toElement","_clickablePoint_decorators","clickablePoint","_hover_decorators","hover","_click_decorators","click","_drag_decorators","drag","_dragEnter_decorators","dragEnter","_dragOver_decorators","dragOver","_drop_decorators","drop","_dragAndDrop_decorators","dragAndDrop","_select_decorators","select","_tap_decorators","tap","_touchStart_decorators","touchStart","_touchMove_decorators","touchMove","_touchEnd_decorators","touchEnd","_focus_decorators","focus","_type_decorators","type","_press_decorators","press","_boundingBox_decorators","boundingBox","_boxModel_decorators","boxModel","_screenshot_decorators","screenshot","_isIntersectingViewport_decorators","isIntersectingViewport","_scrollIntoView_decorators","scrollIntoView","target","_","args","realm","frame","isolatedRealm","call","adoptedThis","__addDisposableResource","env_1","adoptHandle","result","transferHandle","Array","isArray","Promise","all","map","item","index","Map","entries","key","value","set","handle","__runInitializers","constructor","id","disposed","propertyName","evaluate","pageFunction","evaluateHandle","toString","remoteObject","dispose","asElement","selector","updatedSelector","QueryHandler","queryOne","collect","queryAll","$eval","elementHandle","env_2","Error","$$eval","results","elements","env_3","options","waitFor","checkVisibility","#checkVisibility","visibility","element","PuppeteerUtil","Boolean","create","context","puppeteerUtil","tagName","isMatchingTagName","node","nodeName","toUpperCase","offset","box","clickableBox","undefined","x","y","width","height","scrollIntoViewIfNeeded","page","mouse","move","isDragInterceptionEnabled","source","_isDragging","down","error","data","items","dragOperationsMask","dataOrElement","destination","up","startPoint","targetPoint","values","vals","Set","HTMLSelectElement","selectedValues","multiple","option","selected","add","dispatchEvent","Event","bubbles","touchscreen","HTMLElement","text","keyboard","#clickableBox","boxes","Element","getClientRects","rect","length","intersectBoundingBoxesWithFrame","parentFrame","env_4","frameElement","parentBox","getBoundingClientRect","style","window","getComputedStyle","left","parseInt","paddingLeft","borderLeftWidth","top","paddingTop","borderTopWidth","find","#intersectBoundingBoxesWithFrame","documentWidth","documentHeight","document","documentElement","clientWidth","clientHeight","intersectBoundingBox","getTopLeftCornerOfFrame","model","offsets","padding","right","paddingRight","bottom","paddingBottom","margin","marginLeft","marginTop","marginRight","marginBottom","border","borderLeft","borderTop","borderRight","borderBottom","transformQuadWithOffsets","content","quad","attribute","point","#getTopLeftCornerOfFrame","env_5","clip","nonEmptyVisibleBoundingBox","pageLeft","pageTop","visualViewport","#nonEmptyVisibleBoundingBox","assertConnectedElement","isConnected","nodeType","Node","ELEMENT_NODE","threshold","asSVGElementHandle","env_6","getOwnerSVGElement","visibleRatio","resolve","observer","IntersectionObserver","intersectionRatio","disconnect","observe","block","inline","behavior","#asSVGElementHandle","SVGElement","#getOwnerSVGElement","SVGSVGElement","ownerSVGElement","Math","max","min"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/puppeteer-core/src/api/ElementHandle.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {Frame} from '../api/Frame.js';\nimport {getQueryHandlerAndSelector} from '../common/GetQueryHandler.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport type {\n  ElementFor,\n  EvaluateFuncWith,\n  HandleFor,\n  HandleOr,\n  NodeFor,\n} from '../common/types.js';\nimport type {KeyInput} from '../common/USKeyboardLayout.js';\nimport {isString, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\nimport {throwIfDisposed} from '../util/decorators.js';\n\nimport {_isElementHandle} from './ElementHandleSymbol.js';\nimport type {\n  KeyboardTypeOptions,\n  KeyPressOptions,\n  MouseClickOptions,\n} from './Input.js';\nimport {JSHandle} from './JSHandle.js';\nimport type {ScreenshotOptions, WaitForSelectorOptions} from './Page.js';\n\n/**\n * @public\n */\nexport type Quad = [Point, Point, Point, Point];\n\n/**\n * @public\n */\nexport interface BoxModel {\n  content: Quad;\n  padding: Quad;\n  border: Quad;\n  margin: Quad;\n  width: number;\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface BoundingBox extends Point {\n  /**\n   * the width of the element in pixels.\n   */\n  width: number;\n  /**\n   * the height of the element in pixels.\n   */\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface Offset {\n  /**\n   * x-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  x: number;\n  /**\n   * y-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ClickOptions extends MouseClickOptions {\n  /**\n   * Offset for the clickable point relative to the top-left corner of the border box.\n   */\n  offset?: Offset;\n}\n\n/**\n * @public\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ElementScreenshotOptions extends ScreenshotOptions {\n  /**\n   * @defaultValue `true`\n   */\n  scrollIntoView?: boolean;\n}\n\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nexport abstract class ElementHandle<\n  ElementType extends Node = Element,\n> extends JSHandle<ElementType> {\n  /**\n   * @internal\n   */\n  declare [_isElementHandle]: boolean;\n\n  /**\n   * A given method will have it's `this` replaced with an isolated version of\n   * `this` when decorated with this decorator.\n   *\n   * All changes of isolated `this` are reflected on the actual `this`.\n   *\n   * @internal\n   */\n  static bindIsolatedHandle<This extends ElementHandle<Node>>(\n    target: (this: This, ...args: any[]) => Promise<any>,\n    _: unknown\n  ): typeof target {\n    return async function (...args) {\n      // If the handle is already isolated, then we don't need to adopt it\n      // again.\n      if (this.realm === this.frame.isolatedRealm()) {\n        return await target.call(this, ...args);\n      }\n      using adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);\n      const result = await target.call(adoptedThis, ...args);\n      // If the function returns `adoptedThis`, then we return `this`.\n      if (result === adoptedThis) {\n        return this;\n      }\n      // If the function returns a handle, transfer it into the current realm.\n      if (result instanceof JSHandle) {\n        return await this.realm.transferHandle(result);\n      }\n      // If the function returns an array of handlers, transfer them into the\n      // current realm.\n      if (Array.isArray(result)) {\n        await Promise.all(\n          result.map(async (item, index, result) => {\n            if (item instanceof JSHandle) {\n              result[index] = await this.realm.transferHandle(item);\n            }\n          })\n        );\n      }\n      if (result instanceof Map) {\n        await Promise.all(\n          [...result.entries()].map(async ([key, value]) => {\n            if (value instanceof JSHandle) {\n              result.set(key, await this.realm.transferHandle(value));\n            }\n          })\n        );\n      }\n      return result;\n    };\n  }\n\n  /**\n   * @internal\n   */\n  protected readonly handle;\n\n  /**\n   * @internal\n   */\n  constructor(handle: JSHandle<ElementType>) {\n    super();\n    this.handle = handle;\n    this[_isElementHandle] = true;\n  }\n\n  /**\n   * @internal\n   */\n  override get id(): string | undefined {\n    return this.handle.id;\n  }\n\n  /**\n   * @internal\n   */\n  override get disposed(): boolean {\n    return this.handle.disposed;\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async getProperty<K extends keyof ElementType>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<ElementType[K]>> {\n    return await this.handle.getProperty(propertyName);\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async getProperties(): Promise<Map<string, JSHandle>> {\n    return await this.handle.getProperties();\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.handle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.handle.evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async jsonValue(): Promise<ElementType> {\n    return await this.handle.jsonValue();\n  }\n\n  /**\n   * @internal\n   */\n  override toString(): string {\n    return this.handle.toString();\n  }\n\n  /**\n   * @internal\n   */\n  override remoteObject(): Protocol.Runtime.RemoteObject {\n    return this.handle.remoteObject();\n  }\n\n  /**\n   * @internal\n   */\n  override dispose(): Promise<void> {\n    return this.handle.dispose();\n  }\n\n  /**\n   * @internal\n   */\n  override asElement(): ElementHandle<ElementType> {\n    return this;\n  }\n\n  /**\n   * Frame corresponding to the current handle.\n   */\n  abstract get frame(): Frame;\n\n  /**\n   * Queries the current element for an element matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.queryOne(\n      this,\n      updatedSelector\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  /**\n   * Queries the current element for all elements matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return await (AsyncIterableUtil.collect(\n      QueryHandler.queryAll(this, updatedSelector)\n    ) as Promise<Array<ElementHandle<NodeFor<Selector>>>>);\n  }\n\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const tweetHandle = await page.$('.tweet');\n   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n   *   '100'\n   * );\n   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n   *   '10'\n   * );\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in this element's page's\n   * context. The first element matching the selector will be passed in as the\n   * first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    using elementHandle = await this.$(selector);\n    if (!elementHandle) {\n      throw new Error(\n        `Error: failed to find element matching selector \"${selector}\"`\n      );\n    }\n    return await elementHandle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   * HTML:\n   *\n   * ```html\n   * <div class=\"feed\">\n   *   <div class=\"tweet\">Hello!</div>\n   *   <div class=\"tweet\">Hi!</div>\n   * </div>\n   * ```\n   *\n   * JavaScript:\n   *\n   * ```ts\n   * const feedHandle = await page.$('.feed');\n   * expect(\n   *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))\n   * ).toEqual(['Hello!', 'Hi!']);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in the element's page's\n   * context. An array of elements matching the given selector will be passed to\n   * the function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    const results = await this.$$(selector);\n    using elements = await this.evaluateHandle(\n      (_, ...elements) => {\n        return elements;\n      },\n      ...results\n    );\n    const [result] = await Promise.all([\n      elements.evaluate(pageFunction, ...args),\n      ...results.map(results => {\n        return results.dispose();\n      }),\n    ]);\n    return result;\n  }\n\n  /**\n   * Wait for an element matching the given selector to appear in the current\n   * element.\n   *\n   * Unlike {@link Frame.waitForSelector}, this method does not work across\n   * navigations or if the element is detached from DOM.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.waitFor(\n      this,\n      updatedSelector,\n      options\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  async #checkVisibility(visibility: boolean): Promise<boolean> {\n    return await this.evaluate(\n      async (element, PuppeteerUtil, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      },\n      LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }),\n      visibility\n    );\n  }\n\n  /**\n   * Checks if an element is visible using the same mechanism as\n   * {@link ElementHandle.waitForSelector}.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isVisible(): Promise<boolean> {\n    return await this.#checkVisibility(true);\n  }\n\n  /**\n   * Checks if an element is hidden using the same mechanism as\n   * {@link ElementHandle.waitForSelector}.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isHidden(): Promise<boolean> {\n    return await this.#checkVisibility(false);\n  }\n\n  /**\n   * Converts the current handle to the given element type.\n   *\n   * @example\n   *\n   * ```ts\n   * const element: ElementHandle<Element> = await page.$(\n   *   '.class-name-of-anchor'\n   * );\n   * // DO NOT DISPOSE `element`, this will be always be the same handle.\n   * const anchor: ElementHandle<HTMLAnchorElement> =\n   *   await element.toElement('a');\n   * ```\n   *\n   * @param tagName - The tag name of the desired element type.\n   * @throws An error if the handle does not match. **The handle will not be\n   * automatically disposed.**\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async toElement<\n    K extends keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap,\n  >(tagName: K): Promise<HandleFor<ElementFor<K>>> {\n    const isMatchingTagName = await this.evaluate((node, tagName) => {\n      return node.nodeName === tagName.toUpperCase();\n    }, tagName);\n    if (!isMatchingTagName) {\n      throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n    }\n    return this as unknown as HandleFor<ElementFor<K>>;\n  }\n\n  /**\n   * Resolves the frame associated with the element, if any. Always exists for\n   * HTMLIFrameElements.\n   */\n  abstract contentFrame(this: ElementHandle<HTMLIFrameElement>): Promise<Frame>;\n  abstract contentFrame(): Promise<Frame | null>;\n\n  /**\n   * Returns the middle point within an element unless a specific offset is provided.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async clickablePoint(offset?: Offset): Promise<Point> {\n    const box = await this.#clickableBox();\n    if (!box) {\n      throw new Error('Node is either not clickable or not an Element');\n    }\n    if (offset !== undefined) {\n      return {\n        x: box.x + offset.x,\n        y: box.y + offset.y,\n      };\n    }\n    return {\n      x: box.x + box.width / 2,\n      y: box.y + box.height / 2,\n    };\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async hover(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().mouse.move(x, y);\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page | Page.mouse} to click in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async click(\n    this: ElementHandle<Element>,\n    options: Readonly<ClickOptions> = {}\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint(options.offset);\n    await this.frame.page().mouse.click(x, y, options);\n  }\n\n  /**\n   * Drags an element over the given element or point.\n   *\n   * @returns DEPRECATED. When drag interception is enabled, the drag payload is\n   * returned.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async drag(\n    this: ElementHandle<Element>,\n    target: Point | ElementHandle<Element>\n  ): Promise<Protocol.Input.DragData | void> {\n    await this.scrollIntoViewIfNeeded();\n    const page = this.frame.page();\n    if (page.isDragInterceptionEnabled()) {\n      const source = await this.clickablePoint();\n      if (target instanceof ElementHandle) {\n        target = await target.clickablePoint();\n      }\n      return await page.mouse.drag(source, target);\n    }\n    try {\n      if (!page._isDragging) {\n        page._isDragging = true;\n        await this.hover();\n        await page.mouse.down();\n      }\n      if (target instanceof ElementHandle) {\n        await target.hover();\n      } else {\n        await page.mouse.move(target.x, target.y);\n      }\n    } catch (error) {\n      page._isDragging = false;\n      throw error;\n    }\n  }\n\n  /**\n   * @deprecated Do not use. `dragenter` will automatically be performed during dragging.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragEnter(\n    this: ElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    const page = this.frame.page();\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await page.mouse.dragEnter(target, data);\n  }\n\n  /**\n   * @deprecated Do not use. `dragover` will automatically be performed during dragging.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragOver(\n    this: ElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    const page = this.frame.page();\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await page.mouse.dragOver(target, data);\n  }\n\n  /**\n   * Drops the given element onto the current one.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    element: ElementHandle<Element>\n  ): Promise<void>;\n\n  /**\n   * @deprecated No longer supported.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    data?: Protocol.Input.DragData\n  ): Promise<void>;\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async drop(\n    this: ElementHandle<Element>,\n    dataOrElement: ElementHandle<Element> | Protocol.Input.DragData = {\n      items: [],\n      dragOperationsMask: 1,\n    }\n  ): Promise<void> {\n    const page = this.frame.page();\n    if ('items' in dataOrElement) {\n      await this.scrollIntoViewIfNeeded();\n      const destination = await this.clickablePoint();\n      await page.mouse.drop(destination, dataOrElement);\n    } else {\n      // Note if the rest errors, we still want dragging off because the errors\n      // is most likely something implying the mouse is no longer dragging.\n      await dataOrElement.drag(this);\n      page._isDragging = false;\n      await page.mouse.up();\n    }\n  }\n\n  /**\n   * @deprecated Use `ElementHandle.drop` instead.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragAndDrop(\n    this: ElementHandle<Element>,\n    target: ElementHandle<Node>,\n    options?: {delay: number}\n  ): Promise<void> {\n    const page = this.frame.page();\n    assert(\n      page.isDragInterceptionEnabled(),\n      'Drag Interception is not enabled!'\n    );\n    await this.scrollIntoViewIfNeeded();\n    const startPoint = await this.clickablePoint();\n    const targetPoint = await target.clickablePoint();\n    await page.mouse.dragAndDrop(startPoint, targetPoint, options);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * handle.select('blue'); // single selection\n   * handle.select('red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async select(...values: string[]): Promise<string[]> {\n    for (const value of values) {\n      assert(\n        isString(value),\n        'Values must be strings. Found value \"' +\n          value +\n          '\" of type \"' +\n          typeof value +\n          '\"'\n      );\n    }\n\n    return await this.evaluate((element, vals): string[] => {\n      const values = new Set(vals);\n      if (!(element instanceof HTMLSelectElement)) {\n        throw new Error('Element is not a <select> element.');\n      }\n\n      const selectedValues = new Set<string>();\n      if (!element.multiple) {\n        for (const option of element.options) {\n          option.selected = false;\n        }\n        for (const option of element.options) {\n          if (values.has(option.value)) {\n            option.selected = true;\n            selectedValues.add(option.value);\n            break;\n          }\n        }\n      } else {\n        for (const option of element.options) {\n          option.selected = values.has(option.value);\n          if (option.selected) {\n            selectedValues.add(option.value);\n          }\n        }\n      }\n      element.dispatchEvent(new Event('input', {bubbles: true}));\n      element.dispatchEvent(new Event('change', {bubbles: true}));\n      return [...selectedValues.values()];\n    }, values);\n  }\n\n  /**\n   * Sets the value of an\n   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}\n   * to the given file paths.\n   *\n   * @remarks This will not validate whether the file paths exists. Also, if a\n   * path is relative, then it is resolved against the\n   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.\n   * For locals script connecting to remote chrome environments, paths must be\n   * absolute.\n   */\n  abstract uploadFile(\n    this: ElementHandle<HTMLInputElement>,\n    ...paths: string[]\n  ): Promise<void>;\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Touchscreen.tap} to tap in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async tap(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.tap(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchStart(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.touchStart(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchMove(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.touchMove(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchEnd(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    await this.frame.page().touchscreen.touchEnd();\n  }\n\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async focus(): Promise<void> {\n    await this.evaluate(element => {\n      if (!(element instanceof HTMLElement)) {\n        throw new Error('Cannot focus non-HTMLElement');\n      }\n      return element.focus();\n    });\n  }\n\n  /**\n   * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n   * `keyup` event for each character in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`,\n   * use {@link ElementHandle.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await elementHandle.type('Hello'); // Types instantly\n   * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @example\n   * An example of typing into a text field and then submitting the form:\n   *\n   * ```ts\n   * const elementHandle = await page.$('input');\n   * await elementHandle.type('some text');\n   * await elementHandle.press('Enter');\n   * ```\n   *\n   * @param options - Delay in milliseconds. Defaults to 0.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async type(\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    await this.focus();\n    await this.frame.page().keyboard.type(text, options);\n  }\n\n  /**\n   * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n   *\n   * @remarks\n   * If `key` is a single character and no modifier keys besides `Shift`\n   * are being held down, a `keypress`/`input` event will also be generated.\n   * The `text` option can be specified to force an input event to be generated.\n   *\n   * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n   * will type the text in upper case.\n   *\n   * @param key - Name of key to press, such as `ArrowLeft`.\n   * See {@link KeyInput} for a list of all key names.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async press(\n    key: KeyInput,\n    options?: Readonly<KeyPressOptions>\n  ): Promise<void> {\n    await this.focus();\n    await this.frame.page().keyboard.press(key, options);\n  }\n\n  async #clickableBox(): Promise<BoundingBox | null> {\n    const boxes = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      return [...element.getClientRects()].map(rect => {\n        return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n      });\n    });\n    if (!boxes?.length) {\n      return null;\n    }\n    await this.#intersectBoundingBoxesWithFrame(boxes);\n    let frame = this.frame;\n    let parentFrame: Frame | null | undefined;\n    while ((parentFrame = frame?.parentFrame())) {\n      using handle = await frame.frameElement();\n      if (!handle) {\n        throw new Error('Unsupported frame type');\n      }\n      const parentBox = await handle.evaluate(element => {\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return {\n          left:\n            rect.left +\n            parseInt(style.paddingLeft, 10) +\n            parseInt(style.borderLeftWidth, 10),\n          top:\n            rect.top +\n            parseInt(style.paddingTop, 10) +\n            parseInt(style.borderTopWidth, 10),\n        };\n      });\n      if (!parentBox) {\n        return null;\n      }\n      for (const box of boxes) {\n        box.x += parentBox.left;\n        box.y += parentBox.top;\n      }\n      await handle.#intersectBoundingBoxesWithFrame(boxes);\n      frame = parentFrame;\n    }\n    const box = boxes.find(box => {\n      return box.width >= 1 && box.height >= 1;\n    });\n    if (!box) {\n      return null;\n    }\n    return {\n      x: box.x,\n      y: box.y,\n      height: box.height,\n      width: box.width,\n    };\n  }\n\n  async #intersectBoundingBoxesWithFrame(boxes: BoundingBox[]) {\n    const {documentWidth, documentHeight} = await this.frame\n      .isolatedRealm()\n      .evaluate(() => {\n        return {\n          documentWidth: document.documentElement.clientWidth,\n          documentHeight: document.documentElement.clientHeight,\n        };\n      });\n    for (const box of boxes) {\n      intersectBoundingBox(box, documentWidth, documentHeight);\n    }\n  }\n\n  /**\n   * This method returns the bounding box of the element (relative to the main frame),\n   * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n   * (example: `display: none`).\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async boundingBox(): Promise<BoundingBox | null> {\n    const box = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      // Element is not visible.\n      if (element.getClientRects().length === 0) {\n        return null;\n      }\n      const rect = element.getBoundingClientRect();\n      return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n    });\n    if (!box) {\n      return null;\n    }\n    const offset = await this.#getTopLeftCornerOfFrame();\n    if (!offset) {\n      return null;\n    }\n    return {\n      x: box.x + offset.x,\n      y: box.y + offset.y,\n      height: box.height,\n      width: box.width,\n    };\n  }\n\n  /**\n   * This method returns boxes of the element,\n   * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n   * (example: `display: none`).\n   *\n   * @remarks\n   *\n   * Boxes are represented as an array of points;\n   * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async boxModel(): Promise<BoxModel | null> {\n    const model = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      // Element is not visible.\n      if (element.getClientRects().length === 0) {\n        return null;\n      }\n      const rect = element.getBoundingClientRect();\n      const style = window.getComputedStyle(element);\n      const offsets = {\n        padding: {\n          left: parseInt(style.paddingLeft, 10),\n          top: parseInt(style.paddingTop, 10),\n          right: parseInt(style.paddingRight, 10),\n          bottom: parseInt(style.paddingBottom, 10),\n        },\n        margin: {\n          left: -parseInt(style.marginLeft, 10),\n          top: -parseInt(style.marginTop, 10),\n          right: -parseInt(style.marginRight, 10),\n          bottom: -parseInt(style.marginBottom, 10),\n        },\n        border: {\n          left: parseInt(style.borderLeft, 10),\n          top: parseInt(style.borderTop, 10),\n          right: parseInt(style.borderRight, 10),\n          bottom: parseInt(style.borderBottom, 10),\n        },\n      };\n      const border: Quad = [\n        {x: rect.left, y: rect.top},\n        {x: rect.left + rect.width, y: rect.top},\n        {x: rect.left + rect.width, y: rect.top + rect.bottom},\n        {x: rect.left, y: rect.top + rect.bottom},\n      ];\n      const padding = transformQuadWithOffsets(border, offsets.border);\n      const content = transformQuadWithOffsets(padding, offsets.padding);\n      const margin = transformQuadWithOffsets(border, offsets.margin);\n      return {\n        content,\n        padding,\n        border,\n        margin,\n        width: rect.width,\n        height: rect.height,\n      };\n\n      function transformQuadWithOffsets(\n        quad: Quad,\n        offsets: {top: number; left: number; right: number; bottom: number}\n      ): Quad {\n        return [\n          {\n            x: quad[0].x + offsets.left,\n            y: quad[0].y + offsets.top,\n          },\n          {\n            x: quad[1].x - offsets.right,\n            y: quad[1].y + offsets.top,\n          },\n          {\n            x: quad[2].x - offsets.right,\n            y: quad[2].y - offsets.bottom,\n          },\n          {\n            x: quad[3].x + offsets.left,\n            y: quad[3].y - offsets.bottom,\n          },\n        ];\n      }\n    });\n    if (!model) {\n      return null;\n    }\n    const offset = await this.#getTopLeftCornerOfFrame();\n    if (!offset) {\n      return null;\n    }\n    for (const attribute of [\n      'content',\n      'padding',\n      'border',\n      'margin',\n    ] as const) {\n      for (const point of model[attribute]) {\n        point.x += offset.x;\n        point.y += offset.y;\n      }\n    }\n    return model;\n  }\n\n  async #getTopLeftCornerOfFrame() {\n    const point = {x: 0, y: 0};\n    let frame = this.frame;\n    let parentFrame: Frame | null | undefined;\n    while ((parentFrame = frame?.parentFrame())) {\n      using handle = await frame.frameElement();\n      if (!handle) {\n        throw new Error('Unsupported frame type');\n      }\n      const parentBox = await handle.evaluate(element => {\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return {\n          left:\n            rect.left +\n            parseInt(style.paddingLeft, 10) +\n            parseInt(style.borderLeftWidth, 10),\n          top:\n            rect.top +\n            parseInt(style.paddingTop, 10) +\n            parseInt(style.borderTopWidth, 10),\n        };\n      });\n      if (!parentBox) {\n        return null;\n      }\n      point.x += parentBox.left;\n      point.y += parentBox.top;\n      frame = parentFrame;\n    }\n    return point;\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Page.(screenshot:2) } to take a screenshot of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async screenshot(\n    options: Readonly<ScreenshotOptions> & {encoding: 'base64'}\n  ): Promise<string>;\n  async screenshot(options?: Readonly<ScreenshotOptions>): Promise<Buffer>;\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async screenshot(\n    this: ElementHandle<Element>,\n    options: Readonly<ElementScreenshotOptions> = {}\n  ): Promise<string | Buffer> {\n    const {scrollIntoView = true} = options;\n\n    let clip = await this.#nonEmptyVisibleBoundingBox();\n\n    const page = this.frame.page();\n\n    // Only scroll the element into view if the user wants it.\n    if (scrollIntoView) {\n      await this.scrollIntoViewIfNeeded();\n\n      // We measure again just in case.\n      clip = await this.#nonEmptyVisibleBoundingBox();\n    }\n\n    const [pageLeft, pageTop] = await this.evaluate(() => {\n      if (!window.visualViewport) {\n        throw new Error('window.visualViewport is not supported.');\n      }\n      return [\n        window.visualViewport.pageLeft,\n        window.visualViewport.pageTop,\n      ] as const;\n    });\n    clip.x += pageLeft;\n    clip.y += pageTop;\n\n    return await page.screenshot({...options, clip});\n  }\n\n  async #nonEmptyVisibleBoundingBox() {\n    const box = await this.boundingBox();\n    assert(box, 'Node is either not visible or not an HTMLElement');\n    assert(box.width !== 0, 'Node has 0 width.');\n    assert(box.height !== 0, 'Node has 0 height.');\n    return box;\n  }\n\n  /**\n   * @internal\n   */\n  protected async assertConnectedElement(): Promise<void> {\n    const error = await this.evaluate(async element => {\n      if (!element.isConnected) {\n        return 'Node is detached from document';\n      }\n      if (element.nodeType !== Node.ELEMENT_NODE) {\n        return 'Node is not of type HTMLElement';\n      }\n      return;\n    });\n\n    if (error) {\n      throw new Error(error);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected async scrollIntoViewIfNeeded(\n    this: ElementHandle<Element>\n  ): Promise<void> {\n    if (\n      await this.isIntersectingViewport({\n        threshold: 1,\n      })\n    ) {\n      return;\n    }\n    await this.scrollIntoView();\n  }\n\n  /**\n   * Resolves to true if the element is visible in the current viewport. If an\n   * element is an SVG, we check if the svg owner element is in the viewport\n   * instead. See https://crbug.com/963246.\n   *\n   * @param options - Threshold for the intersection between 0 (no intersection) and 1\n   * (full intersection). Defaults to 1.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isIntersectingViewport(\n    this: ElementHandle<Element>,\n    options: {\n      threshold?: number;\n    } = {}\n  ): Promise<boolean> {\n    await this.assertConnectedElement();\n    // eslint-disable-next-line rulesdir/use-using -- Returns `this`.\n    const handle = await this.#asSVGElementHandle();\n    using target = handle && (await handle.#getOwnerSVGElement());\n    return await ((target ?? this) as ElementHandle<Element>).evaluate(\n      async (element, threshold) => {\n        const visibleRatio = await new Promise<number>(resolve => {\n          const observer = new IntersectionObserver(entries => {\n            resolve(entries[0]!.intersectionRatio);\n            observer.disconnect();\n          });\n          observer.observe(element);\n        });\n        return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n      },\n      options.threshold ?? 0\n    );\n  }\n\n  /**\n   * Scrolls the element into view using either the automation protocol client\n   * or by calling element.scrollIntoView.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async scrollIntoView(this: ElementHandle<Element>): Promise<void> {\n    await this.assertConnectedElement();\n    await this.evaluate(async (element): Promise<void> => {\n      element.scrollIntoView({\n        block: 'center',\n        inline: 'center',\n        behavior: 'instant',\n      });\n    });\n  }\n\n  /**\n   * Returns true if an element is an SVGElement (included svg, path, rect\n   * etc.).\n   */\n  async #asSVGElementHandle(\n    this: ElementHandle<Element>\n  ): Promise<ElementHandle<SVGElement> | null> {\n    if (\n      await this.evaluate(element => {\n        return element instanceof SVGElement;\n      })\n    ) {\n      return this as ElementHandle<SVGElement>;\n    } else {\n      return null;\n    }\n  }\n\n  async #getOwnerSVGElement(\n    this: ElementHandle<SVGElement>\n  ): Promise<ElementHandle<SVGSVGElement>> {\n    // SVGSVGElement.ownerSVGElement === null.\n    return await this.evaluateHandle(element => {\n      if (element instanceof SVGSVGElement) {\n        return element;\n      }\n      return element.ownerSVGElement!;\n    });\n  }\n\n  /**\n   * If the element is a form input, you can use {@link ElementHandle.autofill}\n   * to test if the form is compatible with the browser's autofill\n   * implementation. Throws an error if the form cannot be autofilled.\n   *\n   * @remarks\n   *\n   * Currently, Puppeteer supports auto-filling credit card information only and\n   * in Chrome in the new headless and headful modes only.\n   *\n   * ```ts\n   * // Select an input on the credit card form.\n   * const name = await page.waitForSelector('form #name');\n   * // Trigger autofill with the desired data.\n   * await name.autofill({\n   *   creditCard: {\n   *     number: '4444444444444444',\n   *     name: 'John Smith',\n   *     expiryMonth: '01',\n   *     expiryYear: '2030',\n   *     cvc: '123',\n   *   },\n   * });\n   * ```\n   */\n  abstract autofill(data: AutofillData): Promise<void>;\n}\n\n/**\n * @public\n */\nexport interface AutofillData {\n  creditCard: {\n    // See https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#type-CreditCard.\n    number: string;\n    name: string;\n    expiryMonth: string;\n    expiryYear: string;\n    cvc: string;\n  };\n}\n\nfunction intersectBoundingBox(\n  box: BoundingBox,\n  width: number,\n  height: number\n): void {\n  box.width = Math.max(\n    box.x >= 0\n      ? Math.min(width - box.x, box.width)\n      : Math.min(width, box.width + box.x),\n    0\n  );\n  box.height = Math.max(\n    box.y >= 0\n      ? Math.min(height - box.y, box.height)\n      : Math.min(height, box.height + box.y),\n    0\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}