{"ast":null,"code":"var Tokenizer = require('./tokenizer');\nvar TAB = 9;\nvar N = 10;\nvar F = 12;\nvar R = 13;\nvar SPACE = 32;\nvar EXCLAMATIONMARK = 33; // !\nvar NUMBERSIGN = 35; // #\nvar AMPERSAND = 38; // &\nvar APOSTROPHE = 39; // '\nvar LEFTPARENTHESIS = 40; // (\nvar RIGHTPARENTHESIS = 41; // )\nvar ASTERISK = 42; // *\nvar PLUSSIGN = 43; // +\nvar COMMA = 44; // ,\nvar HYPERMINUS = 45; // -\nvar LESSTHANSIGN = 60; // <\nvar GREATERTHANSIGN = 62; // >\nvar QUESTIONMARK = 63; // ?\nvar COMMERCIALAT = 64; // @\nvar LEFTSQUAREBRACKET = 91; // [\nvar RIGHTSQUAREBRACKET = 93; // ]\nvar LEFTCURLYBRACKET = 123; // {\nvar VERTICALLINE = 124; // |\nvar RIGHTCURLYBRACKET = 125; // }\nvar INFINITY = 8734; // ∞\nvar NAME_CHAR = createCharMap(function (ch) {\n  return /[a-zA-Z0-9\\-]/.test(ch);\n});\nvar COMBINATOR_PRECEDENCE = {\n  ' ': 1,\n  '&&': 2,\n  '||': 3,\n  '|': 4\n};\nfunction createCharMap(fn) {\n  var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);\n  for (var i = 0; i < 128; i++) {\n    array[i] = fn(String.fromCharCode(i)) ? 1 : 0;\n  }\n  return array;\n}\nfunction scanSpaces(tokenizer) {\n  return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));\n}\nfunction scanWord(tokenizer) {\n  var end = tokenizer.pos;\n  for (; end < tokenizer.str.length; end++) {\n    var code = tokenizer.str.charCodeAt(end);\n    if (code >= 128 || NAME_CHAR[code] === 0) {\n      break;\n    }\n  }\n  if (tokenizer.pos === end) {\n    tokenizer.error('Expect a keyword');\n  }\n  return tokenizer.substringToPos(end);\n}\nfunction scanNumber(tokenizer) {\n  var end = tokenizer.pos;\n  for (; end < tokenizer.str.length; end++) {\n    var code = tokenizer.str.charCodeAt(end);\n    if (code < 48 || code > 57) {\n      break;\n    }\n  }\n  if (tokenizer.pos === end) {\n    tokenizer.error('Expect a number');\n  }\n  return tokenizer.substringToPos(end);\n}\nfunction scanString(tokenizer) {\n  var end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n  if (end === -1) {\n    tokenizer.pos = tokenizer.str.length;\n    tokenizer.error('Expect an apostrophe');\n  }\n  return tokenizer.substringToPos(end + 1);\n}\nfunction readMultiplierRange(tokenizer) {\n  var min = null;\n  var max = null;\n  tokenizer.eat(LEFTCURLYBRACKET);\n  min = scanNumber(tokenizer);\n  if (tokenizer.charCode() === COMMA) {\n    tokenizer.pos++;\n    if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n      max = scanNumber(tokenizer);\n    }\n  } else {\n    max = min;\n  }\n  tokenizer.eat(RIGHTCURLYBRACKET);\n  return {\n    min: Number(min),\n    max: max ? Number(max) : 0\n  };\n}\nfunction readMultiplier(tokenizer) {\n  var range = null;\n  var comma = false;\n  switch (tokenizer.charCode()) {\n    case ASTERISK:\n      tokenizer.pos++;\n      range = {\n        min: 0,\n        max: 0\n      };\n      break;\n    case PLUSSIGN:\n      tokenizer.pos++;\n      range = {\n        min: 1,\n        max: 0\n      };\n      break;\n    case QUESTIONMARK:\n      tokenizer.pos++;\n      range = {\n        min: 0,\n        max: 1\n      };\n      break;\n    case NUMBERSIGN:\n      tokenizer.pos++;\n      comma = true;\n      if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n        range = readMultiplierRange(tokenizer);\n      } else {\n        range = {\n          min: 1,\n          max: 0\n        };\n      }\n      break;\n    case LEFTCURLYBRACKET:\n      range = readMultiplierRange(tokenizer);\n      break;\n    default:\n      return null;\n  }\n  return {\n    type: 'Multiplier',\n    comma: comma,\n    min: range.min,\n    max: range.max,\n    term: null\n  };\n}\nfunction maybeMultiplied(tokenizer, node) {\n  var multiplier = readMultiplier(tokenizer);\n  if (multiplier !== null) {\n    multiplier.term = node;\n    return multiplier;\n  }\n  return node;\n}\nfunction maybeToken(tokenizer) {\n  var ch = tokenizer.peek();\n  if (ch === '') {\n    return null;\n  }\n  return {\n    type: 'Token',\n    value: ch\n  };\n}\nfunction readProperty(tokenizer) {\n  var name;\n  tokenizer.eat(LESSTHANSIGN);\n  tokenizer.eat(APOSTROPHE);\n  name = scanWord(tokenizer);\n  tokenizer.eat(APOSTROPHE);\n  tokenizer.eat(GREATERTHANSIGN);\n  return maybeMultiplied(tokenizer, {\n    type: 'Property',\n    name: name\n  });\n}\n\n// https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation—[min,max]—within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\nfunction readTypeRange(tokenizer) {\n  // use null for Infinity to make AST format JSON serializable/deserializable\n  var min = null; // -Infinity\n  var max = null; // Infinity\n  var sign = 1;\n  tokenizer.eat(LEFTSQUAREBRACKET);\n  if (tokenizer.charCode() === HYPERMINUS) {\n    tokenizer.peek();\n    sign = -1;\n  }\n  if (sign == -1 && tokenizer.charCode() === INFINITY) {\n    tokenizer.peek();\n  } else {\n    min = sign * Number(scanNumber(tokenizer));\n  }\n  scanSpaces(tokenizer);\n  tokenizer.eat(COMMA);\n  scanSpaces(tokenizer);\n  if (tokenizer.charCode() === INFINITY) {\n    tokenizer.peek();\n  } else {\n    sign = 1;\n    if (tokenizer.charCode() === HYPERMINUS) {\n      tokenizer.peek();\n      sign = -1;\n    }\n    max = sign * Number(scanNumber(tokenizer));\n  }\n  tokenizer.eat(RIGHTSQUAREBRACKET);\n\n  // If no range is indicated, either by using the bracketed range notation\n  // or in the property description, then [−∞,∞] is assumed.\n  if (min === null && max === null) {\n    return null;\n  }\n  return {\n    type: 'Range',\n    min: min,\n    max: max\n  };\n}\nfunction readType(tokenizer) {\n  var name;\n  var opts = null;\n  tokenizer.eat(LESSTHANSIGN);\n  name = scanWord(tokenizer);\n  if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n    tokenizer.pos += 2;\n    name += '()';\n  }\n  if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n    scanSpaces(tokenizer);\n    opts = readTypeRange(tokenizer);\n  }\n  tokenizer.eat(GREATERTHANSIGN);\n  return maybeMultiplied(tokenizer, {\n    type: 'Type',\n    name: name,\n    opts: opts\n  });\n}\nfunction readKeywordOrFunction(tokenizer) {\n  var name;\n  name = scanWord(tokenizer);\n  if (tokenizer.charCode() === LEFTPARENTHESIS) {\n    tokenizer.pos++;\n    return {\n      type: 'Function',\n      name: name\n    };\n  }\n  return maybeMultiplied(tokenizer, {\n    type: 'Keyword',\n    name: name\n  });\n}\nfunction regroupTerms(terms, combinators) {\n  function createGroup(terms, combinator) {\n    return {\n      type: 'Group',\n      terms: terms,\n      combinator: combinator,\n      disallowEmpty: false,\n      explicit: false\n    };\n  }\n  combinators = Object.keys(combinators).sort(function (a, b) {\n    return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];\n  });\n  while (combinators.length > 0) {\n    var combinator = combinators.shift();\n    for (var i = 0, subgroupStart = 0; i < terms.length; i++) {\n      var term = terms[i];\n      if (term.type === 'Combinator') {\n        if (term.value === combinator) {\n          if (subgroupStart === -1) {\n            subgroupStart = i - 1;\n          }\n          terms.splice(i, 1);\n          i--;\n        } else {\n          if (subgroupStart !== -1 && i - subgroupStart > 1) {\n            terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));\n            i = subgroupStart + 1;\n          }\n          subgroupStart = -1;\n        }\n      }\n    }\n    if (subgroupStart !== -1 && combinators.length) {\n      terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));\n    }\n  }\n  return combinator;\n}\nfunction readImplicitGroup(tokenizer) {\n  var terms = [];\n  var combinators = {};\n  var token;\n  var prevToken = null;\n  var prevTokenPos = tokenizer.pos;\n  while (token = peek(tokenizer)) {\n    if (token.type !== 'Spaces') {\n      if (token.type === 'Combinator') {\n        // check for combinator in group beginning and double combinator sequence\n        if (prevToken === null || prevToken.type === 'Combinator') {\n          tokenizer.pos = prevTokenPos;\n          tokenizer.error('Unexpected combinator');\n        }\n        combinators[token.value] = true;\n      } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n        combinators[' '] = true; // a b\n        terms.push({\n          type: 'Combinator',\n          value: ' '\n        });\n      }\n      terms.push(token);\n      prevToken = token;\n      prevTokenPos = tokenizer.pos;\n    }\n  }\n\n  // check for combinator in group ending\n  if (prevToken !== null && prevToken.type === 'Combinator') {\n    tokenizer.pos -= prevTokenPos;\n    tokenizer.error('Unexpected combinator');\n  }\n  return {\n    type: 'Group',\n    terms: terms,\n    combinator: regroupTerms(terms, combinators) || ' ',\n    disallowEmpty: false,\n    explicit: false\n  };\n}\nfunction readGroup(tokenizer) {\n  var result;\n  tokenizer.eat(LEFTSQUAREBRACKET);\n  result = readImplicitGroup(tokenizer);\n  tokenizer.eat(RIGHTSQUAREBRACKET);\n  result.explicit = true;\n  if (tokenizer.charCode() === EXCLAMATIONMARK) {\n    tokenizer.pos++;\n    result.disallowEmpty = true;\n  }\n  return result;\n}\nfunction peek(tokenizer) {\n  var code = tokenizer.charCode();\n  if (code < 128 && NAME_CHAR[code] === 1) {\n    return readKeywordOrFunction(tokenizer);\n  }\n  switch (code) {\n    case RIGHTSQUAREBRACKET:\n      // don't eat, stop scan a group\n      break;\n    case LEFTSQUAREBRACKET:\n      return maybeMultiplied(tokenizer, readGroup(tokenizer));\n    case LESSTHANSIGN:\n      return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);\n    case VERTICALLINE:\n      return {\n        type: 'Combinator',\n        value: tokenizer.substringToPos(tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1)\n      };\n    case AMPERSAND:\n      tokenizer.pos++;\n      tokenizer.eat(AMPERSAND);\n      return {\n        type: 'Combinator',\n        value: '&&'\n      };\n    case COMMA:\n      tokenizer.pos++;\n      return {\n        type: 'Comma'\n      };\n    case APOSTROPHE:\n      return maybeMultiplied(tokenizer, {\n        type: 'String',\n        value: scanString(tokenizer)\n      });\n    case SPACE:\n    case TAB:\n    case N:\n    case R:\n    case F:\n      return {\n        type: 'Spaces',\n        value: scanSpaces(tokenizer)\n      };\n    case COMMERCIALAT:\n      code = tokenizer.nextCharCode();\n      if (code < 128 && NAME_CHAR[code] === 1) {\n        tokenizer.pos++;\n        return {\n          type: 'AtKeyword',\n          name: scanWord(tokenizer)\n        };\n      }\n      return maybeToken(tokenizer);\n    case ASTERISK:\n    case PLUSSIGN:\n    case QUESTIONMARK:\n    case NUMBERSIGN:\n    case EXCLAMATIONMARK:\n      // prohibited tokens (used as a multiplier start)\n      break;\n    case LEFTCURLYBRACKET:\n      // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n      // check next char isn't a number, because it's likely a disjoined multiplier\n      code = tokenizer.nextCharCode();\n      if (code < 48 || code > 57) {\n        return maybeToken(tokenizer);\n      }\n      break;\n    default:\n      return maybeToken(tokenizer);\n  }\n}\nfunction parse(source) {\n  var tokenizer = new Tokenizer(source);\n  var result = readImplicitGroup(tokenizer);\n  if (tokenizer.pos !== source.length) {\n    tokenizer.error('Unexpected input');\n  }\n\n  // reduce redundant groups with single group term\n  if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n    result = result.terms[0];\n  }\n  return result;\n}\n\n// warm up parse to elimitate code branches that never execute\n// fix soft deoptimizations (insufficient type feedback)\nparse('[a&&<b>#|<\\'c\\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');\nmodule.exports = parse;","map":{"version":3,"names":["Tokenizer","require","TAB","N","F","R","SPACE","EXCLAMATIONMARK","NUMBERSIGN","AMPERSAND","APOSTROPHE","LEFTPARENTHESIS","RIGHTPARENTHESIS","ASTERISK","PLUSSIGN","COMMA","HYPERMINUS","LESSTHANSIGN","GREATERTHANSIGN","QUESTIONMARK","COMMERCIALAT","LEFTSQUAREBRACKET","RIGHTSQUAREBRACKET","LEFTCURLYBRACKET","VERTICALLINE","RIGHTCURLYBRACKET","INFINITY","NAME_CHAR","createCharMap","ch","test","COMBINATOR_PRECEDENCE","fn","array","Uint32Array","Array","i","String","fromCharCode","scanSpaces","tokenizer","substringToPos","findWsEnd","pos","scanWord","end","str","length","code","charCodeAt","error","scanNumber","scanString","indexOf","readMultiplierRange","min","max","eat","charCode","Number","readMultiplier","range","comma","type","term","maybeMultiplied","node","multiplier","maybeToken","peek","value","readProperty","name","readTypeRange","sign","readType","opts","nextCharCode","readKeywordOrFunction","regroupTerms","terms","combinators","createGroup","combinator","disallowEmpty","explicit","Object","keys","sort","a","b","shift","subgroupStart","splice","slice","readImplicitGroup","token","prevToken","prevTokenPos","push","readGroup","result","parse","source","module","exports"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/definition-syntax/parse.js"],"sourcesContent":["var Tokenizer = require('./tokenizer');\nvar TAB = 9;\nvar N = 10;\nvar F = 12;\nvar R = 13;\nvar SPACE = 32;\nvar EXCLAMATIONMARK = 33;    // !\nvar NUMBERSIGN = 35;         // #\nvar AMPERSAND = 38;          // &\nvar APOSTROPHE = 39;         // '\nvar LEFTPARENTHESIS = 40;    // (\nvar RIGHTPARENTHESIS = 41;   // )\nvar ASTERISK = 42;           // *\nvar PLUSSIGN = 43;           // +\nvar COMMA = 44;              // ,\nvar HYPERMINUS = 45;         // -\nvar LESSTHANSIGN = 60;       // <\nvar GREATERTHANSIGN = 62;    // >\nvar QUESTIONMARK = 63;       // ?\nvar COMMERCIALAT = 64;       // @\nvar LEFTSQUAREBRACKET = 91;  // [\nvar RIGHTSQUAREBRACKET = 93; // ]\nvar LEFTCURLYBRACKET = 123;  // {\nvar VERTICALLINE = 124;      // |\nvar RIGHTCURLYBRACKET = 125; // }\nvar INFINITY = 8734;         // ∞\nvar NAME_CHAR = createCharMap(function(ch) {\n    return /[a-zA-Z0-9\\-]/.test(ch);\n});\nvar COMBINATOR_PRECEDENCE = {\n    ' ': 1,\n    '&&': 2,\n    '||': 3,\n    '|': 4\n};\n\nfunction createCharMap(fn) {\n    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);\n    for (var i = 0; i < 128; i++) {\n        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;\n    }\n    return array;\n}\n\nfunction scanSpaces(tokenizer) {\n    return tokenizer.substringToPos(\n        tokenizer.findWsEnd(tokenizer.pos)\n    );\n}\n\nfunction scanWord(tokenizer) {\n    var end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        var code = tokenizer.str.charCodeAt(end);\n        if (code >= 128 || NAME_CHAR[code] === 0) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a keyword');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanNumber(tokenizer) {\n    var end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        var code = tokenizer.str.charCodeAt(end);\n        if (code < 48 || code > 57) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a number');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanString(tokenizer) {\n    var end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n\n    if (end === -1) {\n        tokenizer.pos = tokenizer.str.length;\n        tokenizer.error('Expect an apostrophe');\n    }\n\n    return tokenizer.substringToPos(end + 1);\n}\n\nfunction readMultiplierRange(tokenizer) {\n    var min = null;\n    var max = null;\n\n    tokenizer.eat(LEFTCURLYBRACKET);\n\n    min = scanNumber(tokenizer);\n\n    if (tokenizer.charCode() === COMMA) {\n        tokenizer.pos++;\n        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n            max = scanNumber(tokenizer);\n        }\n    } else {\n        max = min;\n    }\n\n    tokenizer.eat(RIGHTCURLYBRACKET);\n\n    return {\n        min: Number(min),\n        max: max ? Number(max) : 0\n    };\n}\n\nfunction readMultiplier(tokenizer) {\n    var range = null;\n    var comma = false;\n\n    switch (tokenizer.charCode()) {\n        case ASTERISK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 0\n            };\n\n            break;\n\n        case PLUSSIGN:\n            tokenizer.pos++;\n\n            range = {\n                min: 1,\n                max: 0\n            };\n\n            break;\n\n        case QUESTIONMARK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 1\n            };\n\n            break;\n\n        case NUMBERSIGN:\n            tokenizer.pos++;\n\n            comma = true;\n\n            if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n                range = readMultiplierRange(tokenizer);\n            } else {\n                range = {\n                    min: 1,\n                    max: 0\n                };\n            }\n\n            break;\n\n        case LEFTCURLYBRACKET:\n            range = readMultiplierRange(tokenizer);\n            break;\n\n        default:\n            return null;\n    }\n\n    return {\n        type: 'Multiplier',\n        comma: comma,\n        min: range.min,\n        max: range.max,\n        term: null\n    };\n}\n\nfunction maybeMultiplied(tokenizer, node) {\n    var multiplier = readMultiplier(tokenizer);\n\n    if (multiplier !== null) {\n        multiplier.term = node;\n        return multiplier;\n    }\n\n    return node;\n}\n\nfunction maybeToken(tokenizer) {\n    var ch = tokenizer.peek();\n\n    if (ch === '') {\n        return null;\n    }\n\n    return {\n        type: 'Token',\n        value: ch\n    };\n}\n\nfunction readProperty(tokenizer) {\n    var name;\n\n    tokenizer.eat(LESSTHANSIGN);\n    tokenizer.eat(APOSTROPHE);\n\n    name = scanWord(tokenizer);\n\n    tokenizer.eat(APOSTROPHE);\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Property',\n        name: name\n    });\n}\n\n// https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation—[min,max]—within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\nfunction readTypeRange(tokenizer) {\n    // use null for Infinity to make AST format JSON serializable/deserializable\n    var min = null; // -Infinity\n    var max = null; // Infinity\n    var sign = 1;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n\n    if (tokenizer.charCode() === HYPERMINUS) {\n        tokenizer.peek();\n        sign = -1;\n    }\n\n    if (sign == -1 && tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        min = sign * Number(scanNumber(tokenizer));\n    }\n\n    scanSpaces(tokenizer);\n    tokenizer.eat(COMMA);\n    scanSpaces(tokenizer);\n\n    if (tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        sign = 1;\n\n        if (tokenizer.charCode() === HYPERMINUS) {\n            tokenizer.peek();\n            sign = -1;\n        }\n\n        max = sign * Number(scanNumber(tokenizer));\n    }\n\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    // If no range is indicated, either by using the bracketed range notation\n    // or in the property description, then [−∞,∞] is assumed.\n    if (min === null && max === null) {\n        return null;\n    }\n\n    return {\n        type: 'Range',\n        min: min,\n        max: max\n    };\n}\n\nfunction readType(tokenizer) {\n    var name;\n    var opts = null;\n\n    tokenizer.eat(LESSTHANSIGN);\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS &&\n        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n        tokenizer.pos += 2;\n        name += '()';\n    }\n\n    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n        scanSpaces(tokenizer);\n        opts = readTypeRange(tokenizer);\n    }\n\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Type',\n        name: name,\n        opts: opts\n    });\n}\n\nfunction readKeywordOrFunction(tokenizer) {\n    var name;\n\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS) {\n        tokenizer.pos++;\n\n        return {\n            type: 'Function',\n            name: name\n        };\n    }\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Keyword',\n        name: name\n    });\n}\n\nfunction regroupTerms(terms, combinators) {\n    function createGroup(terms, combinator) {\n        return {\n            type: 'Group',\n            terms: terms,\n            combinator: combinator,\n            disallowEmpty: false,\n            explicit: false\n        };\n    }\n\n    combinators = Object.keys(combinators).sort(function(a, b) {\n        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];\n    });\n\n    while (combinators.length > 0) {\n        var combinator = combinators.shift();\n        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {\n            var term = terms[i];\n            if (term.type === 'Combinator') {\n                if (term.value === combinator) {\n                    if (subgroupStart === -1) {\n                        subgroupStart = i - 1;\n                    }\n                    terms.splice(i, 1);\n                    i--;\n                } else {\n                    if (subgroupStart !== -1 && i - subgroupStart > 1) {\n                        terms.splice(\n                            subgroupStart,\n                            i - subgroupStart,\n                            createGroup(terms.slice(subgroupStart, i), combinator)\n                        );\n                        i = subgroupStart + 1;\n                    }\n                    subgroupStart = -1;\n                }\n            }\n        }\n\n        if (subgroupStart !== -1 && combinators.length) {\n            terms.splice(\n                subgroupStart,\n                i - subgroupStart,\n                createGroup(terms.slice(subgroupStart, i), combinator)\n            );\n        }\n    }\n\n    return combinator;\n}\n\nfunction readImplicitGroup(tokenizer) {\n    var terms = [];\n    var combinators = {};\n    var token;\n    var prevToken = null;\n    var prevTokenPos = tokenizer.pos;\n\n    while (token = peek(tokenizer)) {\n        if (token.type !== 'Spaces') {\n            if (token.type === 'Combinator') {\n                // check for combinator in group beginning and double combinator sequence\n                if (prevToken === null || prevToken.type === 'Combinator') {\n                    tokenizer.pos = prevTokenPos;\n                    tokenizer.error('Unexpected combinator');\n                }\n\n                combinators[token.value] = true;\n            } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n                combinators[' '] = true;  // a b\n                terms.push({\n                    type: 'Combinator',\n                    value: ' '\n                });\n            }\n\n            terms.push(token);\n            prevToken = token;\n            prevTokenPos = tokenizer.pos;\n        }\n    }\n\n    // check for combinator in group ending\n    if (prevToken !== null && prevToken.type === 'Combinator') {\n        tokenizer.pos -= prevTokenPos;\n        tokenizer.error('Unexpected combinator');\n    }\n\n    return {\n        type: 'Group',\n        terms: terms,\n        combinator: regroupTerms(terms, combinators) || ' ',\n        disallowEmpty: false,\n        explicit: false\n    };\n}\n\nfunction readGroup(tokenizer) {\n    var result;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n    result = readImplicitGroup(tokenizer);\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    result.explicit = true;\n\n    if (tokenizer.charCode() === EXCLAMATIONMARK) {\n        tokenizer.pos++;\n        result.disallowEmpty = true;\n    }\n\n    return result;\n}\n\nfunction peek(tokenizer) {\n    var code = tokenizer.charCode();\n\n    if (code < 128 && NAME_CHAR[code] === 1) {\n        return readKeywordOrFunction(tokenizer);\n    }\n\n    switch (code) {\n        case RIGHTSQUAREBRACKET:\n            // don't eat, stop scan a group\n            break;\n\n        case LEFTSQUAREBRACKET:\n            return maybeMultiplied(tokenizer, readGroup(tokenizer));\n\n        case LESSTHANSIGN:\n            return tokenizer.nextCharCode() === APOSTROPHE\n                ? readProperty(tokenizer)\n                : readType(tokenizer);\n\n        case VERTICALLINE:\n            return {\n                type: 'Combinator',\n                value: tokenizer.substringToPos(\n                    tokenizer.nextCharCode() === VERTICALLINE\n                        ? tokenizer.pos + 2\n                        : tokenizer.pos + 1\n                )\n            };\n\n        case AMPERSAND:\n            tokenizer.pos++;\n            tokenizer.eat(AMPERSAND);\n\n            return {\n                type: 'Combinator',\n                value: '&&'\n            };\n\n        case COMMA:\n            tokenizer.pos++;\n            return {\n                type: 'Comma'\n            };\n\n        case APOSTROPHE:\n            return maybeMultiplied(tokenizer, {\n                type: 'String',\n                value: scanString(tokenizer)\n            });\n\n        case SPACE:\n        case TAB:\n        case N:\n        case R:\n        case F:\n            return {\n                type: 'Spaces',\n                value: scanSpaces(tokenizer)\n            };\n\n        case COMMERCIALAT:\n            code = tokenizer.nextCharCode();\n\n            if (code < 128 && NAME_CHAR[code] === 1) {\n                tokenizer.pos++;\n                return {\n                    type: 'AtKeyword',\n                    name: scanWord(tokenizer)\n                };\n            }\n\n            return maybeToken(tokenizer);\n\n        case ASTERISK:\n        case PLUSSIGN:\n        case QUESTIONMARK:\n        case NUMBERSIGN:\n        case EXCLAMATIONMARK:\n            // prohibited tokens (used as a multiplier start)\n            break;\n\n        case LEFTCURLYBRACKET:\n            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n            // check next char isn't a number, because it's likely a disjoined multiplier\n            code = tokenizer.nextCharCode();\n\n            if (code < 48 || code > 57) {\n                return maybeToken(tokenizer);\n            }\n\n            break;\n\n        default:\n            return maybeToken(tokenizer);\n    }\n}\n\nfunction parse(source) {\n    var tokenizer = new Tokenizer(source);\n    var result = readImplicitGroup(tokenizer);\n\n    if (tokenizer.pos !== source.length) {\n        tokenizer.error('Unexpected input');\n    }\n\n    // reduce redundant groups with single group term\n    if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n        result = result.terms[0];\n    }\n\n    return result;\n}\n\n// warm up parse to elimitate code branches that never execute\n// fix soft deoptimizations (insufficient type feedback)\nparse('[a&&<b>#|<\\'c\\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');\n\nmodule.exports = parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}