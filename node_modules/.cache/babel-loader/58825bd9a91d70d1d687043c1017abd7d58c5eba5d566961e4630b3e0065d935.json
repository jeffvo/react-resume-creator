{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertNode = exports.convertElementStyle = exports.convertStylesheet = exports.convertRule = void 0;\nconst node_html_parser_1 = require(\"node-html-parser\");\nconst css_tree_1 = __importDefault(require(\"css-tree\"));\nconst supportedStyles_1 = __importDefault(require(\"./supportedStyles\"));\nconst resolveCssFile_1 = __importDefault(require(\"./resolveCssFile\"));\nconst camelize = require('camelize');\nconst convertRule = (rule, source = 'style') => {\n  const declarations = rule.children.filter(declaration => declaration.type === 'Declaration').toArray();\n  return declarations.map(entry => Object.assign(Object.assign({}, entry), {\n    property: camelize(entry.property)\n  })).reduce((style, {\n    property,\n    value\n  }) => {\n    let valueString = css_tree_1.default.generate(value);\n    if (property && value) {\n      if (property === 'fontFamily') {\n        valueString = valueString.replace(/[\"']+/g, '');\n        if (valueString.includes(',')) {\n          const reduced = valueString.split(',', 2)[0];\n          console.warn(`react-pdf doesn't support fontFamily lists like \"${valueString}\". Reducing to \"${reduced}\".`);\n          valueString = reduced;\n        }\n      } else if (!supportedStyles_1.default.includes(property)) {\n        if (property === 'background' && /^#?[a-zA-Z0-9]+$/.test(valueString) || /^rgba?\\([0-9, ]+\\)$/i.test(valueString) || /^hsla?\\([0-9.%, ]+\\)$/i.test(valueString)) {\n          property = 'backgroundColor';\n        } else {\n          console.warn(`${source}: Found unsupported style \"${property}\"`, {\n            property,\n            value\n          });\n        }\n      }\n      style[property] = valueString;\n    }\n    return style;\n  }, {});\n};\nexports.convertRule = convertRule;\nconst convertStylesheet = stylesheet => {\n  const response = {};\n  try {\n    const parsed = css_tree_1.default.parse(stylesheet);\n    const rules = parsed.children.filter(rule => {\n      var _a;\n      return rule.type === 'Rule' && ((_a = rule.prelude) === null || _a === void 0 ? void 0 : _a.type) === 'SelectorList';\n    });\n    rules.forEach(rule => {\n      const style = (0, exports.convertRule)(rule.block);\n      if (rule.prelude.type !== 'SelectorList') {\n        return;\n      }\n      rule.prelude.children.forEach(selector => {\n        const selectorString = css_tree_1.default.generate(selector);\n        response[selectorString] = style;\n      });\n    });\n  } catch (e) {\n    console.error(`Error parsing stylesheet: \"${stylesheet}\"`, e);\n  }\n  return response;\n};\nexports.convertStylesheet = convertStylesheet;\nconst convertElementStyle = (styleAttr, tag) => {\n  try {\n    const parsed = css_tree_1.default.parse(`${tag} { ${styleAttr} }`);\n    const rules = parsed.children.filter(rule => {\n      var _a;\n      return rule.type === 'Rule' && ((_a = rule.prelude) === null || _a === void 0 ? void 0 : _a.type) === 'SelectorList';\n    });\n    const firstRule = rules.first();\n    return firstRule ? (0, exports.convertRule)(firstRule.block, tag) : undefined;\n  } catch (e) {\n    console.error(`Error parsing style attribute \"${styleAttr}\" for tag: ${tag}`, e);\n  }\n};\nexports.convertElementStyle = convertElementStyle;\nconst convertNode = node => {\n  if (node.nodeType === node_html_parser_1.NodeType.TEXT_NODE) {\n    return node.rawText;\n  }\n  if (node.nodeType === node_html_parser_1.NodeType.COMMENT_NODE) {\n    return '';\n  }\n  if (node.nodeType !== node_html_parser_1.NodeType.ELEMENT_NODE) {\n    throw new Error('Not sure what this is');\n  }\n  const html = node;\n  const content = html.childNodes.map(exports.convertNode);\n  const kindCounters = {};\n  content.forEach(child => {\n    if (typeof child !== 'string') {\n      child.indexOfType = child.tag in kindCounters ? kindCounters[child.tag] = kindCounters[child.tag] + 1 : kindCounters[child.tag] = 0;\n    }\n  });\n  let style;\n  if (html.attributes.style && html.attributes.style.trim()) {\n    style = (0, exports.convertElementStyle)(html.attributes.style, html.tagName);\n  }\n  return Object.assign(html, {\n    tag: (html.tagName || '').toLowerCase(),\n    style: style ? [style] : [],\n    content,\n    indexOfType: 0\n  });\n};\nexports.convertNode = convertNode;\nconst parseHtml = text => {\n  const html = (0, node_html_parser_1.parse)(text, {\n    comment: false\n  });\n  const stylesheets = html.querySelectorAll('style, link[rel=\"stylesheet\"][href]').map(styleNode => {\n    if (styleNode.tagName === 'STYLE') {\n      return styleNode.childNodes.map(textNode => textNode.rawText.trim()).join('\\n');\n    } else {\n      try {\n        return (0, resolveCssFile_1.default)(styleNode.getAttribute('href'));\n      } catch (e) {\n        console.error(`Unable to get remote CSS file ${styleNode.getAttribute('href')}`, e);\n      }\n    }\n  }).filter(styleText => !!styleText).map(exports.convertStylesheet);\n  return {\n    stylesheets,\n    rootElement: (0, exports.convertNode)(html)\n  };\n};\nexports.default = parseHtml;","map":{"version":3,"names":["node_html_parser_1","require","css_tree_1","__importDefault","supportedStyles_1","resolveCssFile_1","camelize","convertRule","rule","source","declarations","children","filter","declaration","type","toArray","map","entry","Object","assign","property","reduce","style","value","valueString","default","generate","replace","includes","reduced","split","console","warn","test","exports","convertStylesheet","stylesheet","response","parsed","parse","rules","_a","prelude","forEach","block","selector","selectorString","e","error","convertElementStyle","styleAttr","tag","firstRule","first","undefined","convertNode","node","nodeType","NodeType","TEXT_NODE","rawText","COMMENT_NODE","ELEMENT_NODE","Error","html","content","childNodes","kindCounters","child","indexOfType","attributes","trim","tagName","toLowerCase","parseHtml","text","comment","stylesheets","querySelectorAll","styleNode","textNode","join","getAttribute","styleText","rootElement"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/src/parse.ts"],"sourcesContent":["import {\n  HTMLElement,\n  Node as HTMLNode,\n  NodeType,\n  parse,\n  TextNode,\n} from 'node-html-parser';\nimport { Tag } from './tags';\nimport cssTree, { Block, Declaration, List, Rule, StyleSheet } from 'css-tree';\nimport supportedStyles from './supportedStyles';\nimport { HtmlStyle, HtmlStyles } from './styles';\nimport remoteCss from './resolveCssFile';\nconst camelize = require('camelize');\n\nexport type HtmlContent = (HtmlElement | string)[];\n\nexport type HtmlElement = HTMLElement & {\n  tag: Tag | 'string';\n  parentNode: HtmlElement;\n  style: HtmlStyle[];\n  content: HtmlContent;\n  indexOfType: number;\n  querySelectorAll: (selector: string) => HtmlElement[];\n  querySelector: (selector: string) => HtmlElement;\n};\n\nexport const convertRule = (\n  rule: Block,\n  source: string = 'style'\n): HtmlStyle => {\n  const declarations = rule.children\n    .filter((declaration) => declaration.type === 'Declaration')\n    .toArray() as Declaration[];\n\n  return declarations\n    .map((entry) => ({\n      ...entry,\n      property: camelize(entry.property as string),\n    }))\n    .reduce((style, { property, value }: Declaration) => {\n      let valueString = cssTree.generate(value);\n      if (property && value) {\n        if (property === 'fontFamily') {\n          valueString = valueString.replace(/[\"']+/g, '');\n          if (valueString.includes(',')) {\n            const reduced = valueString.split(',', 2)[0];\n            console.warn(\n              `react-pdf doesn't support fontFamily lists like \"${valueString}\". Reducing to \"${reduced}\".`\n            );\n            valueString = reduced;\n          }\n        } else if (!supportedStyles.includes(property)) {\n          if (\n            (property === 'background' &&\n              /^#?[a-zA-Z0-9]+$/.test(valueString)) ||\n            /^rgba?\\([0-9, ]+\\)$/i.test(valueString) ||\n            /^hsla?\\([0-9.%, ]+\\)$/i.test(valueString)\n          ) {\n            property = 'backgroundColor';\n          } else {\n            console.warn(`${source}: Found unsupported style \"${property}\"`, {\n              property,\n              value,\n            });\n          }\n        }\n\n        style[property as keyof HtmlStyle] = valueString;\n      }\n      return style;\n    }, {} as HtmlStyle);\n};\n\nexport const convertStylesheet = (stylesheet: string): HtmlStyles => {\n  const response = {} as HtmlStyles;\n  try {\n    const parsed = cssTree.parse(stylesheet) as StyleSheet;\n    const rules = parsed.children.filter(\n      (rule) => rule.type === 'Rule' && rule.prelude?.type === 'SelectorList'\n    ) as List<Rule>;\n    rules.forEach((rule) => {\n      const style = convertRule(rule.block);\n      if (rule.prelude.type !== 'SelectorList') {\n        return;\n      }\n      rule.prelude.children.forEach((selector) => {\n        const selectorString = cssTree.generate(selector);\n        response[selectorString] = style;\n      });\n    });\n  } catch (e) {\n    console.error(`Error parsing stylesheet: \"${stylesheet}\"`, e);\n  }\n  return response;\n};\n\nexport const convertElementStyle = (\n  styleAttr: string,\n  tag: string\n): HtmlStyle | undefined => {\n  try {\n    const parsed = cssTree.parse(`${tag} { ${styleAttr} }`) as StyleSheet;\n    const rules = parsed.children.filter(\n      (rule) => rule.type === 'Rule' && rule.prelude?.type === 'SelectorList'\n    ) as List<Rule>;\n    const firstRule = rules.first();\n    return firstRule ? convertRule(firstRule.block, tag) : undefined;\n  } catch (e) {\n    console.error(\n      `Error parsing style attribute \"${styleAttr}\" for tag: ${tag}`,\n      e\n    );\n  }\n};\n\nexport const convertNode = (node: HTMLNode): HtmlElement | string => {\n  if (node.nodeType === NodeType.TEXT_NODE) {\n    return (node as TextNode).rawText;\n  }\n  if (node.nodeType === NodeType.COMMENT_NODE) {\n    return '';\n  }\n  if (node.nodeType !== NodeType.ELEMENT_NODE) {\n    throw new Error('Not sure what this is');\n  }\n  const html = node as HTMLElement;\n  const content = html.childNodes.map(convertNode);\n  const kindCounters: Record<string, number> = {};\n  content.forEach((child) => {\n    if (typeof child !== 'string') {\n      child.indexOfType =\n        child.tag in kindCounters\n          ? (kindCounters[child.tag] = kindCounters[child.tag] + 1)\n          : (kindCounters[child.tag] = 0);\n    }\n  });\n\n  let style: HtmlStyle | undefined;\n  if (html.attributes.style && html.attributes.style.trim()) {\n    style = convertElementStyle(html.attributes.style, html.tagName);\n  }\n\n  return Object.assign(html, {\n    tag: (html.tagName || '').toLowerCase() as Tag | string,\n    style: style ? [style] : [],\n    content,\n    indexOfType: 0,\n  }) as HtmlElement;\n};\n\nconst parseHtml = (\n  text: string\n): { stylesheets: HtmlStyles[]; rootElement: HtmlElement } => {\n  const html = parse(text, { comment: false });\n\n  const stylesheets = html\n    .querySelectorAll('style, link[rel=\"stylesheet\"][href]')\n    .map((styleNode) => {\n      if (styleNode.tagName === 'STYLE') {\n        return styleNode.childNodes\n          .map((textNode) => textNode.rawText.trim())\n          .join('\\n');\n      } else {\n        try {\n          return remoteCss(styleNode.getAttribute('href') as string);\n        } catch (e) {\n          console.error(\n            `Unable to get remote CSS file ${styleNode.getAttribute('href')}`,\n            e\n          );\n        }\n      }\n    })\n    .filter((styleText) => !!styleText)\n    .map(convertStylesheet);\n  return {\n    stylesheets,\n    rootElement: convertNode(html) as HtmlElement,\n  };\n};\n\nexport default parseHtml;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}