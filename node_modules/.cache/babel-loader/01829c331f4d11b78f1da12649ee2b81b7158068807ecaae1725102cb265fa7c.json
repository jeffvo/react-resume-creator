{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\nconst STREAM_DESTROYED = new Error('Stream was destroyed');\nconst PREMATURE_CLOSE = new Error('Premature close');\nconst queueTick = require('queue-tick');\nconst FIFO = require('fast-fifo');\n\n/* eslint-disable no-multi-spaces */\n\n// 28 bits used total (4 from shared, 14 from read, and 10 from write)\nconst MAX = (1 << 28) - 1;\n\n// Shared state\nconst OPENING = 0b0001;\nconst PREDESTROYING = 0b0010;\nconst DESTROYING = 0b0100;\nconst DESTROYED = 0b1000;\nconst NOT_OPENING = MAX ^ OPENING;\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING;\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE = 0b00000000000001 << 4;\nconst READ_UPDATING = 0b00000000000010 << 4;\nconst READ_PRIMARY = 0b00000000000100 << 4;\nconst READ_QUEUED = 0b00000000001000 << 4;\nconst READ_RESUMED = 0b00000000010000 << 4;\nconst READ_PIPE_DRAINED = 0b00000000100000 << 4;\nconst READ_ENDING = 0b00000001000000 << 4;\nconst READ_EMIT_DATA = 0b00000010000000 << 4;\nconst READ_EMIT_READABLE = 0b00000100000000 << 4;\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4;\nconst READ_DONE = 0b00010000000000 << 4;\nconst READ_NEXT_TICK = 0b00100000000000 << 4;\nconst READ_NEEDS_PUSH = 0b01000000000000 << 4;\nconst READ_READ_AHEAD = 0b10000000000000 << 4;\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;\nconst READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;\nconst READ_NON_PRIMARY = MAX ^ READ_PRIMARY;\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);\nconst READ_PUSHED = MAX ^ READ_NEEDS_PUSH;\nconst READ_PAUSED = MAX ^ READ_RESUMED;\nconst READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);\nconst READ_NOT_ENDING = MAX ^ READ_ENDING;\nconst READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;\nconst READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;\nconst READ_NOT_UPDATING = MAX ^ READ_UPDATING;\nconst READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;\nconst READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;\n\n// Write state (18 bit offset, 4 bit offset from shared state and 13 from read state)\nconst WRITE_ACTIVE = 0b0000000001 << 18;\nconst WRITE_UPDATING = 0b0000000010 << 18;\nconst WRITE_PRIMARY = 0b0000000100 << 18;\nconst WRITE_QUEUED = 0b0000001000 << 18;\nconst WRITE_UNDRAINED = 0b0000010000 << 18;\nconst WRITE_DONE = 0b0000100000 << 18;\nconst WRITE_EMIT_DRAIN = 0b0001000000 << 18;\nconst WRITE_NEXT_TICK = 0b0010000000 << 18;\nconst WRITE_WRITING = 0b0100000000 << 18;\nconst WRITE_FINISHING = 0b1000000000 << 18;\nconst WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);\nconst WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;\nconst WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;\nconst WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;\nconst WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;\nconst WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE;\nconst NOT_ACTIVE = MAX ^ ACTIVE;\nconst DONE = READ_DONE | WRITE_DONE;\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;\nconst OPEN_STATUS = DESTROY_STATUS | OPENING;\nconst AUTO_DESTROY = DESTROY_STATUS | DONE;\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;\nconst IS_OPENING = OPEN_STATUS | TICKING;\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED;\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');\nclass WritableState {\n  constructor(stream, {\n    highWaterMark = 16384,\n    map = null,\n    mapWritable,\n    byteLength,\n    byteLengthWritable\n  } = {}) {\n    this.stream = stream;\n    this.queue = new FIFO();\n    this.highWaterMark = highWaterMark;\n    this.buffered = 0;\n    this.error = null;\n    this.pipeline = null;\n    this.drains = null; // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength;\n    this.map = mapWritable || map;\n    this.afterWrite = afterWrite.bind(this);\n    this.afterUpdateNextTick = updateWriteNT.bind(this);\n  }\n  get ended() {\n    return (this.stream._duplexState & WRITE_DONE) !== 0;\n  }\n  push(data) {\n    if (this.map !== null) data = this.map(data);\n    this.buffered += this.byteLength(data);\n    this.queue.push(data);\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED;\n      return true;\n    }\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;\n    return false;\n  }\n  shift() {\n    const data = this.queue.shift();\n    this.buffered -= this.byteLength(data);\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;\n    return data;\n  }\n  end(data) {\n    if (typeof data === 'function') this.stream.once('finish', data);else if (data !== undefined && data !== null) this.push(data);\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;\n  }\n  autoBatch(data, cb) {\n    const buffer = [];\n    const stream = this.stream;\n    buffer.push(data);\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift());\n    }\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);\n    stream._writev(buffer, cb);\n  }\n  update() {\n    const stream = this.stream;\n    stream._duplexState |= WRITE_UPDATING;\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift();\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING;\n        stream._write(data, this.afterWrite);\n      }\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();\n    } while (this.continueUpdate() === true);\n    stream._duplexState &= WRITE_NOT_UPDATING;\n  }\n  updateNonPrimary() {\n    const stream = this.stream;\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;\n      stream._final(afterFinal.bind(this));\n      return;\n    }\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE;\n        stream._destroy(afterDestroy.bind(this));\n      }\n      return;\n    }\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;\n      stream._open(afterOpen.bind(this));\n    }\n  }\n  continueUpdate() {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK;\n    return true;\n  }\n  updateCallback() {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();else this.updateNextTick();\n  }\n  updateNextTick() {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;\n    this.stream._duplexState |= WRITE_NEXT_TICK;\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick);\n  }\n}\nclass ReadableState {\n  constructor(stream, {\n    highWaterMark = 16384,\n    map = null,\n    mapReadable,\n    byteLength,\n    byteLengthReadable\n  } = {}) {\n    this.stream = stream;\n    this.queue = new FIFO();\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;\n    this.buffered = 0;\n    this.readAhead = highWaterMark > 0;\n    this.error = null;\n    this.pipeline = null;\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength;\n    this.map = mapReadable || map;\n    this.pipeTo = null;\n    this.afterRead = afterRead.bind(this);\n    this.afterUpdateNextTick = updateReadNT.bind(this);\n  }\n  get ended() {\n    return (this.stream._duplexState & READ_DONE) !== 0;\n  }\n  pipe(pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');\n    if (typeof cb !== 'function') cb = null;\n    this.stream._duplexState |= READ_PIPE_DRAINED;\n    this.pipeTo = pipeTo;\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb);\n    if (cb) this.stream.on('error', noop); // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline;\n      if (cb) pipeTo.on('error', noop); // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)); // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null); // onclose has a weird bool arg\n      pipeTo.on('error', onerror);\n      pipeTo.on('close', onclose);\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));\n    }\n    pipeTo.on('drain', afterDrain.bind(this));\n    this.stream.emit('piping', pipeTo);\n    pipeTo.emit('pipe', this.stream);\n  }\n  push(data) {\n    const stream = this.stream;\n    if (data === null) {\n      this.highWaterMark = 0;\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;\n      return false;\n    }\n    if (this.map !== null) data = this.map(data);\n    this.buffered += this.byteLength(data);\n    this.queue.push(data);\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;\n    return this.buffered < this.highWaterMark;\n  }\n  shift() {\n    const data = this.queue.shift();\n    this.buffered -= this.byteLength(data);\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;\n    return data;\n  }\n  unshift(data) {\n    const pending = [this.map !== null ? this.map(data) : data];\n    while (this.buffered > 0) pending.push(this.shift());\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i];\n      this.buffered += this.byteLength(data);\n      this.queue.push(data);\n    }\n    this.push(pending[pending.length - 1]);\n  }\n  read() {\n    const stream = this.stream;\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift();\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);\n      return data;\n    }\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD;\n      this.updateNextTick();\n    }\n    return null;\n  }\n  drain() {\n    const stream = this.stream;\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift();\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);\n    }\n  }\n  update() {\n    const stream = this.stream;\n    stream._duplexState |= READ_UPDATING;\n    do {\n      this.drain();\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;\n        stream._read(this.afterRead);\n        this.drain();\n      }\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE;\n        stream.emit('readable');\n      }\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();\n    } while (this.continueUpdate() === true);\n    stream._duplexState &= READ_NOT_UPDATING;\n  }\n  updateNonPrimary() {\n    const stream = this.stream;\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;\n      stream.emit('end');\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;\n      if (this.pipeTo !== null) this.pipeTo.end();\n    }\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE;\n        stream._destroy(afterDestroy.bind(this));\n      }\n      return;\n    }\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;\n      stream._open(afterOpen.bind(this));\n    }\n  }\n  continueUpdate() {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;\n    this.stream._duplexState &= READ_NOT_NEXT_TICK;\n    return true;\n  }\n  updateCallback() {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();else this.updateNextTick();\n  }\n  updateNextTick() {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;\n    this.stream._duplexState |= READ_NEXT_TICK;\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick);\n  }\n}\nclass TransformState {\n  constructor(stream) {\n    this.data = null;\n    this.afterTransform = afterTransform.bind(stream);\n    this.afterFinal = null;\n  }\n}\nclass Pipeline {\n  constructor(src, dst, cb) {\n    this.from = src;\n    this.to = dst;\n    this.afterPipe = cb;\n    this.error = null;\n    this.pipeToFinished = false;\n  }\n  finished() {\n    this.pipeToFinished = true;\n  }\n  done(stream, err) {\n    if (err) this.error = err;\n    if (stream === this.to) {\n      this.to = null;\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'));\n        }\n        return;\n      }\n    }\n    if (stream === this.from) {\n      this.from = null;\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'));\n        }\n        return;\n      }\n    }\n    if (this.afterPipe !== null) this.afterPipe(this.error);\n    this.to = this.from = this.afterPipe = null;\n  }\n}\nfunction afterDrain() {\n  this.stream._duplexState |= READ_PIPE_DRAINED;\n  this.updateCallback();\n}\nfunction afterFinal(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE;\n    stream.emit('finish');\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING;\n  }\n  stream._duplexState &= WRITE_NOT_ACTIVE;\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();else this.updateNextTick();\n}\nfunction afterDestroy(err) {\n  const stream = this.stream;\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error;\n  if (err) stream.emit('error', err);\n  stream._duplexState |= DESTROYED;\n  stream.emit('close');\n  const rs = stream._readableState;\n  const ws = stream._writableState;\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false);\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err);\n  }\n}\nfunction afterWrite(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  stream._duplexState &= WRITE_NOT_ACTIVE;\n  if (this.drains !== null) tickDrains(this.drains);\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED;\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain');\n    }\n  }\n  this.updateCallback();\n}\nfunction afterRead(err) {\n  if (err) this.stream.destroy(err);\n  this.stream._duplexState &= READ_NOT_ACTIVE;\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;\n  this.updateCallback();\n}\nfunction updateReadNT() {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK;\n    this.update();\n  }\n}\nfunction updateWriteNT() {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK;\n    this.update();\n  }\n}\nfunction tickDrains(drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true);\n      i--;\n    }\n  }\n}\nfunction afterOpen(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;\n    stream.emit('open');\n  }\n  stream._duplexState &= NOT_ACTIVE;\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback();\n  }\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback();\n  }\n}\nfunction afterTransform(err, data) {\n  if (data !== undefined && data !== null) this.push(data);\n  this._writableState.afterWrite(err);\n}\nfunction newListener(name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;\n      this._readableState.updateNextTick();\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE;\n      this._readableState.updateNextTick();\n    }\n  }\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN;\n      this._writableState.updateNextTick();\n    }\n  }\n}\nclass Stream extends EventEmitter {\n  constructor(opts) {\n    super();\n    this._duplexState = 0;\n    this._readableState = null;\n    this._writableState = null;\n    if (opts) {\n      if (opts.open) this._open = opts.open;\n      if (opts.destroy) this._destroy = opts.destroy;\n      if (opts.predestroy) this._predestroy = opts.predestroy;\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this));\n      }\n    }\n    this.on('newListener', newListener);\n  }\n  _open(cb) {\n    cb(null);\n  }\n  _destroy(cb) {\n    cb(null);\n  }\n  _predestroy() {\n    // does nothing\n  }\n  get readable() {\n    return this._readableState !== null ? true : undefined;\n  }\n  get writable() {\n    return this._writableState !== null ? true : undefined;\n  }\n  get destroyed() {\n    return (this._duplexState & DESTROYED) !== 0;\n  }\n  get destroying() {\n    return (this._duplexState & DESTROY_STATUS) !== 0;\n  }\n  destroy(err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED;\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0;\n        this._readableState.error = err;\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0;\n        this._writableState.error = err;\n      }\n      this._duplexState |= PREDESTROYING;\n      this._predestroy();\n      this._duplexState &= NOT_PREDESTROYING;\n      if (this._readableState !== null) this._readableState.updateNextTick();\n      if (this._writableState !== null) this._writableState.updateNextTick();\n    }\n  }\n}\nclass Readable extends Stream {\n  constructor(opts) {\n    super(opts);\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;\n    this._readableState = new ReadableState(this, opts);\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;\n      if (opts.read) this._read = opts.read;\n      if (opts.eagerOpen) this._readableState.updateNextTick();\n    }\n  }\n  _read(cb) {\n    cb(null);\n  }\n  pipe(dest, cb) {\n    this._readableState.updateNextTick();\n    this._readableState.pipe(dest, cb);\n    return dest;\n  }\n  read() {\n    this._readableState.updateNextTick();\n    return this._readableState.read();\n  }\n  push(data) {\n    this._readableState.updateNextTick();\n    return this._readableState.push(data);\n  }\n  unshift(data) {\n    this._readableState.updateNextTick();\n    return this._readableState.unshift(data);\n  }\n  resume() {\n    this._duplexState |= READ_RESUMED_READ_AHEAD;\n    this._readableState.updateNextTick();\n    return this;\n  }\n  pause() {\n    this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;\n    return this;\n  }\n  static _fromAsyncIterator(ite, opts) {\n    let destroy;\n    const rs = new Readable({\n      ...opts,\n      read(cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb);\n      },\n      predestroy() {\n        destroy = ite.return();\n      },\n      destroy(cb) {\n        if (!destroy) return cb(null);\n        destroy.then(cb.bind(null, null)).catch(cb);\n      }\n    });\n    return rs;\n    function push(data) {\n      if (data.done) rs.push(null);else rs.push(data.value);\n    }\n  }\n  static from(data, opts) {\n    if (isReadStreamx(data)) return data;\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data];\n    let i = 0;\n    return new Readable({\n      ...opts,\n      read(cb) {\n        this.push(i === data.length ? null : data[i++]);\n        cb(null);\n      }\n    });\n  }\n  static isBackpressured(rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;\n  }\n  static isPaused(rs) {\n    return (rs._duplexState & READ_RESUMED) === 0;\n  }\n  [asyncIterator]() {\n    const stream = this;\n    let error = null;\n    let promiseResolve = null;\n    let promiseReject = null;\n    this.on('error', err => {\n      error = err;\n    });\n    this.on('readable', onreadable);\n    this.on('close', onclose);\n    return {\n      [asyncIterator]() {\n        return this;\n      },\n      next() {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve;\n          promiseReject = reject;\n          const data = stream.read();\n          if (data !== null) ondata(data);else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);\n        });\n      },\n      return() {\n        return destroy(null);\n      },\n      throw(err) {\n        return destroy(err);\n      }\n    };\n    function onreadable() {\n      if (promiseResolve !== null) ondata(stream.read());\n    }\n    function onclose() {\n      if (promiseResolve !== null) ondata(null);\n    }\n    function ondata(data) {\n      if (promiseReject === null) return;\n      if (error) promiseReject(error);else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);else promiseResolve({\n        value: data,\n        done: data === null\n      });\n      promiseReject = promiseResolve = null;\n    }\n    function destroy(err) {\n      stream.destroy(err);\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({\n          value: undefined,\n          done: true\n        });\n        stream.once('close', function () {\n          if (err) reject(err);else resolve({\n            value: undefined,\n            done: true\n          });\n        });\n      });\n    }\n  }\n}\nclass Writable extends Stream {\n  constructor(opts) {\n    super(opts);\n    this._duplexState |= OPENING | READ_DONE;\n    this._writableState = new WritableState(this, opts);\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev;\n      if (opts.write) this._write = opts.write;\n      if (opts.final) this._final = opts.final;\n      if (opts.eagerOpen) this._writableState.updateNextTick();\n    }\n  }\n  _writev(batch, cb) {\n    cb(null);\n  }\n  _write(data, cb) {\n    this._writableState.autoBatch(data, cb);\n  }\n  _final(cb) {\n    cb(null);\n  }\n  static isBackpressured(ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;\n  }\n  static drained(ws) {\n    if (ws.destroyed) return Promise.resolve(false);\n    const state = ws._writableState;\n    const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;\n    const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);\n    if (writes === 0) return Promise.resolve(true);\n    if (state.drains === null) state.drains = [];\n    return new Promise(resolve => {\n      state.drains.push({\n        writes,\n        resolve\n      });\n    });\n  }\n  write(data) {\n    this._writableState.updateNextTick();\n    return this._writableState.push(data);\n  }\n  end(data) {\n    this._writableState.updateNextTick();\n    this._writableState.end(data);\n    return this;\n  }\n}\nclass Duplex extends Readable {\n  // and Writable\n  constructor(opts) {\n    super(opts);\n    this._duplexState = OPENING;\n    this._writableState = new WritableState(this, opts);\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev;\n      if (opts.write) this._write = opts.write;\n      if (opts.final) this._final = opts.final;\n    }\n  }\n  _writev(batch, cb) {\n    cb(null);\n  }\n  _write(data, cb) {\n    this._writableState.autoBatch(data, cb);\n  }\n  _final(cb) {\n    cb(null);\n  }\n  write(data) {\n    this._writableState.updateNextTick();\n    return this._writableState.push(data);\n  }\n  end(data) {\n    this._writableState.updateNextTick();\n    this._writableState.end(data);\n    return this;\n  }\n}\nclass Transform extends Duplex {\n  constructor(opts) {\n    super(opts);\n    this._transformState = new TransformState(this);\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform;\n      if (opts.flush) this._flush = opts.flush;\n    }\n  }\n  _write(data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data;\n    } else {\n      this._transform(data, this._transformState.afterTransform);\n    }\n  }\n  _read(cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data;\n      this._transformState.data = null;\n      cb(null);\n      this._transform(data, this._transformState.afterTransform);\n    } else {\n      cb(null);\n    }\n  }\n  destroy(err) {\n    super.destroy(err);\n    if (this._transformState.data !== null) {\n      this._transformState.data = null;\n      this._transformState.afterTransform();\n    }\n  }\n  _transform(data, cb) {\n    cb(null, data);\n  }\n  _flush(cb) {\n    cb(null);\n  }\n  _final(cb) {\n    this._transformState.afterFinal = cb;\n    this._flush(transformAfterFlush.bind(this));\n  }\n}\nclass PassThrough extends Transform {}\nfunction transformAfterFlush(err, data) {\n  const cb = this._transformState.afterFinal;\n  if (err) return cb(err);\n  if (data !== null && data !== undefined) this.push(data);\n  this.push(null);\n  cb(null);\n}\nfunction pipelinePromise(...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, err => {\n      if (err) return reject(err);\n      resolve();\n    });\n  });\n}\nfunction pipeline(stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];\n  const done = all.length && typeof all[all.length - 1] === 'function' ? all.pop() : null;\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams');\n  let src = all[0];\n  let dest = null;\n  let error = null;\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i];\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror);\n    } else {\n      errorHandle(src, true, i > 1, onerror);\n      src.pipe(dest);\n    }\n    src = dest;\n  }\n  if (done) {\n    let fin = false;\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);\n    dest.on('error', err => {\n      if (error === null) error = err;\n    });\n    dest.on('finish', () => {\n      fin = true;\n      if (!autoDestroy) done(error);\n    });\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)));\n    }\n  }\n  return dest;\n  function errorHandle(s, rd, wr, onerror) {\n    s.on('error', onerror);\n    s.on('close', onclose);\n    function onclose() {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE);\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE);\n    }\n  }\n  function onerror(err) {\n    if (!err || error) return;\n    error = err;\n    for (const s of all) {\n      s.destroy(err);\n    }\n  }\n}\nfunction isStream(stream) {\n  return !!stream._readableState || !!stream._writableState;\n}\nfunction isStreamx(stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream);\n}\nfunction getStreamError(stream) {\n  const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;\n  return err === STREAM_DESTROYED ? null : err; // only explicit errors\n}\nfunction isReadStreamx(stream) {\n  return isStreamx(stream) && stream.readable;\n}\nfunction isTypedArray(data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number';\n}\nfunction defaultByteLength(data) {\n  return isTypedArray(data) ? data.byteLength : 1024;\n}\nfunction noop() {}\nfunction abort() {\n  this.destroy(new Error('Stream aborted.'));\n}\nfunction isWritev(s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;\n}\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n};","map":{"version":3,"names":["EventEmitter","require","STREAM_DESTROYED","Error","PREMATURE_CLOSE","queueTick","FIFO","MAX","OPENING","PREDESTROYING","DESTROYING","DESTROYED","NOT_OPENING","NOT_PREDESTROYING","READ_ACTIVE","READ_UPDATING","READ_PRIMARY","READ_QUEUED","READ_RESUMED","READ_PIPE_DRAINED","READ_ENDING","READ_EMIT_DATA","READ_EMIT_READABLE","READ_EMITTED_READABLE","READ_DONE","READ_NEXT_TICK","READ_NEEDS_PUSH","READ_READ_AHEAD","READ_FLOWING","READ_ACTIVE_AND_NEEDS_PUSH","READ_PRIMARY_AND_ACTIVE","READ_EMIT_READABLE_AND_QUEUED","READ_RESUMED_READ_AHEAD","READ_NOT_ACTIVE","READ_NON_PRIMARY","READ_NON_PRIMARY_AND_PUSHED","READ_PUSHED","READ_PAUSED","READ_NOT_QUEUED","READ_NOT_ENDING","READ_PIPE_NOT_DRAINED","READ_NOT_NEXT_TICK","READ_NOT_UPDATING","READ_NO_READ_AHEAD","READ_PAUSED_NO_READ_AHEAD","WRITE_ACTIVE","WRITE_UPDATING","WRITE_PRIMARY","WRITE_QUEUED","WRITE_UNDRAINED","WRITE_DONE","WRITE_EMIT_DRAIN","WRITE_NEXT_TICK","WRITE_WRITING","WRITE_FINISHING","WRITE_NOT_ACTIVE","WRITE_NON_PRIMARY","WRITE_NOT_FINISHING","WRITE_DRAINED","WRITE_NOT_QUEUED","WRITE_NOT_NEXT_TICK","WRITE_NOT_UPDATING","ACTIVE","NOT_ACTIVE","DONE","DESTROY_STATUS","OPEN_STATUS","AUTO_DESTROY","NON_PRIMARY","ACTIVE_OR_TICKING","TICKING","IS_OPENING","READ_PRIMARY_STATUS","READ_STATUS","READ_ENDING_STATUS","READ_READABLE_STATUS","SHOULD_NOT_READ","READ_BACKPRESSURE_STATUS","READ_UPDATE_SYNC_STATUS","WRITE_PRIMARY_STATUS","WRITE_QUEUED_AND_UNDRAINED","WRITE_QUEUED_AND_ACTIVE","WRITE_DRAIN_STATUS","WRITE_STATUS","WRITE_PRIMARY_AND_ACTIVE","WRITE_ACTIVE_AND_WRITING","WRITE_FINISHING_STATUS","WRITE_BACKPRESSURE_STATUS","WRITE_UPDATE_SYNC_STATUS","asyncIterator","Symbol","WritableState","constructor","stream","highWaterMark","map","mapWritable","byteLength","byteLengthWritable","queue","buffered","error","pipeline","drains","defaultByteLength","afterWrite","bind","afterUpdateNextTick","updateWriteNT","ended","_duplexState","push","data","shift","end","once","undefined","autoBatch","cb","buffer","_writableState","_writev","update","_write","updateNonPrimary","continueUpdate","_final","afterFinal","_destroy","afterDestroy","_open","afterOpen","updateCallback","updateNextTick","ReadableState","mapReadable","byteLengthReadable","readAhead","pipeTo","afterRead","updateReadNT","pipe","Pipeline","on","noop","isStreamx","finished","onerror","done","onclose","afterDrain","emit","unshift","pending","i","length","read","write","drain","_read","TransformState","afterTransform","src","dst","from","to","afterPipe","pipeToFinished","err","destroy","rs","_readableState","ws","resolve","tickDrains","writes","newListener","name","Stream","opts","open","predestroy","_predestroy","signal","addEventListener","abort","readable","writable","destroyed","destroying","Readable","eagerOpen","dest","resume","pause","_fromAsyncIterator","ite","next","then","catch","return","value","isReadStreamx","Array","isArray","isBackpressured","isPaused","promiseResolve","promiseReject","onreadable","Promise","reject","ondata","throw","Writable","writev","final","batch","drained","state","isWritev","Math","min","Duplex","Transform","_transformState","transform","_transform","flush","_flush","transformAfterFlush","PassThrough","pipelinePromise","streams","all","pop","errorHandle","fin","autoDestroy","s","rd","wr","isStream","getStreamError","isTypedArray","prototype","module","exports"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/streamx/index.js"],"sourcesContent":["const { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = require('queue-tick')\nconst FIFO = require('fast-fifo')\n\n/* eslint-disable no-multi-spaces */\n\n// 28 bits used total (4 from shared, 14 from read, and 10 from write)\nconst MAX = ((1 << 28) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 13 from read state)\nconst WRITE_ACTIVE     = 0b0000000001 << 18\nconst WRITE_UPDATING   = 0b0000000010 << 18\nconst WRITE_PRIMARY    = 0b0000000100 << 18\nconst WRITE_QUEUED     = 0b0000001000 << 18\nconst WRITE_UNDRAINED  = 0b0000010000 << 18\nconst WRITE_DONE       = 0b0000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b0001000000 << 18\nconst WRITE_NEXT_TICK  = 0b0010000000 << 18\nconst WRITE_WRITING    = 0b0100000000 << 18\nconst WRITE_FINISHING  = 0b1000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) data = this.map(data)\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction getStreamError (stream) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n  return err === STREAM_DESTROYED ? null : err // only explicit errors\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}