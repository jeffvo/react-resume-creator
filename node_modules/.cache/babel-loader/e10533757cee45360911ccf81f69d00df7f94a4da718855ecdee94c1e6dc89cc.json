{"ast":null,"code":"const mdnAtrules = require('mdn-data/css/at-rules.json');\nconst mdnProperties = require('mdn-data/css/properties.json');\nconst mdnSyntaxes = require('mdn-data/css/syntaxes.json');\nconst patch = require('./patch.json');\nconst extendSyntax = /^\\s*\\|\\s*/;\nfunction preprocessAtrules(dict) {\n  const result = Object.create(null);\n  for (const atruleName in dict) {\n    const atrule = dict[atruleName];\n    let descriptors = null;\n    if (atrule.descriptors) {\n      descriptors = Object.create(null);\n      for (const descriptor in atrule.descriptors) {\n        descriptors[descriptor] = atrule.descriptors[descriptor].syntax;\n      }\n    }\n    result[atruleName.substr(1)] = {\n      prelude: atrule.syntax.trim().match(/^@\\S+\\s+([^;\\{]*)/)[1].trim() || null,\n      descriptors\n    };\n  }\n  return result;\n}\nfunction patchDictionary(dict, patchDict) {\n  const result = {};\n\n  // copy all syntaxes for an original dict\n  for (const key in dict) {\n    result[key] = dict[key].syntax || dict[key];\n  }\n\n  // apply a patch\n  for (const key in patchDict) {\n    if (key in dict) {\n      if (patchDict[key].syntax) {\n        result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + ' ' + patchDict[key].syntax.trim() : patchDict[key].syntax;\n      } else {\n        delete result[key];\n      }\n    } else {\n      if (patchDict[key].syntax) {\n        result[key] = patchDict[key].syntax.replace(extendSyntax, '');\n      }\n    }\n  }\n  return result;\n}\nfunction unpackSyntaxes(dict) {\n  const result = {};\n  for (const key in dict) {\n    result[key] = dict[key].syntax;\n  }\n  return result;\n}\nfunction patchAtrules(dict, patchDict) {\n  const result = {};\n\n  // copy all syntaxes for an original dict\n  for (const key in dict) {\n    const patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;\n    result[key] = {\n      prelude: key in patchDict && 'prelude' in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,\n      descriptors: dict[key].descriptors ? patchDictionary(dict[key].descriptors, patchDescriptors || {}) : patchDescriptors && unpackSyntaxes(patchDescriptors)\n    };\n  }\n\n  // apply a patch\n  for (const key in patchDict) {\n    if (!hasOwnProperty.call(dict, key)) {\n      result[key] = {\n        prelude: patchDict[key].prelude || null,\n        descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)\n      };\n    }\n  }\n  return result;\n}\nmodule.exports = {\n  types: patchDictionary(mdnSyntaxes, patch.syntaxes),\n  atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),\n  properties: patchDictionary(mdnProperties, patch.properties)\n};","map":{"version":3,"names":["mdnAtrules","require","mdnProperties","mdnSyntaxes","patch","extendSyntax","preprocessAtrules","dict","result","Object","create","atruleName","atrule","descriptors","descriptor","syntax","substr","prelude","trim","match","patchDictionary","patchDict","key","test","replace","unpackSyntaxes","patchAtrules","patchDescriptors","hasOwnProperty","call","module","exports","types","syntaxes","atrules","properties"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/data/index.js"],"sourcesContent":["const mdnAtrules = require('mdn-data/css/at-rules.json');\nconst mdnProperties = require('mdn-data/css/properties.json');\nconst mdnSyntaxes = require('mdn-data/css/syntaxes.json');\nconst patch = require('./patch.json');\nconst extendSyntax = /^\\s*\\|\\s*/;\n\nfunction preprocessAtrules(dict) {\n    const result = Object.create(null);\n\n    for (const atruleName in dict) {\n        const atrule = dict[atruleName];\n        let descriptors = null;\n\n        if (atrule.descriptors) {\n            descriptors = Object.create(null);\n\n            for (const descriptor in atrule.descriptors) {\n                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;\n            }\n        }\n\n        result[atruleName.substr(1)] = {\n            prelude: atrule.syntax.trim().match(/^@\\S+\\s+([^;\\{]*)/)[1].trim() || null,\n            descriptors\n        };\n    }\n\n    return result;\n}\n\nfunction patchDictionary(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        result[key] = dict[key].syntax || dict[key];\n    }\n\n    // apply a patch\n    for (const key in patchDict) {\n        if (key in dict) {\n            if (patchDict[key].syntax) {\n                result[key] = extendSyntax.test(patchDict[key].syntax)\n                    ? result[key] + ' ' + patchDict[key].syntax.trim()\n                    : patchDict[key].syntax;\n            } else {\n                delete result[key];\n            }\n        } else {\n            if (patchDict[key].syntax) {\n                result[key] = patchDict[key].syntax.replace(extendSyntax, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction unpackSyntaxes(dict) {\n    const result = {};\n\n    for (const key in dict) {\n        result[key] = dict[key].syntax;\n    }\n\n    return result;\n}\n\nfunction patchAtrules(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        const patchDescriptors = (patchDict[key] && patchDict[key].descriptors) || null;\n\n        result[key] = {\n            prelude: key in patchDict && 'prelude' in patchDict[key]\n                ? patchDict[key].prelude\n                : dict[key].prelude || null,\n            descriptors: dict[key].descriptors\n                ? patchDictionary(dict[key].descriptors, patchDescriptors || {})\n                : patchDescriptors && unpackSyntaxes(patchDescriptors)\n        };\n    }\n\n    // apply a patch\n    for (const key in patchDict) {\n        if (!hasOwnProperty.call(dict, key)) {\n            result[key] = {\n                prelude: patchDict[key].prelude || null,\n                descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)\n            };\n        }\n    }\n\n    return result;\n}\n\nmodule.exports = {\n    types: patchDictionary(mdnSyntaxes, patch.syntaxes),\n    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),\n    properties: patchDictionary(mdnProperties, patch.properties)\n};\n"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,4BAA4B,CAAC;AACxD,MAAMC,aAAa,GAAGD,OAAO,CAAC,8BAA8B,CAAC;AAC7D,MAAME,WAAW,GAAGF,OAAO,CAAC,4BAA4B,CAAC;AACzD,MAAMG,KAAK,GAAGH,OAAO,CAAC,cAAc,CAAC;AACrC,MAAMI,YAAY,GAAG,WAAW;AAEhC,SAASC,iBAAiBA,CAACC,IAAI,EAAE;EAC7B,MAAMC,MAAM,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAElC,KAAK,MAAMC,UAAU,IAAIJ,IAAI,EAAE;IAC3B,MAAMK,MAAM,GAAGL,IAAI,CAACI,UAAU,CAAC;IAC/B,IAAIE,WAAW,GAAG,IAAI;IAEtB,IAAID,MAAM,CAACC,WAAW,EAAE;MACpBA,WAAW,GAAGJ,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;MAEjC,KAAK,MAAMI,UAAU,IAAIF,MAAM,CAACC,WAAW,EAAE;QACzCA,WAAW,CAACC,UAAU,CAAC,GAAGF,MAAM,CAACC,WAAW,CAACC,UAAU,CAAC,CAACC,MAAM;MACnE;IACJ;IAEAP,MAAM,CAACG,UAAU,CAACK,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG;MAC3BC,OAAO,EAAEL,MAAM,CAACG,MAAM,CAACG,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAACD,IAAI,CAAC,CAAC,IAAI,IAAI;MAC1EL;IACJ,CAAC;EACL;EAEA,OAAOL,MAAM;AACjB;AAEA,SAASY,eAAeA,CAACb,IAAI,EAAEc,SAAS,EAAE;EACtC,MAAMb,MAAM,GAAG,CAAC,CAAC;;EAEjB;EACA,KAAK,MAAMc,GAAG,IAAIf,IAAI,EAAE;IACpBC,MAAM,CAACc,GAAG,CAAC,GAAGf,IAAI,CAACe,GAAG,CAAC,CAACP,MAAM,IAAIR,IAAI,CAACe,GAAG,CAAC;EAC/C;;EAEA;EACA,KAAK,MAAMA,GAAG,IAAID,SAAS,EAAE;IACzB,IAAIC,GAAG,IAAIf,IAAI,EAAE;MACb,IAAIc,SAAS,CAACC,GAAG,CAAC,CAACP,MAAM,EAAE;QACvBP,MAAM,CAACc,GAAG,CAAC,GAAGjB,YAAY,CAACkB,IAAI,CAACF,SAAS,CAACC,GAAG,CAAC,CAACP,MAAM,CAAC,GAChDP,MAAM,CAACc,GAAG,CAAC,GAAG,GAAG,GAAGD,SAAS,CAACC,GAAG,CAAC,CAACP,MAAM,CAACG,IAAI,CAAC,CAAC,GAChDG,SAAS,CAACC,GAAG,CAAC,CAACP,MAAM;MAC/B,CAAC,MAAM;QACH,OAAOP,MAAM,CAACc,GAAG,CAAC;MACtB;IACJ,CAAC,MAAM;MACH,IAAID,SAAS,CAACC,GAAG,CAAC,CAACP,MAAM,EAAE;QACvBP,MAAM,CAACc,GAAG,CAAC,GAAGD,SAAS,CAACC,GAAG,CAAC,CAACP,MAAM,CAACS,OAAO,CAACnB,YAAY,EAAE,EAAE,CAAC;MACjE;IACJ;EACJ;EAEA,OAAOG,MAAM;AACjB;AAEA,SAASiB,cAAcA,CAAClB,IAAI,EAAE;EAC1B,MAAMC,MAAM,GAAG,CAAC,CAAC;EAEjB,KAAK,MAAMc,GAAG,IAAIf,IAAI,EAAE;IACpBC,MAAM,CAACc,GAAG,CAAC,GAAGf,IAAI,CAACe,GAAG,CAAC,CAACP,MAAM;EAClC;EAEA,OAAOP,MAAM;AACjB;AAEA,SAASkB,YAAYA,CAACnB,IAAI,EAAEc,SAAS,EAAE;EACnC,MAAMb,MAAM,GAAG,CAAC,CAAC;;EAEjB;EACA,KAAK,MAAMc,GAAG,IAAIf,IAAI,EAAE;IACpB,MAAMoB,gBAAgB,GAAIN,SAAS,CAACC,GAAG,CAAC,IAAID,SAAS,CAACC,GAAG,CAAC,CAACT,WAAW,IAAK,IAAI;IAE/EL,MAAM,CAACc,GAAG,CAAC,GAAG;MACVL,OAAO,EAAEK,GAAG,IAAID,SAAS,IAAI,SAAS,IAAIA,SAAS,CAACC,GAAG,CAAC,GAClDD,SAAS,CAACC,GAAG,CAAC,CAACL,OAAO,GACtBV,IAAI,CAACe,GAAG,CAAC,CAACL,OAAO,IAAI,IAAI;MAC/BJ,WAAW,EAAEN,IAAI,CAACe,GAAG,CAAC,CAACT,WAAW,GAC5BO,eAAe,CAACb,IAAI,CAACe,GAAG,CAAC,CAACT,WAAW,EAAEc,gBAAgB,IAAI,CAAC,CAAC,CAAC,GAC9DA,gBAAgB,IAAIF,cAAc,CAACE,gBAAgB;IAC7D,CAAC;EACL;;EAEA;EACA,KAAK,MAAML,GAAG,IAAID,SAAS,EAAE;IACzB,IAAI,CAACO,cAAc,CAACC,IAAI,CAACtB,IAAI,EAAEe,GAAG,CAAC,EAAE;MACjCd,MAAM,CAACc,GAAG,CAAC,GAAG;QACVL,OAAO,EAAEI,SAAS,CAACC,GAAG,CAAC,CAACL,OAAO,IAAI,IAAI;QACvCJ,WAAW,EAAEQ,SAAS,CAACC,GAAG,CAAC,CAACT,WAAW,IAAIY,cAAc,CAACJ,SAAS,CAACC,GAAG,CAAC,CAACT,WAAW;MACxF,CAAC;IACL;EACJ;EAEA,OAAOL,MAAM;AACjB;AAEAsB,MAAM,CAACC,OAAO,GAAG;EACbC,KAAK,EAAEZ,eAAe,CAACjB,WAAW,EAAEC,KAAK,CAAC6B,QAAQ,CAAC;EACnDC,OAAO,EAAER,YAAY,CAACpB,iBAAiB,CAACN,UAAU,CAAC,EAAEI,KAAK,CAAC8B,OAAO,CAAC;EACnEC,UAAU,EAAEf,eAAe,CAAClB,aAAa,EAAEE,KAAK,CAAC+B,UAAU;AAC/D,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}