{"ast":null,"code":"var __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { EMPTY, catchError, defaultIfEmpty, defer, filter, first, firstValueFrom, from, fromEvent, identity, ignoreElements, map, merge, mergeMap, noop, pipe, race, raceWith, retry, tap, throwIfEmpty } from '../../../third_party/rxjs/rxjs.js';\nimport { EventEmitter } from '../../common/EventEmitter.js';\nimport { debugError, timeout } from '../../common/util.js';\n/**\n * All the events that a locator instance may emit.\n *\n * @public\n */\nexport var LocatorEvent;\n(function (LocatorEvent) {\n  /**\n   * Emitted every time before the locator performs an action on the located element(s).\n   */\n  LocatorEvent[\"Action\"] = \"action\";\n})(LocatorEvent || (LocatorEvent = {}));\n/**\n * Locators describe a strategy of locating objects and performing an action on\n * them. If the action fails because the object is not ready for the action, the\n * whole operation is retried. Various preconditions for a successful action are\n * checked automatically.\n *\n * @public\n */\nexport class Locator extends EventEmitter {\n  /**\n   * Creates a race between multiple locators but ensures that only a single one\n   * acts.\n   *\n   * @public\n   */\n  static race(locators) {\n    return RaceLocator.create(locators);\n  }\n  /**\n   * @internal\n   */\n  visibility = null;\n  /**\n   * @internal\n   */\n  _timeout = 30000;\n  #ensureElementIsInTheViewport = true;\n  #waitForEnabled = true;\n  #waitForStableBoundingBox = true;\n  /**\n   * @internal\n   */\n  operators = {\n    conditions: (conditions, signal) => {\n      return mergeMap(handle => {\n        return merge(...conditions.map(condition => {\n          return condition(handle, signal);\n        })).pipe(defaultIfEmpty(handle));\n      });\n    },\n    retryAndRaceWithSignalAndTimer: signal => {\n      const candidates = [];\n      if (signal) {\n        candidates.push(fromEvent(signal, 'abort').pipe(map(() => {\n          throw signal.reason;\n        })));\n      }\n      candidates.push(timeout(this._timeout));\n      return pipe(retry({\n        delay: RETRY_DELAY\n      }), raceWith(...candidates));\n    }\n  };\n  // Determines when the locator will timeout for actions.\n  get timeout() {\n    return this._timeout;\n  }\n  setTimeout(timeout) {\n    const locator = this._clone();\n    locator._timeout = timeout;\n    return locator;\n  }\n  setVisibility(visibility) {\n    const locator = this._clone();\n    locator.visibility = visibility;\n    return locator;\n  }\n  setWaitForEnabled(value) {\n    const locator = this._clone();\n    locator.#waitForEnabled = value;\n    return locator;\n  }\n  setEnsureElementIsInTheViewport(value) {\n    const locator = this._clone();\n    locator.#ensureElementIsInTheViewport = value;\n    return locator;\n  }\n  setWaitForStableBoundingBox(value) {\n    const locator = this._clone();\n    locator.#waitForStableBoundingBox = value;\n    return locator;\n  }\n  /**\n   * @internal\n   */\n  copyOptions(locator) {\n    this._timeout = locator._timeout;\n    this.visibility = locator.visibility;\n    this.#waitForEnabled = locator.#waitForEnabled;\n    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;\n    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;\n    return this;\n  }\n  /**\n   * If the element has a \"disabled\" property, wait for the element to be\n   * enabled.\n   */\n  #waitForEnabledIfNeeded = (handle, signal) => {\n    if (!this.#waitForEnabled) {\n      return EMPTY;\n    }\n    return from(handle.frame.waitForFunction(element => {\n      if (!(element instanceof HTMLElement)) {\n        return true;\n      }\n      const isNativeFormControl = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTION', 'OPTGROUP'].includes(element.nodeName);\n      return !isNativeFormControl || !element.hasAttribute('disabled');\n    }, {\n      timeout: this._timeout,\n      signal\n    }, handle)).pipe(ignoreElements());\n  };\n  /**\n   * Compares the bounding box of the element for two consecutive animation\n   * frames and waits till they are the same.\n   */\n  #waitForStableBoundingBoxIfNeeded = handle => {\n    if (!this.#waitForStableBoundingBox) {\n      return EMPTY;\n    }\n    return defer(() => {\n      // Note we don't use waitForFunction because that relies on RAF.\n      return from(handle.evaluate(element => {\n        return new Promise(resolve => {\n          window.requestAnimationFrame(() => {\n            const rect1 = element.getBoundingClientRect();\n            window.requestAnimationFrame(() => {\n              const rect2 = element.getBoundingClientRect();\n              resolve([{\n                x: rect1.x,\n                y: rect1.y,\n                width: rect1.width,\n                height: rect1.height\n              }, {\n                x: rect2.x,\n                y: rect2.y,\n                width: rect2.width,\n                height: rect2.height\n              }]);\n            });\n          });\n        });\n      }));\n    }).pipe(first(([rect1, rect2]) => {\n      return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;\n    }), retry({\n      delay: RETRY_DELAY\n    }), ignoreElements());\n  };\n  /**\n   * Checks if the element is in the viewport and auto-scrolls it if it is not.\n   */\n  #ensureElementIsInTheViewportIfNeeded = handle => {\n    if (!this.#ensureElementIsInTheViewport) {\n      return EMPTY;\n    }\n    return from(handle.isIntersectingViewport({\n      threshold: 0\n    })).pipe(filter(isIntersectingViewport => {\n      return !isIntersectingViewport;\n    }), mergeMap(() => {\n      return from(handle.scrollIntoView());\n    }), mergeMap(() => {\n      return defer(() => {\n        return from(handle.isIntersectingViewport({\n          threshold: 0\n        }));\n      }).pipe(first(identity), retry({\n        delay: RETRY_DELAY\n      }), ignoreElements());\n    }));\n  };\n  #click(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded, this.#waitForEnabledIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), mergeMap(handle => {\n      return from(handle.click(options)).pipe(catchError(err => {\n        void handle.dispose().catch(debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #fill(value, options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded, this.#waitForEnabledIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), mergeMap(handle => {\n      return from(handle.evaluate(el => {\n        if (el instanceof HTMLSelectElement) {\n          return 'select';\n        }\n        if (el instanceof HTMLTextAreaElement) {\n          return 'typeable-input';\n        }\n        if (el instanceof HTMLInputElement) {\n          if (new Set(['textarea', 'text', 'url', 'tel', 'search', 'password', 'number', 'email']).has(el.type)) {\n            return 'typeable-input';\n          } else {\n            return 'other-input';\n          }\n        }\n        if (el.isContentEditable) {\n          return 'contenteditable';\n        }\n        return 'unknown';\n      })).pipe(mergeMap(inputType => {\n        switch (inputType) {\n          case 'select':\n            return from(handle.select(value).then(noop));\n          case 'contenteditable':\n          case 'typeable-input':\n            return from(handle.evaluate((input, newValue) => {\n              const currentValue = input.isContentEditable ? input.innerText : input.value;\n              // Clear the input if the current value does not match the filled\n              // out value.\n              if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {\n                if (input.isContentEditable) {\n                  input.innerText = '';\n                } else {\n                  input.value = '';\n                }\n                return newValue;\n              }\n              const originalValue = input.isContentEditable ? input.innerText : input.value;\n              // If the value is partially filled out, only type the rest. Move\n              // cursor to the end of the common prefix.\n              if (input.isContentEditable) {\n                input.innerText = '';\n                input.innerText = originalValue;\n              } else {\n                input.value = '';\n                input.value = originalValue;\n              }\n              return newValue.substring(originalValue.length);\n            }, value)).pipe(mergeMap(textToType => {\n              return from(handle.type(textToType));\n            }));\n          case 'other-input':\n            return from(handle.focus()).pipe(mergeMap(() => {\n              return from(handle.evaluate((input, value) => {\n                input.value = value;\n                input.dispatchEvent(new Event('input', {\n                  bubbles: true\n                }));\n                input.dispatchEvent(new Event('change', {\n                  bubbles: true\n                }));\n              }, value));\n            }));\n          case 'unknown':\n            throw new Error(`Element cannot be filled out.`);\n        }\n      })).pipe(catchError(err => {\n        void handle.dispose().catch(debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #hover(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), mergeMap(handle => {\n      return from(handle.hover()).pipe(catchError(err => {\n        void handle.dispose().catch(debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #scroll(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), mergeMap(handle => {\n      return from(handle.evaluate((el, scrollTop, scrollLeft) => {\n        if (scrollTop !== undefined) {\n          el.scrollTop = scrollTop;\n        }\n        if (scrollLeft !== undefined) {\n          el.scrollLeft = scrollLeft;\n        }\n      }, options?.scrollTop, options?.scrollLeft)).pipe(catchError(err => {\n        void handle.dispose().catch(debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  /**\n   * Clones the locator.\n   */\n  clone() {\n    return this._clone();\n  }\n  /**\n   * Waits for the locator to get a handle from the page.\n   *\n   * @public\n   */\n  async waitHandle(options) {\n    return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal)));\n  }\n  /**\n   * Waits for the locator to get the serialized value from the page.\n   *\n   * Note this requires the value to be JSON-serializable.\n   *\n   * @public\n   */\n  async wait(options) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      const handle = __addDisposableResource(env_1, await this.waitHandle(options), false);\n      return await handle.jsonValue();\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @public\n   */\n  map(mapper) {\n    return new MappedLocator(this._clone(), handle => {\n      // SAFETY: TypeScript cannot deduce the type.\n      return handle.evaluateHandle(mapper);\n    });\n  }\n  /**\n   * Creates an expectation that is evaluated against located values.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @public\n   */\n  filter(predicate) {\n    return new FilteredLocator(this._clone(), async (handle, signal) => {\n      await handle.frame.waitForFunction(predicate, {\n        signal,\n        timeout: this._timeout\n      }, handle);\n      return true;\n    });\n  }\n  /**\n   * Creates an expectation that is evaluated against located handles.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @internal\n   */\n  filterHandle(predicate) {\n    return new FilteredLocator(this._clone(), predicate);\n  }\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @internal\n   */\n  mapHandle(mapper) {\n    return new MappedLocator(this._clone(), mapper);\n  }\n  click(options) {\n    return firstValueFrom(this.#click(options));\n  }\n  /**\n   * Fills out the input identified by the locator using the provided value. The\n   * type of the input is determined at runtime and the appropriate fill-out\n   * method is chosen based on the type. contenteditable, selector, inputs are\n   * supported.\n   */\n  fill(value, options) {\n    return firstValueFrom(this.#fill(value, options));\n  }\n  hover(options) {\n    return firstValueFrom(this.#hover(options));\n  }\n  scroll(options) {\n    return firstValueFrom(this.#scroll(options));\n  }\n}\n/**\n * @internal\n */\nexport class FunctionLocator extends Locator {\n  static create(pageOrFrame, func) {\n    return new FunctionLocator(pageOrFrame, func).setTimeout('getDefaultTimeout' in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());\n  }\n  #pageOrFrame;\n  #func;\n  constructor(pageOrFrame, func) {\n    super();\n    this.#pageOrFrame = pageOrFrame;\n    this.#func = func;\n  }\n  _clone() {\n    return new FunctionLocator(this.#pageOrFrame, this.#func);\n  }\n  _wait(options) {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(this.#pageOrFrame.waitForFunction(this.#func, {\n        timeout: this.timeout,\n        signal\n      }));\n    }).pipe(throwIfEmpty());\n  }\n}\n/**\n * @internal\n */\nexport class DelegatedLocator extends Locator {\n  #delegate;\n  constructor(delegate) {\n    super();\n    this.#delegate = delegate;\n    this.copyOptions(this.#delegate);\n  }\n  get delegate() {\n    return this.#delegate;\n  }\n  setTimeout(timeout) {\n    const locator = super.setTimeout(timeout);\n    locator.#delegate = this.#delegate.setTimeout(timeout);\n    return locator;\n  }\n  setVisibility(visibility) {\n    const locator = super.setVisibility(visibility);\n    locator.#delegate = locator.#delegate.setVisibility(visibility);\n    return locator;\n  }\n  setWaitForEnabled(value) {\n    const locator = super.setWaitForEnabled(value);\n    locator.#delegate = this.#delegate.setWaitForEnabled(value);\n    return locator;\n  }\n  setEnsureElementIsInTheViewport(value) {\n    const locator = super.setEnsureElementIsInTheViewport(value);\n    locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);\n    return locator;\n  }\n  setWaitForStableBoundingBox(value) {\n    const locator = super.setWaitForStableBoundingBox(value);\n    locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);\n    return locator;\n  }\n}\n/**\n * @internal\n */\nexport class FilteredLocator extends DelegatedLocator {\n  #predicate;\n  constructor(base, predicate) {\n    super(base);\n    this.#predicate = predicate;\n  }\n  _clone() {\n    return new FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);\n  }\n  _wait(options) {\n    return this.delegate._wait(options).pipe(mergeMap(handle => {\n      return from(Promise.resolve(this.#predicate(handle, options?.signal))).pipe(filter(value => {\n        return value;\n      }), map(() => {\n        // SAFETY: It passed the predicate, so this is correct.\n        return handle;\n      }));\n    }), throwIfEmpty());\n  }\n}\n/**\n * @internal\n */\nexport class MappedLocator extends DelegatedLocator {\n  #mapper;\n  constructor(base, mapper) {\n    super(base);\n    this.#mapper = mapper;\n  }\n  _clone() {\n    return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);\n  }\n  _wait(options) {\n    return this.delegate._wait(options).pipe(mergeMap(handle => {\n      return from(Promise.resolve(this.#mapper(handle, options?.signal)));\n    }));\n  }\n}\n/**\n * @internal\n */\nexport class NodeLocator extends Locator {\n  static create(pageOrFrame, selector) {\n    return new NodeLocator(pageOrFrame, selector).setTimeout('getDefaultTimeout' in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());\n  }\n  #pageOrFrame;\n  #selector;\n  constructor(pageOrFrame, selector) {\n    super();\n    this.#pageOrFrame = pageOrFrame;\n    this.#selector = selector;\n  }\n  /**\n   * Waits for the element to become visible or hidden. visibility === 'visible'\n   * means that the element has a computed style, the visibility property other\n   * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===\n   * 'hidden' means the opposite of that.\n   */\n  #waitForVisibilityIfNeeded = handle => {\n    if (!this.visibility) {\n      return EMPTY;\n    }\n    return (() => {\n      switch (this.visibility) {\n        case 'hidden':\n          return defer(() => {\n            return from(handle.isHidden());\n          });\n        case 'visible':\n          return defer(() => {\n            return from(handle.isVisible());\n          });\n      }\n    })().pipe(first(identity), retry({\n      delay: RETRY_DELAY\n    }), ignoreElements());\n  };\n  _clone() {\n    return new NodeLocator(this.#pageOrFrame, this.#selector).copyOptions(this);\n  }\n  _wait(options) {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(this.#pageOrFrame.waitForSelector(this.#selector, {\n        visible: false,\n        timeout: this._timeout,\n        signal\n      }));\n    }).pipe(filter(value => {\n      return value !== null;\n    }), throwIfEmpty(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));\n  }\n}\nfunction checkLocatorArray(locators) {\n  for (const locator of locators) {\n    if (!(locator instanceof Locator)) {\n      throw new Error('Unknown locator for race candidate');\n    }\n  }\n  return locators;\n}\n/**\n * @internal\n */\nexport class RaceLocator extends Locator {\n  static create(locators) {\n    const array = checkLocatorArray(locators);\n    return new RaceLocator(array);\n  }\n  #locators;\n  constructor(locators) {\n    super();\n    this.#locators = locators;\n  }\n  _clone() {\n    return new RaceLocator(this.#locators.map(locator => {\n      return locator.clone();\n    })).copyOptions(this);\n  }\n  _wait(options) {\n    return race(...this.#locators.map(locator => {\n      return locator._wait(options);\n    }));\n  }\n}\n/**\n * For observables coming from promises, a delay is needed, otherwise RxJS will\n * never yield in a permanent failure for a promise.\n *\n * We also don't want RxJS to do promise operations to often, so we bump the\n * delay up to 100ms.\n *\n * @internal\n */\nexport const RETRY_DELAY = 100;","map":{"version":3,"names":["EMPTY","catchError","defaultIfEmpty","defer","filter","first","firstValueFrom","from","fromEvent","identity","ignoreElements","map","merge","mergeMap","noop","pipe","race","raceWith","retry","tap","throwIfEmpty","EventEmitter","debugError","timeout","LocatorEvent","Locator","locators","RaceLocator","create","visibility","_timeout","ensureElementIsInTheViewport","waitForEnabled","waitForStableBoundingBox","operators","conditions","signal","handle","condition","retryAndRaceWithSignalAndTimer","candidates","push","reason","delay","RETRY_DELAY","setTimeout","locator","_clone","setVisibility","setWaitForEnabled","value","setEnsureElementIsInTheViewport","setWaitForStableBoundingBox","copyOptions","waitForEnabledIfNeeded","#waitForEnabledIfNeeded","frame","waitForFunction","element","HTMLElement","isNativeFormControl","includes","nodeName","hasAttribute","waitForStableBoundingBoxIfNeeded","evaluate","Promise","resolve","window","requestAnimationFrame","rect1","getBoundingClientRect","rect2","x","y","width","height","ensureElementIsInTheViewportIfNeeded","isIntersectingViewport","threshold","scrollIntoView","click","#click","options","_wait","emit","Action","undefined","err","dispose","catch","fill","#fill","el","HTMLSelectElement","HTMLTextAreaElement","HTMLInputElement","Set","has","type","isContentEditable","inputType","select","then","input","newValue","currentValue","innerText","length","startsWith","originalValue","substring","textToType","focus","dispatchEvent","Event","bubbles","Error","hover","#hover","scroll","#scroll","scrollTop","scrollLeft","clone","waitHandle","wait","__addDisposableResource","env_1","jsonValue","mapper","MappedLocator","evaluateHandle","predicate","FilteredLocator","filterHandle","mapHandle","FunctionLocator","pageOrFrame","func","getDefaultTimeout","page","constructor","DelegatedLocator","delegate","base","NodeLocator","selector","waitForVisibilityIfNeeded","isHidden","isVisible","waitForSelector","visible","checkLocatorArray","array"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/puppeteer-core/src/api/locators/locators.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {\n  Observable,\n  OperatorFunction,\n} from '../../../third_party/rxjs/rxjs.js';\nimport {\n  EMPTY,\n  catchError,\n  defaultIfEmpty,\n  defer,\n  filter,\n  first,\n  firstValueFrom,\n  from,\n  fromEvent,\n  identity,\n  ignoreElements,\n  map,\n  merge,\n  mergeMap,\n  noop,\n  pipe,\n  race,\n  raceWith,\n  retry,\n  tap,\n  throwIfEmpty,\n} from '../../../third_party/rxjs/rxjs.js';\nimport type {EventType} from '../../common/EventEmitter.js';\nimport {EventEmitter} from '../../common/EventEmitter.js';\nimport type {Awaitable, HandleFor, NodeFor} from '../../common/types.js';\nimport {debugError, timeout} from '../../common/util.js';\nimport type {\n  BoundingBox,\n  ClickOptions,\n  ElementHandle,\n} from '../ElementHandle.js';\nimport type {Frame} from '../Frame.js';\nimport type {Page} from '../Page.js';\n\n/**\n * @public\n */\nexport type VisibilityOption = 'hidden' | 'visible' | null;\n/**\n * @public\n */\nexport interface LocatorOptions {\n  /**\n   * Whether to wait for the element to be `visible` or `hidden`. `null` to\n   * disable visibility checks.\n   */\n  visibility: VisibilityOption;\n  /**\n   * Total timeout for the entire locator operation.\n   *\n   * Pass `0` to disable timeout.\n   *\n   * @defaultValue `Page.getDefaultTimeout()`\n   */\n  timeout: number;\n  /**\n   * Whether to scroll the element into viewport if not in the viewprot already.\n   * @defaultValue `true`\n   */\n  ensureElementIsInTheViewport: boolean;\n  /**\n   * Whether to wait for input elements to become enabled before the action.\n   * Applicable to `click` and `fill` actions.\n   * @defaultValue `true`\n   */\n  waitForEnabled: boolean;\n  /**\n   * Whether to wait for the element's bounding box to be same between two\n   * animation frames.\n   * @defaultValue `true`\n   */\n  waitForStableBoundingBox: boolean;\n}\n/**\n * @public\n */\nexport interface ActionOptions {\n  signal?: AbortSignal;\n}\n/**\n * @public\n */\nexport type LocatorClickOptions = ClickOptions & ActionOptions;\n/**\n * @public\n */\nexport interface LocatorScrollOptions extends ActionOptions {\n  scrollTop?: number;\n  scrollLeft?: number;\n}\n/**\n * All the events that a locator instance may emit.\n *\n * @public\n */\nexport enum LocatorEvent {\n  /**\n   * Emitted every time before the locator performs an action on the located element(s).\n   */\n  Action = 'action',\n}\n\n/**\n * @public\n */\nexport interface LocatorEvents extends Record<EventType, unknown> {\n  [LocatorEvent.Action]: undefined;\n}\n\n/**\n * Locators describe a strategy of locating objects and performing an action on\n * them. If the action fails because the object is not ready for the action, the\n * whole operation is retried. Various preconditions for a successful action are\n * checked automatically.\n *\n * @public\n */\nexport abstract class Locator<T> extends EventEmitter<LocatorEvents> {\n  /**\n   * Creates a race between multiple locators but ensures that only a single one\n   * acts.\n   *\n   * @public\n   */\n  static race<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return RaceLocator.create(locators);\n  }\n\n  /**\n   * Used for nominally typing {@link Locator}.\n   */\n  declare _?: T;\n\n  /**\n   * @internal\n   */\n  protected visibility: VisibilityOption = null;\n  /**\n   * @internal\n   */\n  protected _timeout = 30000;\n  #ensureElementIsInTheViewport = true;\n  #waitForEnabled = true;\n  #waitForStableBoundingBox = true;\n\n  /**\n   * @internal\n   */\n  protected operators = {\n    conditions: (\n      conditions: Array<Action<T, never>>,\n      signal?: AbortSignal\n    ): OperatorFunction<HandleFor<T>, HandleFor<T>> => {\n      return mergeMap((handle: HandleFor<T>) => {\n        return merge(\n          ...conditions.map(condition => {\n            return condition(handle, signal);\n          })\n        ).pipe(defaultIfEmpty(handle));\n      });\n    },\n    retryAndRaceWithSignalAndTimer: <T>(\n      signal?: AbortSignal\n    ): OperatorFunction<T, T> => {\n      const candidates = [];\n      if (signal) {\n        candidates.push(\n          fromEvent(signal, 'abort').pipe(\n            map(() => {\n              throw signal.reason;\n            })\n          )\n        );\n      }\n      candidates.push(timeout(this._timeout));\n      return pipe(\n        retry({delay: RETRY_DELAY}),\n        raceWith<T, never[]>(...candidates)\n      );\n    },\n  };\n\n  // Determines when the locator will timeout for actions.\n  get timeout(): number {\n    return this._timeout;\n  }\n\n  setTimeout(timeout: number): Locator<T> {\n    const locator = this._clone();\n    locator._timeout = timeout;\n    return locator;\n  }\n\n  setVisibility<NodeType extends Node>(\n    this: Locator<NodeType>,\n    visibility: VisibilityOption\n  ): Locator<NodeType> {\n    const locator = this._clone();\n    locator.visibility = visibility;\n    return locator;\n  }\n\n  setWaitForEnabled<NodeType extends Node>(\n    this: Locator<NodeType>,\n    value: boolean\n  ): Locator<NodeType> {\n    const locator = this._clone();\n    locator.#waitForEnabled = value;\n    return locator;\n  }\n\n  setEnsureElementIsInTheViewport<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: boolean\n  ): Locator<ElementType> {\n    const locator = this._clone();\n    locator.#ensureElementIsInTheViewport = value;\n    return locator;\n  }\n\n  setWaitForStableBoundingBox<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: boolean\n  ): Locator<ElementType> {\n    const locator = this._clone();\n    locator.#waitForStableBoundingBox = value;\n    return locator;\n  }\n\n  /**\n   * @internal\n   */\n  copyOptions<T>(locator: Locator<T>): this {\n    this._timeout = locator._timeout;\n    this.visibility = locator.visibility;\n    this.#waitForEnabled = locator.#waitForEnabled;\n    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;\n    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;\n    return this;\n  }\n\n  /**\n   * If the element has a \"disabled\" property, wait for the element to be\n   * enabled.\n   */\n  #waitForEnabledIfNeeded = <ElementType extends Node>(\n    handle: HandleFor<ElementType>,\n    signal?: AbortSignal\n  ): Observable<never> => {\n    if (!this.#waitForEnabled) {\n      return EMPTY;\n    }\n    return from(\n      handle.frame.waitForFunction(\n        element => {\n          if (!(element instanceof HTMLElement)) {\n            return true;\n          }\n          const isNativeFormControl = [\n            'BUTTON',\n            'INPUT',\n            'SELECT',\n            'TEXTAREA',\n            'OPTION',\n            'OPTGROUP',\n          ].includes(element.nodeName);\n          return !isNativeFormControl || !element.hasAttribute('disabled');\n        },\n        {\n          timeout: this._timeout,\n          signal,\n        },\n        handle\n      )\n    ).pipe(ignoreElements());\n  };\n\n  /**\n   * Compares the bounding box of the element for two consecutive animation\n   * frames and waits till they are the same.\n   */\n  #waitForStableBoundingBoxIfNeeded = <ElementType extends Element>(\n    handle: HandleFor<ElementType>\n  ): Observable<never> => {\n    if (!this.#waitForStableBoundingBox) {\n      return EMPTY;\n    }\n    return defer(() => {\n      // Note we don't use waitForFunction because that relies on RAF.\n      return from(\n        handle.evaluate(element => {\n          return new Promise<[BoundingBox, BoundingBox]>(resolve => {\n            window.requestAnimationFrame(() => {\n              const rect1 = element.getBoundingClientRect();\n              window.requestAnimationFrame(() => {\n                const rect2 = element.getBoundingClientRect();\n                resolve([\n                  {\n                    x: rect1.x,\n                    y: rect1.y,\n                    width: rect1.width,\n                    height: rect1.height,\n                  },\n                  {\n                    x: rect2.x,\n                    y: rect2.y,\n                    width: rect2.width,\n                    height: rect2.height,\n                  },\n                ]);\n              });\n            });\n          });\n        })\n      );\n    }).pipe(\n      first(([rect1, rect2]) => {\n        return (\n          rect1.x === rect2.x &&\n          rect1.y === rect2.y &&\n          rect1.width === rect2.width &&\n          rect1.height === rect2.height\n        );\n      }),\n      retry({delay: RETRY_DELAY}),\n      ignoreElements()\n    );\n  };\n\n  /**\n   * Checks if the element is in the viewport and auto-scrolls it if it is not.\n   */\n  #ensureElementIsInTheViewportIfNeeded = <ElementType extends Element>(\n    handle: HandleFor<ElementType>\n  ): Observable<never> => {\n    if (!this.#ensureElementIsInTheViewport) {\n      return EMPTY;\n    }\n    return from(handle.isIntersectingViewport({threshold: 0})).pipe(\n      filter(isIntersectingViewport => {\n        return !isIntersectingViewport;\n      }),\n      mergeMap(() => {\n        return from(handle.scrollIntoView());\n      }),\n      mergeMap(() => {\n        return defer(() => {\n          return from(handle.isIntersectingViewport({threshold: 0}));\n        }).pipe(first(identity), retry({delay: RETRY_DELAY}), ignoreElements());\n      })\n    );\n  };\n\n  #click<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorClickOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n          this.#waitForEnabledIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(handle.click(options)).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #fill<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: string,\n    options?: Readonly<ActionOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n          this.#waitForEnabledIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(\n          (handle as unknown as ElementHandle<HTMLElement>).evaluate(el => {\n            if (el instanceof HTMLSelectElement) {\n              return 'select';\n            }\n            if (el instanceof HTMLTextAreaElement) {\n              return 'typeable-input';\n            }\n            if (el instanceof HTMLInputElement) {\n              if (\n                new Set([\n                  'textarea',\n                  'text',\n                  'url',\n                  'tel',\n                  'search',\n                  'password',\n                  'number',\n                  'email',\n                ]).has(el.type)\n              ) {\n                return 'typeable-input';\n              } else {\n                return 'other-input';\n              }\n            }\n\n            if (el.isContentEditable) {\n              return 'contenteditable';\n            }\n\n            return 'unknown';\n          })\n        )\n          .pipe(\n            mergeMap(inputType => {\n              switch (inputType) {\n                case 'select':\n                  return from(handle.select(value).then(noop));\n                case 'contenteditable':\n                case 'typeable-input':\n                  return from(\n                    (\n                      handle as unknown as ElementHandle<HTMLInputElement>\n                    ).evaluate((input, newValue) => {\n                      const currentValue = input.isContentEditable\n                        ? input.innerText\n                        : input.value;\n\n                      // Clear the input if the current value does not match the filled\n                      // out value.\n                      if (\n                        newValue.length <= currentValue.length ||\n                        !newValue.startsWith(input.value)\n                      ) {\n                        if (input.isContentEditable) {\n                          input.innerText = '';\n                        } else {\n                          input.value = '';\n                        }\n                        return newValue;\n                      }\n                      const originalValue = input.isContentEditable\n                        ? input.innerText\n                        : input.value;\n\n                      // If the value is partially filled out, only type the rest. Move\n                      // cursor to the end of the common prefix.\n                      if (input.isContentEditable) {\n                        input.innerText = '';\n                        input.innerText = originalValue;\n                      } else {\n                        input.value = '';\n                        input.value = originalValue;\n                      }\n                      return newValue.substring(originalValue.length);\n                    }, value)\n                  ).pipe(\n                    mergeMap(textToType => {\n                      return from(handle.type(textToType));\n                    })\n                  );\n                case 'other-input':\n                  return from(handle.focus()).pipe(\n                    mergeMap(() => {\n                      return from(\n                        handle.evaluate((input, value) => {\n                          (input as HTMLInputElement).value = value;\n                          input.dispatchEvent(\n                            new Event('input', {bubbles: true})\n                          );\n                          input.dispatchEvent(\n                            new Event('change', {bubbles: true})\n                          );\n                        }, value)\n                      );\n                    })\n                  );\n                case 'unknown':\n                  throw new Error(`Element cannot be filled out.`);\n              }\n            })\n          )\n          .pipe(\n            catchError(err => {\n              void handle.dispose().catch(debugError);\n              throw err;\n            })\n          );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #hover<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<ActionOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(handle.hover()).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #scroll<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorScrollOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(\n          handle.evaluate(\n            (el, scrollTop, scrollLeft) => {\n              if (scrollTop !== undefined) {\n                el.scrollTop = scrollTop;\n              }\n              if (scrollLeft !== undefined) {\n                el.scrollLeft = scrollLeft;\n              }\n            },\n            options?.scrollTop,\n            options?.scrollLeft\n          )\n        ).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  /**\n   * @internal\n   */\n  abstract _clone(): Locator<T>;\n\n  /**\n   * @internal\n   */\n  abstract _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>>;\n\n  /**\n   * Clones the locator.\n   */\n  clone(): Locator<T> {\n    return this._clone();\n  }\n\n  /**\n   * Waits for the locator to get a handle from the page.\n   *\n   * @public\n   */\n  async waitHandle(options?: Readonly<ActionOptions>): Promise<HandleFor<T>> {\n    return await firstValueFrom(\n      this._wait(options).pipe(\n        this.operators.retryAndRaceWithSignalAndTimer(options?.signal)\n      )\n    );\n  }\n\n  /**\n   * Waits for the locator to get the serialized value from the page.\n   *\n   * Note this requires the value to be JSON-serializable.\n   *\n   * @public\n   */\n  async wait(options?: Readonly<ActionOptions>): Promise<T> {\n    using handle = await this.waitHandle(options);\n    return await handle.jsonValue();\n  }\n\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @public\n   */\n  map<To>(mapper: Mapper<T, To>): Locator<To> {\n    return new MappedLocator(this._clone(), handle => {\n      // SAFETY: TypeScript cannot deduce the type.\n      return (handle as any).evaluateHandle(mapper);\n    });\n  }\n\n  /**\n   * Creates an expectation that is evaluated against located values.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @public\n   */\n  filter<S extends T>(predicate: Predicate<T, S>): Locator<S> {\n    return new FilteredLocator(this._clone(), async (handle, signal) => {\n      await (handle as ElementHandle<Node>).frame.waitForFunction(\n        predicate,\n        {signal, timeout: this._timeout},\n        handle\n      );\n      return true;\n    });\n  }\n\n  /**\n   * Creates an expectation that is evaluated against located handles.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @internal\n   */\n  filterHandle<S extends T>(\n    predicate: Predicate<HandleFor<T>, HandleFor<S>>\n  ): Locator<S> {\n    return new FilteredLocator(this._clone(), predicate);\n  }\n\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @internal\n   */\n  mapHandle<To>(mapper: HandleMapper<T, To>): Locator<To> {\n    return new MappedLocator(this._clone(), mapper);\n  }\n\n  click<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorClickOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#click(options));\n  }\n\n  /**\n   * Fills out the input identified by the locator using the provided value. The\n   * type of the input is determined at runtime and the appropriate fill-out\n   * method is chosen based on the type. contenteditable, selector, inputs are\n   * supported.\n   */\n  fill<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: string,\n    options?: Readonly<ActionOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#fill(value, options));\n  }\n\n  hover<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<ActionOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#hover(options));\n  }\n\n  scroll<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorScrollOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#scroll(options));\n  }\n}\n\n/**\n * @internal\n */\nexport class FunctionLocator<T> extends Locator<T> {\n  static create<Ret>(\n    pageOrFrame: Page | Frame,\n    func: () => Awaitable<Ret>\n  ): Locator<Ret> {\n    return new FunctionLocator<Ret>(pageOrFrame, func).setTimeout(\n      'getDefaultTimeout' in pageOrFrame\n        ? pageOrFrame.getDefaultTimeout()\n        : pageOrFrame.page().getDefaultTimeout()\n    );\n  }\n\n  #pageOrFrame: Page | Frame;\n  #func: () => Awaitable<T>;\n\n  private constructor(pageOrFrame: Page | Frame, func: () => Awaitable<T>) {\n    super();\n\n    this.#pageOrFrame = pageOrFrame;\n    this.#func = func;\n  }\n\n  override _clone(): FunctionLocator<T> {\n    return new FunctionLocator(this.#pageOrFrame, this.#func);\n  }\n\n  _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(\n        this.#pageOrFrame.waitForFunction(this.#func, {\n          timeout: this.timeout,\n          signal,\n        })\n      );\n    }).pipe(throwIfEmpty());\n  }\n}\n\n/**\n * @public\n */\nexport type Predicate<From, To extends From = From> =\n  | ((value: From) => value is To)\n  | ((value: From) => Awaitable<boolean>);\n/**\n * @internal\n */\nexport type HandlePredicate<From, To extends From = From> =\n  | ((value: HandleFor<From>, signal?: AbortSignal) => value is HandleFor<To>)\n  | ((value: HandleFor<From>, signal?: AbortSignal) => Awaitable<boolean>);\n\n/**\n * @internal\n */\nexport abstract class DelegatedLocator<T, U> extends Locator<U> {\n  #delegate: Locator<T>;\n\n  constructor(delegate: Locator<T>) {\n    super();\n\n    this.#delegate = delegate;\n    this.copyOptions(this.#delegate);\n  }\n\n  protected get delegate(): Locator<T> {\n    return this.#delegate;\n  }\n\n  override setTimeout(timeout: number): DelegatedLocator<T, U> {\n    const locator = super.setTimeout(timeout) as DelegatedLocator<T, U>;\n    locator.#delegate = this.#delegate.setTimeout(timeout);\n    return locator;\n  }\n\n  override setVisibility<ValueType extends Node, NodeType extends Node>(\n    this: DelegatedLocator<ValueType, NodeType>,\n    visibility: VisibilityOption\n  ): DelegatedLocator<ValueType, NodeType> {\n    const locator = super.setVisibility<NodeType>(\n      visibility\n    ) as DelegatedLocator<ValueType, NodeType>;\n    locator.#delegate = locator.#delegate.setVisibility<ValueType>(visibility);\n    return locator;\n  }\n\n  override setWaitForEnabled<ValueType extends Node, NodeType extends Node>(\n    this: DelegatedLocator<ValueType, NodeType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, NodeType> {\n    const locator = super.setWaitForEnabled<NodeType>(\n      value\n    ) as DelegatedLocator<ValueType, NodeType>;\n    locator.#delegate = this.#delegate.setWaitForEnabled(value);\n    return locator;\n  }\n\n  override setEnsureElementIsInTheViewport<\n    ValueType extends Element,\n    ElementType extends Element,\n  >(\n    this: DelegatedLocator<ValueType, ElementType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, ElementType> {\n    const locator = super.setEnsureElementIsInTheViewport<ElementType>(\n      value\n    ) as DelegatedLocator<ValueType, ElementType>;\n    locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);\n    return locator;\n  }\n\n  override setWaitForStableBoundingBox<\n    ValueType extends Element,\n    ElementType extends Element,\n  >(\n    this: DelegatedLocator<ValueType, ElementType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, ElementType> {\n    const locator = super.setWaitForStableBoundingBox<ElementType>(\n      value\n    ) as DelegatedLocator<ValueType, ElementType>;\n    locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);\n    return locator;\n  }\n\n  abstract override _clone(): DelegatedLocator<T, U>;\n  abstract override _wait(): Observable<HandleFor<U>>;\n}\n\n/**\n * @internal\n */\nexport class FilteredLocator<From, To extends From> extends DelegatedLocator<\n  From,\n  To\n> {\n  #predicate: HandlePredicate<From, To>;\n\n  constructor(base: Locator<From>, predicate: HandlePredicate<From, To>) {\n    super(base);\n    this.#predicate = predicate;\n  }\n\n  override _clone(): FilteredLocator<From, To> {\n    return new FilteredLocator(\n      this.delegate.clone(),\n      this.#predicate\n    ).copyOptions(this);\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<To>> {\n    return this.delegate._wait(options).pipe(\n      mergeMap(handle => {\n        return from(\n          Promise.resolve(this.#predicate(handle, options?.signal))\n        ).pipe(\n          filter(value => {\n            return value;\n          }),\n          map(() => {\n            // SAFETY: It passed the predicate, so this is correct.\n            return handle as HandleFor<To>;\n          })\n        );\n      }),\n      throwIfEmpty()\n    );\n  }\n}\n\n/**\n * @public\n */\nexport type Mapper<From, To> = (value: From) => Awaitable<To>;\n/**\n * @internal\n */\nexport type HandleMapper<From, To> = (\n  value: HandleFor<From>,\n  signal?: AbortSignal\n) => Awaitable<HandleFor<To>>;\n/**\n * @internal\n */\nexport class MappedLocator<From, To> extends DelegatedLocator<From, To> {\n  #mapper: HandleMapper<From, To>;\n\n  constructor(base: Locator<From>, mapper: HandleMapper<From, To>) {\n    super(base);\n    this.#mapper = mapper;\n  }\n\n  override _clone(): MappedLocator<From, To> {\n    return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(\n      this\n    );\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<To>> {\n    return this.delegate._wait(options).pipe(\n      mergeMap(handle => {\n        return from(Promise.resolve(this.#mapper(handle, options?.signal)));\n      })\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport type Action<T, U> = (\n  element: HandleFor<T>,\n  signal?: AbortSignal\n) => Observable<U>;\n/**\n * @internal\n */\nexport class NodeLocator<T extends Node> extends Locator<T> {\n  static create<Selector extends string>(\n    pageOrFrame: Page | Frame,\n    selector: Selector\n  ): Locator<NodeFor<Selector>> {\n    return new NodeLocator<NodeFor<Selector>>(pageOrFrame, selector).setTimeout(\n      'getDefaultTimeout' in pageOrFrame\n        ? pageOrFrame.getDefaultTimeout()\n        : pageOrFrame.page().getDefaultTimeout()\n    );\n  }\n\n  #pageOrFrame: Page | Frame;\n  #selector: string;\n\n  private constructor(pageOrFrame: Page | Frame, selector: string) {\n    super();\n\n    this.#pageOrFrame = pageOrFrame;\n    this.#selector = selector;\n  }\n\n  /**\n   * Waits for the element to become visible or hidden. visibility === 'visible'\n   * means that the element has a computed style, the visibility property other\n   * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===\n   * 'hidden' means the opposite of that.\n   */\n  #waitForVisibilityIfNeeded = (handle: HandleFor<T>): Observable<never> => {\n    if (!this.visibility) {\n      return EMPTY;\n    }\n\n    return (() => {\n      switch (this.visibility) {\n        case 'hidden':\n          return defer(() => {\n            return from(handle.isHidden());\n          });\n        case 'visible':\n          return defer(() => {\n            return from(handle.isVisible());\n          });\n      }\n    })().pipe(first(identity), retry({delay: RETRY_DELAY}), ignoreElements());\n  };\n\n  override _clone(): NodeLocator<T> {\n    return new NodeLocator<T>(this.#pageOrFrame, this.#selector).copyOptions(\n      this\n    );\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(\n        this.#pageOrFrame.waitForSelector(this.#selector, {\n          visible: false,\n          timeout: this._timeout,\n          signal,\n        }) as Promise<HandleFor<T> | null>\n      );\n    }).pipe(\n      filter((value): value is NonNullable<typeof value> => {\n        return value !== null;\n      }),\n      throwIfEmpty(),\n      this.operators.conditions([this.#waitForVisibilityIfNeeded], signal)\n    );\n  }\n}\n\n/**\n * @public\n */\nexport type AwaitedLocator<T> = T extends Locator<infer S> ? S : never;\nfunction checkLocatorArray<T extends readonly unknown[] | []>(\n  locators: T\n): ReadonlyArray<Locator<AwaitedLocator<T[number]>>> {\n  for (const locator of locators) {\n    if (!(locator instanceof Locator)) {\n      throw new Error('Unknown locator for race candidate');\n    }\n  }\n  return locators as ReadonlyArray<Locator<AwaitedLocator<T[number]>>>;\n}\n/**\n * @internal\n */\nexport class RaceLocator<T> extends Locator<T> {\n  static create<T extends readonly unknown[]>(\n    locators: T\n  ): Locator<AwaitedLocator<T[number]>> {\n    const array = checkLocatorArray(locators);\n    return new RaceLocator(array);\n  }\n\n  #locators: ReadonlyArray<Locator<T>>;\n\n  constructor(locators: ReadonlyArray<Locator<T>>) {\n    super();\n    this.#locators = locators;\n  }\n\n  override _clone(): RaceLocator<T> {\n    return new RaceLocator<T>(\n      this.#locators.map(locator => {\n        return locator.clone();\n      })\n    ).copyOptions(this);\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    return race(\n      ...this.#locators.map(locator => {\n        return locator._wait(options);\n      })\n    );\n  }\n}\n\n/**\n * For observables coming from promises, a delay is needed, otherwise RxJS will\n * never yield in a permanent failure for a promise.\n *\n * We also don't want RxJS to do promise operations to often, so we bump the\n * delay up to 100ms.\n *\n * @internal\n */\nexport const RETRY_DELAY = 100;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}