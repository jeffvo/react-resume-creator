{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { Realm } from '../api/Realm.js';\nimport { debugError, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { disposeSymbol } from '../util/disposable.js';\nimport { Mutex } from '../util/Mutex.js';\nimport { ExecutionContext, createCdpHandle } from './ExecutionContext.js';\nimport { addPageBinding } from './utils.js';\n/**\n * @internal\n */\nexport class IsolatedWorld extends Realm {\n  #context = Deferred.create();\n  // Set of bindings that have been registered in the current context.\n  #contextBindings = new Set();\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map();\n  get _bindings() {\n    return this.#bindings;\n  }\n  #frameOrWorker;\n  constructor(frameOrWorker, timeoutSettings) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n    this.frameUpdated();\n  }\n  get environment() {\n    return this.#frameOrWorker;\n  }\n  frameUpdated() {\n    this.client.on('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n  get client() {\n    return this.#frameOrWorker.client;\n  }\n  clearContext() {\n    // The message has to match the CDP message expected by the WaitTask class.\n    this.#context?.reject(new Error('Execution context was destroyed'));\n    this.#context = Deferred.create();\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n  setContext(context) {\n    this.#contextBindings.clear();\n    this.#context.resolve(context);\n    void this.taskManager.rerunAll();\n  }\n  hasContext() {\n    return this.#context.resolved();\n  }\n  #executionContext() {\n    if (this.disposed) {\n      throw new Error(`Execution context is not available in detached frame \"${this.environment.url()}\" (are you trying to evaluate?)`);\n    }\n    if (this.#context === null) {\n      throw new Error(`Execution content promise is missing`);\n    }\n    return this.#context.valueOrThrow();\n  }\n  async evaluateHandle(pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n    const context = await this.#executionContext();\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n  async evaluate(pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n    let context = this.#context.value();\n    if (!context || !(context instanceof ExecutionContext)) {\n      context = await this.#executionContext();\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async _addBindingToContext(context, name) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      if (this.#contextBindings.has(name)) {\n        return;\n      }\n      const _ = __addDisposableResource(env_1, await this.#mutex.acquire(), false);\n      try {\n        await context._client.send('Runtime.addBinding', context._contextName ? {\n          name,\n          executionContextName: context._contextName\n        } : {\n          name,\n          executionContextId: context._contextId\n        });\n        await context.evaluate(addPageBinding, 'internal', name);\n        this.#contextBindings.add(name);\n      } catch (error) {\n        // We could have tried to evaluate in a context which was already\n        // destroyed. This happens, for example, if the page is navigated while\n        // we are trying to add the binding\n        if (error instanceof Error) {\n          // Destroyed context.\n          if (error.message.includes('Execution context was destroyed')) {\n            return;\n          }\n          // Missing context.\n          if (error.message.includes('Cannot find context with specified id')) {\n            return;\n          }\n        }\n        debugError(error);\n      }\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  #onBindingCalled = async event => {\n    let payload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {\n      type,\n      name,\n      seq,\n      args,\n      isTrivial\n    } = payload;\n    if (type !== 'internal') {\n      return;\n    }\n    if (!this.#contextBindings.has(name)) {\n      return;\n    }\n    try {\n      const context = await this.#context.valueOrThrow();\n      if (event.executionContextId !== context._contextId) {\n        return;\n      }\n      const binding = this._bindings.get(name);\n      await binding?.run(context, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  };\n  async adoptBackendNode(backendNodeId) {\n    const executionContext = await this.#executionContext();\n    const {\n      object\n    } = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: executionContext._contextId\n    });\n    return createCdpHandle(this, object);\n  }\n  async adoptHandle(handle) {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return await handle.evaluateHandle(value => {\n        return value;\n      });\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id\n    });\n    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);\n  }\n  async transferHandle(handle) {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId\n    });\n    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);\n    await handle.dispose();\n    return newHandle;\n  }\n  [disposeSymbol]() {\n    super[disposeSymbol]();\n    this.client.off('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n}","map":{"version":3,"names":["Realm","debugError","withSourcePuppeteerURLIfNone","Deferred","disposeSymbol","Mutex","ExecutionContext","createCdpHandle","addPageBinding","IsolatedWorld","context","create","contextBindings","Set","bindings","Map","_bindings","frameOrWorker","constructor","timeoutSettings","frameUpdated","environment","client","on","onBindingCalled","clearContext","reject","Error","clearDocumentHandle","setContext","clear","resolve","taskManager","rerunAll","hasContext","resolved","executionContext","#executionContext","disposed","url","valueOrThrow","evaluateHandle","pageFunction","args","name","evaluate","value","mutex","_addBindingToContext","has","_","__addDisposableResource","env_1","acquire","_client","send","_contextName","executionContextName","executionContextId","_contextId","add","error","message","includes","event","payload","JSON","parse","type","seq","isTrivial","binding","get","run","err","adoptBackendNode","backendNodeId","object","adoptHandle","handle","realm","nodeInfo","objectId","id","node","transferHandle","remoteObject","undefined","info","newHandle","dispose","off"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/puppeteer-core/src/cdp/IsolatedWorld.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {Realm} from '../api/Realm.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {BindingPayload, EvaluateFunc, HandleFor} from '../common/types.js';\nimport {debugError, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {disposeSymbol} from '../util/disposable.js';\nimport {Mutex} from '../util/Mutex.js';\n\nimport type {Binding} from './Binding.js';\nimport {ExecutionContext, createCdpHandle} from './ExecutionContext.js';\nimport type {CdpFrame} from './Frame.js';\nimport type {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {addPageBinding} from './utils.js';\nimport type {CdpWebWorker} from './WebWorker.js';\n\n/**\n * @internal\n */\nexport interface PageBinding {\n  name: string;\n  pptrFunction: Function;\n}\n\n/**\n * @internal\n */\nexport interface IsolatedWorldChart {\n  [key: string]: IsolatedWorld;\n  [MAIN_WORLD]: IsolatedWorld;\n  [PUPPETEER_WORLD]: IsolatedWorld;\n}\n\n/**\n * @internal\n */\nexport class IsolatedWorld extends Realm {\n  #context = Deferred.create<ExecutionContext>();\n\n  // Set of bindings that have been registered in the current context.\n  #contextBindings = new Set<string>();\n\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map<string, Binding>();\n\n  get _bindings(): Map<string, Binding> {\n    return this.#bindings;\n  }\n\n  readonly #frameOrWorker: CdpFrame | CdpWebWorker;\n\n  constructor(\n    frameOrWorker: CdpFrame | CdpWebWorker,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n    this.frameUpdated();\n  }\n\n  get environment(): CdpFrame | CdpWebWorker {\n    return this.#frameOrWorker;\n  }\n\n  frameUpdated(): void {\n    this.client.on('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n\n  get client(): CDPSession {\n    return this.#frameOrWorker.client;\n  }\n\n  clearContext(): void {\n    // The message has to match the CDP message expected by the WaitTask class.\n    this.#context?.reject(new Error('Execution context was destroyed'));\n    this.#context = Deferred.create();\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n\n  setContext(context: ExecutionContext): void {\n    this.#contextBindings.clear();\n    this.#context.resolve(context);\n    void this.taskManager.rerunAll();\n  }\n\n  hasContext(): boolean {\n    return this.#context.resolved();\n  }\n\n  #executionContext(): Promise<ExecutionContext> {\n    if (this.disposed) {\n      throw new Error(\n        `Execution context is not available in detached frame \"${this.environment.url()}\" (are you trying to evaluate?)`\n      );\n    }\n    if (this.#context === null) {\n      throw new Error(`Execution content promise is missing`);\n    }\n    return this.#context.valueOrThrow();\n  }\n\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    const context = await this.#executionContext();\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    let context = this.#context.value();\n    if (!context || !(context instanceof ExecutionContext)) {\n      context = await this.#executionContext();\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async _addBindingToContext(\n    context: ExecutionContext,\n    name: string\n  ): Promise<void> {\n    if (this.#contextBindings.has(name)) {\n      return;\n    }\n\n    using _ = await this.#mutex.acquire();\n    try {\n      await context._client.send(\n        'Runtime.addBinding',\n        context._contextName\n          ? {\n              name,\n              executionContextName: context._contextName,\n            }\n          : {\n              name,\n              executionContextId: context._contextId,\n            }\n      );\n\n      await context.evaluate(addPageBinding, 'internal', name);\n\n      this.#contextBindings.add(name);\n    } catch (error) {\n      // We could have tried to evaluate in a context which was already\n      // destroyed. This happens, for example, if the page is navigated while\n      // we are trying to add the binding\n      if (error instanceof Error) {\n        // Destroyed context.\n        if (error.message.includes('Execution context was destroyed')) {\n          return;\n        }\n        // Missing context.\n        if (error.message.includes('Cannot find context with specified id')) {\n          return;\n        }\n      }\n\n      debugError(error);\n    }\n  }\n\n  #onBindingCalled = async (\n    event: Protocol.Runtime.BindingCalledEvent\n  ): Promise<void> => {\n    let payload: BindingPayload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {type, name, seq, args, isTrivial} = payload;\n    if (type !== 'internal') {\n      return;\n    }\n    if (!this.#contextBindings.has(name)) {\n      return;\n    }\n\n    try {\n      const context = await this.#context.valueOrThrow();\n      if (event.executionContextId !== context._contextId) {\n        return;\n      }\n\n      const binding = this._bindings.get(name);\n      await binding?.run(context, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  };\n\n  override async adoptBackendNode(\n    backendNodeId?: Protocol.DOM.BackendNodeId\n  ): Promise<JSHandle<Node>> {\n    const executionContext = await this.#executionContext();\n    const {object} = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: executionContext._contextId,\n    });\n    return createCdpHandle(this, object) as JSHandle<Node>;\n  }\n\n  async adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return (await handle.evaluateHandle(value => {\n        return value;\n      })) as unknown as T;\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id,\n    });\n    return (await this.adoptBackendNode(nodeInfo.node.backendNodeId)) as T;\n  }\n\n  async transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId,\n    });\n    const newHandle = (await this.adoptBackendNode(\n      info.node.backendNodeId\n    )) as T;\n    await handle.dispose();\n    return newHandle;\n  }\n\n  [disposeSymbol](): void {\n    super[disposeSymbol]();\n    this.client.off('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}