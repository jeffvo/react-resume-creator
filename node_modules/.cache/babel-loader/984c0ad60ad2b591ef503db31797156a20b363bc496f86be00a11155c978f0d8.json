{"ast":null,"code":"var tokenize = require('../tokenizer');\nvar TokenStream = require('../common/TokenStream');\nvar tokenStream = new TokenStream();\nvar astToTokens = {\n  decorator: function (handlers) {\n    var curNode = null;\n    var prev = {\n      len: 0,\n      node: null\n    };\n    var nodes = [prev];\n    var buffer = '';\n    return {\n      children: handlers.children,\n      node: function (node) {\n        var tmp = curNode;\n        curNode = node;\n        handlers.node.call(this, node);\n        curNode = tmp;\n      },\n      chunk: function (chunk) {\n        buffer += chunk;\n        if (prev.node !== curNode) {\n          nodes.push({\n            len: chunk.length,\n            node: curNode\n          });\n        } else {\n          prev.len += chunk.length;\n        }\n      },\n      result: function () {\n        return prepareTokens(buffer, nodes);\n      }\n    };\n  }\n};\nfunction prepareTokens(str, nodes) {\n  var tokens = [];\n  var nodesOffset = 0;\n  var nodesIndex = 0;\n  var currentNode = nodes ? nodes[nodesIndex].node : null;\n  tokenize(str, tokenStream);\n  while (!tokenStream.eof) {\n    if (nodes) {\n      while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {\n        nodesOffset += nodes[nodesIndex++].len;\n        currentNode = nodes[nodesIndex].node;\n      }\n    }\n    tokens.push({\n      type: tokenStream.tokenType,\n      value: tokenStream.getTokenValue(),\n      index: tokenStream.tokenIndex,\n      // TODO: remove it, temporary solution\n      balance: tokenStream.balance[tokenStream.tokenIndex],\n      // TODO: remove it, temporary solution\n      node: currentNode\n    });\n    tokenStream.next();\n    // console.log({ ...tokens[tokens.length - 1], node: undefined });\n  }\n  return tokens;\n}\nmodule.exports = function (value, syntax) {\n  if (typeof value === 'string') {\n    return prepareTokens(value, null);\n  }\n  return syntax.generate(value, astToTokens);\n};","map":{"version":3,"names":["tokenize","require","TokenStream","tokenStream","astToTokens","decorator","handlers","curNode","prev","len","node","nodes","buffer","children","tmp","call","chunk","push","length","result","prepareTokens","str","tokens","nodesOffset","nodesIndex","currentNode","eof","tokenStart","type","tokenType","value","getTokenValue","index","tokenIndex","balance","next","module","exports","syntax","generate"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/prepare-tokens.js"],"sourcesContent":["var tokenize = require('../tokenizer');\nvar TokenStream = require('../common/TokenStream');\nvar tokenStream = new TokenStream();\nvar astToTokens = {\n    decorator: function(handlers) {\n        var curNode = null;\n        var prev = { len: 0, node: null };\n        var nodes = [prev];\n        var buffer = '';\n\n        return {\n            children: handlers.children,\n            node: function(node) {\n                var tmp = curNode;\n                curNode = node;\n                handlers.node.call(this, node);\n                curNode = tmp;\n            },\n            chunk: function(chunk) {\n                buffer += chunk;\n                if (prev.node !== curNode) {\n                    nodes.push({\n                        len: chunk.length,\n                        node: curNode\n                    });\n                } else {\n                    prev.len += chunk.length;\n                }\n            },\n            result: function() {\n                return prepareTokens(buffer, nodes);\n            }\n        };\n    }\n};\n\nfunction prepareTokens(str, nodes) {\n    var tokens = [];\n    var nodesOffset = 0;\n    var nodesIndex = 0;\n    var currentNode = nodes ? nodes[nodesIndex].node : null;\n\n    tokenize(str, tokenStream);\n\n    while (!tokenStream.eof) {\n        if (nodes) {\n            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {\n                nodesOffset += nodes[nodesIndex++].len;\n                currentNode = nodes[nodesIndex].node;\n            }\n        }\n\n        tokens.push({\n            type: tokenStream.tokenType,\n            value: tokenStream.getTokenValue(),\n            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution\n            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution\n            node: currentNode\n        });\n        tokenStream.next();\n        // console.log({ ...tokens[tokens.length - 1], node: undefined });\n    }\n\n    return tokens;\n}\n\nmodule.exports = function(value, syntax) {\n    if (typeof value === 'string') {\n        return prepareTokens(value, null);\n    }\n\n    return syntax.generate(value, astToTokens);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}