{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { FrameEvent } from '../api/Frame.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { debugError, PuppeteerURL, UTILITY_WORLD_NAME } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { disposeSymbol } from '../util/disposable.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { CdpCDPSession } from './CDPSession.js';\nimport { isTargetClosedError } from './Connection.js';\nimport { DeviceRequestPromptManager } from './DeviceRequestPrompt.js';\nimport { ExecutionContext } from './ExecutionContext.js';\nimport { CdpFrame } from './Frame.js';\nimport { FrameManagerEvent } from './FrameManagerEvents.js';\nimport { FrameTree } from './FrameTree.js';\nimport { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';\nimport { NetworkManager } from './NetworkManager.js';\nconst TIME_FOR_WAITING_FOR_SWAP = 100; // ms.\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter {\n  #page;\n  #networkManager;\n  #timeoutSettings;\n  #contextIdToContext = new Map();\n  #isolatedWorlds = new Set();\n  #client;\n  _frameTree = new FrameTree();\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set();\n  #deviceRequestPromptManagerMap = new WeakMap();\n  #frameTreeHandled;\n  get timeoutSettings() {\n    return this.#timeoutSettings;\n  }\n  get networkManager() {\n    return this.#networkManager;\n  }\n  get client() {\n    return this.#client;\n  }\n  constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(ignoreHTTPSErrors, this);\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n  }\n  /**\n   * Called when the frame's client is disconnected. We don't know if the\n   * disconnect means that the frame is removed or if it will be replaced by a\n   * new frame. Therefore, we wait for a swap event.\n   */\n  async #onClientDisconnect() {\n    const mainFrame = this._frameTree.getMainFrame();\n    if (!mainFrame) {\n      return;\n    }\n    for (const child of mainFrame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    const swapped = Deferred.create({\n      timeout: TIME_FOR_WAITING_FOR_SWAP,\n      message: 'Frame was not swapped'\n    });\n    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {\n      swapped.resolve();\n    });\n    try {\n      await swapped.valueOrThrow();\n    } catch (err) {\n      this.#removeFramesRecursively(mainFrame);\n    }\n  }\n  /**\n   * When the main frame is replaced by another main frame,\n   * we maintain the main frame object identity while updating\n   * its frame tree and ID.\n   */\n  async swapFrameTree(client) {\n    this.#onExecutionContextsCleared(this.#client);\n    this.#client = client;\n    assert(this.#client instanceof CdpCDPSession, 'CDPSession is not an instance of CDPSessionImpl.');\n    const frame = this._frameTree.getMainFrame();\n    if (frame) {\n      this.#frameNavigatedReceived.add(this.#client._target()._targetId);\n      this._frameTree.removeFrame(frame);\n      frame.updateId(this.#client._target()._targetId);\n      frame.mainRealm().clearContext();\n      frame.isolatedRealm().clearContext();\n      this._frameTree.addFrame(frame);\n      frame.updateClient(client, true);\n    }\n    this.setupEventListeners(client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n    await this.initialize(client);\n    await this.#networkManager.addClient(client);\n    if (frame) {\n      frame.emit(FrameEvent.FrameSwappedByActivation, undefined);\n    }\n  }\n  async registerSpeculativeSession(client) {\n    await this.#networkManager.addClient(client);\n  }\n  setupEventListeners(session) {\n    session.on('Page.frameAttached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', async event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      await this.#frameTreeHandled?.valueOrThrow();\n      void this.#onFrameNavigated(event.frame, event.type);\n    });\n    session.on('Page.navigatedWithinDocument', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on('Page.frameDetached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameDetached(event.frameId, event.reason);\n    });\n    session.on('Page.frameStartedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', async () => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onLifecycleEvent(event);\n    });\n  }\n  async initialize(client) {\n    try {\n      this.#frameTreeHandled?.resolve();\n      this.#frameTreeHandled = Deferred.create();\n      // We need to schedule all these commands while the target is paused,\n      // therefore, it needs to happen synchroniously. At the same time we\n      // should not start processing execution context and frame events before\n      // we received the initial information about the frame tree.\n      await Promise.all([this.#networkManager.addClient(client), client.send('Page.enable'), client.send('Page.getFrameTree').then(({\n        frameTree\n      }) => {\n        this.#handleFrameTree(client, frameTree);\n        this.#frameTreeHandled?.resolve();\n      }), client.send('Page.setLifecycleEventsEnabled', {\n        enabled: true\n      }), client.send('Runtime.enable').then(() => {\n        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n      })]);\n    } catch (error) {\n      this.#frameTreeHandled?.resolve();\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  executionContextById(contextId, session = this.#client) {\n    const context = this.getExecutionContextById(contextId, session);\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n  getExecutionContextById(contextId, session = this.#client) {\n    return this.#contextIdToContext.get(`${session.id()}:${contextId}`);\n  }\n  page() {\n    return this.#page;\n  }\n  mainFrame() {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n  frames() {\n    return Array.from(this._frameTree.frames());\n  }\n  frame(frameId) {\n    return this._frameTree.getById(frameId) || null;\n  }\n  onAttachedToTarget(target) {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session());\n    }\n    this.setupEventListeners(target._session());\n    void this.initialize(target._session());\n  }\n  _deviceRequestPromptManager(client) {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n  #onLifecycleEvent(event) {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n  #onFrameStartedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n  #onFrameStoppedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n  #handleFrameTree(session, frameTree) {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame, 'Navigation');\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n    if (!frameTree.childFrames) {\n      return;\n    }\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n  #onFrameAttached(session, frameId, parentFrameId) {\n    let frame = this.frame(frameId);\n    if (frame) {\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n    frame = new CdpFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEvent.FrameAttached, frame);\n  }\n  async #onFrameNavigated(framePayload, navigationType) {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n    let frame = this._frameTree.getById(frameId);\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CdpFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, navigationType);\n  }\n  async #createIsolatedWorld(session, name) {\n    const key = `${session.id()}:${name}`;\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name\n    });\n    await Promise.all(this.frames().filter(frame => {\n      return frame.client === session;\n    }).map(frame => {\n      // Frames might be removed before we send this, so we don't want to\n      // throw an error.\n      return session.send('Page.createIsolatedWorld', {\n        frameId: frame._id,\n        worldName: name,\n        grantUniveralAccess: true\n      }).catch(debugError);\n    }));\n    this.#isolatedWorlds.add(key);\n  }\n  #onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);\n    frame.emit(FrameEvent.FrameNavigatedWithinDocument, undefined);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, 'Navigation');\n  }\n  #onFrameDetached(frameId, reason) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    switch (reason) {\n      case 'remove':\n        // Only remove the frame if the reason for the detached event is\n        // an actual removement of the frame.\n        // For frames that become OOP iframes, the reason would be 'swap'.\n        this.#removeFramesRecursively(frame);\n        break;\n      case 'swap':\n        this.emit(FrameManagerEvent.FrameSwapped, frame);\n        frame.emit(FrameEvent.FrameSwapped, undefined);\n        break;\n    }\n  }\n  #onExecutionContextCreated(contextPayload, session) {\n    const auxData = contextPayload.auxData;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame.client !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[PUPPETEER_WORLD].hasContext()) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    // If there is no world, the context is not meant to be handled by us.\n    if (!world) {\n      return;\n    }\n    const context = new ExecutionContext(frame?.client || this.#client, contextPayload, world);\n    if (world) {\n      world.setContext(context);\n    }\n    const key = `${session.id()}:${contextPayload.id}`;\n    this.#contextIdToContext.set(key, context);\n  }\n  #onExecutionContextDestroyed(executionContextId, session) {\n    const key = `${session.id()}:${executionContextId}`;\n    const context = this.#contextIdToContext.get(key);\n    if (!context) {\n      return;\n    }\n    this.#contextIdToContext.delete(key);\n    if (context._world) {\n      context._world.clearContext();\n    }\n  }\n  #onExecutionContextsCleared(session) {\n    for (const [key, context] of this.#contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) {\n        continue;\n      }\n      if (context._world) {\n        context._world.clearContext();\n      }\n      this.#contextIdToContext.delete(key);\n    }\n  }\n  #removeFramesRecursively(frame) {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame[disposeSymbol]();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEvent.FrameDetached, frame);\n    frame.emit(FrameEvent.FrameDetached, frame);\n  }\n}","map":{"version":3,"names":["CDPSessionEvent","FrameEvent","EventEmitter","debugError","PuppeteerURL","UTILITY_WORLD_NAME","assert","Deferred","disposeSymbol","isErrorLike","CdpCDPSession","isTargetClosedError","DeviceRequestPromptManager","ExecutionContext","CdpFrame","FrameManagerEvent","FrameTree","MAIN_WORLD","PUPPETEER_WORLD","NetworkManager","TIME_FOR_WAITING_FOR_SWAP","FrameManager","page","networkManager","timeoutSettings","contextIdToContext","Map","isolatedWorlds","Set","client","_frameTree","frameNavigatedReceived","deviceRequestPromptManagerMap","WeakMap","frameTreeHandled","constructor","ignoreHTTPSErrors","setupEventListeners","once","Disconnected","onClientDisconnect","catch","#onClientDisconnect","mainFrame","getMainFrame","child","childFrames","removeFramesRecursively","swapped","create","timeout","message","FrameSwappedByActivation","resolve","valueOrThrow","err","swapFrameTree","onExecutionContextsCleared","frame","add","_target","_targetId","removeFrame","updateId","mainRealm","clearContext","isolatedRealm","addFrame","updateClient","initialize","addClient","emit","undefined","registerSpeculativeSession","session","on","event","onFrameAttached","frameId","parentFrameId","id","onFrameNavigated","type","onFrameNavigatedWithinDocument","url","onFrameDetached","reason","onFrameStartedLoading","onFrameStoppedLoading","onExecutionContextCreated","context","onExecutionContextDestroyed","executionContextId","onLifecycleEvent","Promise","all","send","then","frameTree","handleFrameTree","enabled","createIsolatedWorld","error","executionContextById","contextId","getExecutionContextById","get","frames","Array","from","getById","onAttachedToTarget","target","_getTargetInfo","targetId","_session","_deviceRequestPromptManager","manager","set","#onLifecycleEvent","_onLifecycleEvent","loaderId","name","LifecycleEvent","#onFrameStartedLoading","_onLoadingStarted","#onFrameStoppedLoading","_onLoadingStopped","#handleFrameTree","parentId","has","delete","#onFrameAttached","isOOPFrame","FrameAttached","#onFrameNavigated","framePayload","navigationType","isMainFrame","_id","waitForFrame","_navigated","FrameNavigated","#createIsolatedWorld","key","source","INTERNAL_URL","worldName","filter","map","grantUniveralAccess","#onFrameNavigatedWithinDocument","_navigatedWithinDocument","FrameNavigatedWithinDocument","#onFrameDetached","FrameSwapped","#onExecutionContextCreated","contextPayload","auxData","world","worlds","hasContext","setContext","#onExecutionContextDestroyed","_world","#onExecutionContextsCleared","entries","_client","#removeFramesRecursively","FrameDetached"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/puppeteer-core/src/cdp/FrameManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {type CDPSession, CDPSessionEvent} from '../api/CDPSession.js';\nimport {FrameEvent} from '../api/Frame.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport {debugError, PuppeteerURL, UTILITY_WORLD_NAME} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {disposeSymbol} from '../util/disposable.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\n\nimport {CdpCDPSession} from './CDPSession.js';\nimport {isTargetClosedError} from './Connection.js';\nimport {DeviceRequestPromptManager} from './DeviceRequestPrompt.js';\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {CdpFrame} from './Frame.js';\nimport type {FrameManagerEvents} from './FrameManagerEvents.js';\nimport {FrameManagerEvent} from './FrameManagerEvents.js';\nimport {FrameTree} from './FrameTree.js';\nimport type {IsolatedWorld} from './IsolatedWorld.js';\nimport {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {NetworkManager} from './NetworkManager.js';\nimport type {CdpPage} from './Page.js';\nimport type {CdpTarget} from './Target.js';\n\nconst TIME_FOR_WAITING_FOR_SWAP = 100; // ms.\n\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter<FrameManagerEvents> {\n  #page: CdpPage;\n  #networkManager: NetworkManager;\n  #timeoutSettings: TimeoutSettings;\n  #contextIdToContext = new Map<string, ExecutionContext>();\n  #isolatedWorlds = new Set<string>();\n  #client: CDPSession;\n\n  _frameTree = new FrameTree<CdpFrame>();\n\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set<string>();\n\n  #deviceRequestPromptManagerMap = new WeakMap<\n    CDPSession,\n    DeviceRequestPromptManager\n  >();\n\n  #frameTreeHandled?: Deferred<void>;\n\n  get timeoutSettings(): TimeoutSettings {\n    return this.#timeoutSettings;\n  }\n\n  get networkManager(): NetworkManager {\n    return this.#networkManager;\n  }\n\n  get client(): CDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CDPSession,\n    page: CdpPage,\n    ignoreHTTPSErrors: boolean,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(ignoreHTTPSErrors, this);\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n  }\n\n  /**\n   * Called when the frame's client is disconnected. We don't know if the\n   * disconnect means that the frame is removed or if it will be replaced by a\n   * new frame. Therefore, we wait for a swap event.\n   */\n  async #onClientDisconnect() {\n    const mainFrame = this._frameTree.getMainFrame();\n    if (!mainFrame) {\n      return;\n    }\n    for (const child of mainFrame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    const swapped = Deferred.create<void>({\n      timeout: TIME_FOR_WAITING_FOR_SWAP,\n      message: 'Frame was not swapped',\n    });\n    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {\n      swapped.resolve();\n    });\n    try {\n      await swapped.valueOrThrow();\n    } catch (err) {\n      this.#removeFramesRecursively(mainFrame);\n    }\n  }\n\n  /**\n   * When the main frame is replaced by another main frame,\n   * we maintain the main frame object identity while updating\n   * its frame tree and ID.\n   */\n  async swapFrameTree(client: CDPSession): Promise<void> {\n    this.#onExecutionContextsCleared(this.#client);\n\n    this.#client = client;\n    assert(\n      this.#client instanceof CdpCDPSession,\n      'CDPSession is not an instance of CDPSessionImpl.'\n    );\n    const frame = this._frameTree.getMainFrame();\n    if (frame) {\n      this.#frameNavigatedReceived.add(this.#client._target()._targetId);\n      this._frameTree.removeFrame(frame);\n      frame.updateId(this.#client._target()._targetId);\n      frame.mainRealm().clearContext();\n      frame.isolatedRealm().clearContext();\n      this._frameTree.addFrame(frame);\n      frame.updateClient(client, true);\n    }\n    this.setupEventListeners(client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n    await this.initialize(client);\n    await this.#networkManager.addClient(client);\n    if (frame) {\n      frame.emit(FrameEvent.FrameSwappedByActivation, undefined);\n    }\n  }\n\n  async registerSpeculativeSession(client: CdpCDPSession): Promise<void> {\n    await this.#networkManager.addClient(client);\n  }\n\n  private setupEventListeners(session: CDPSession) {\n    session.on('Page.frameAttached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', async event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      await this.#frameTreeHandled?.valueOrThrow();\n      void this.#onFrameNavigated(event.frame, event.type);\n    });\n    session.on('Page.navigatedWithinDocument', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on(\n      'Page.frameDetached',\n      async (event: Protocol.Page.FrameDetachedEvent) => {\n        await this.#frameTreeHandled?.valueOrThrow();\n        this.#onFrameDetached(\n          event.frameId,\n          event.reason as Protocol.Page.FrameDetachedEventReason\n        );\n      }\n    );\n    session.on('Page.frameStartedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', async () => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onLifecycleEvent(event);\n    });\n  }\n\n  async initialize(client: CDPSession): Promise<void> {\n    try {\n      this.#frameTreeHandled?.resolve();\n      this.#frameTreeHandled = Deferred.create();\n      // We need to schedule all these commands while the target is paused,\n      // therefore, it needs to happen synchroniously. At the same time we\n      // should not start processing execution context and frame events before\n      // we received the initial information about the frame tree.\n      await Promise.all([\n        this.#networkManager.addClient(client),\n        client.send('Page.enable'),\n        client.send('Page.getFrameTree').then(({frameTree}) => {\n          this.#handleFrameTree(client, frameTree);\n          this.#frameTreeHandled?.resolve();\n        }),\n        client.send('Page.setLifecycleEventsEnabled', {enabled: true}),\n        client.send('Runtime.enable').then(() => {\n          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n        }),\n      ]);\n    } catch (error) {\n      this.#frameTreeHandled?.resolve();\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  executionContextById(\n    contextId: number,\n    session: CDPSession = this.#client\n  ): ExecutionContext {\n    const context = this.getExecutionContextById(contextId, session);\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n\n  getExecutionContextById(\n    contextId: number,\n    session: CDPSession = this.#client\n  ): ExecutionContext | undefined {\n    return this.#contextIdToContext.get(`${session.id()}:${contextId}`);\n  }\n\n  page(): CdpPage {\n    return this.#page;\n  }\n\n  mainFrame(): CdpFrame {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n\n  frames(): CdpFrame[] {\n    return Array.from(this._frameTree.frames());\n  }\n\n  frame(frameId: string): CdpFrame | null {\n    return this._frameTree.getById(frameId) || null;\n  }\n\n  onAttachedToTarget(target: CdpTarget): void {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session()!);\n    }\n    this.setupEventListeners(target._session()!);\n    void this.initialize(target._session()!);\n  }\n\n  _deviceRequestPromptManager(client: CDPSession): DeviceRequestPromptManager {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n\n  #onLifecycleEvent(event: Protocol.Page.LifecycleEventEvent): void {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n\n  #onFrameStartedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n\n  #onFrameStoppedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n\n  #handleFrameTree(\n    session: CDPSession,\n    frameTree: Protocol.Page.FrameTree\n  ): void {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(\n        session,\n        frameTree.frame.id,\n        frameTree.frame.parentId\n      );\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame, 'Navigation');\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n\n    if (!frameTree.childFrames) {\n      return;\n    }\n\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n\n  #onFrameAttached(\n    session: CDPSession,\n    frameId: string,\n    parentFrameId: string\n  ): void {\n    let frame = this.frame(frameId);\n    if (frame) {\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n\n    frame = new CdpFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEvent.FrameAttached, frame);\n  }\n\n  async #onFrameNavigated(\n    framePayload: Protocol.Page.Frame,\n    navigationType: Protocol.Page.NavigationType\n  ): Promise<void> {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n\n    let frame = this._frameTree.getById(frameId);\n\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CdpFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, navigationType);\n  }\n\n  async #createIsolatedWorld(session: CDPSession, name: string): Promise<void> {\n    const key = `${session.id()}:${name}`;\n\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name,\n    });\n\n    await Promise.all(\n      this.frames()\n        .filter(frame => {\n          return frame.client === session;\n        })\n        .map(frame => {\n          // Frames might be removed before we send this, so we don't want to\n          // throw an error.\n          return session\n            .send('Page.createIsolatedWorld', {\n              frameId: frame._id,\n              worldName: name,\n              grantUniveralAccess: true,\n            })\n            .catch(debugError);\n        })\n    );\n\n    this.#isolatedWorlds.add(key);\n  }\n\n  #onFrameNavigatedWithinDocument(frameId: string, url: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);\n    frame.emit(FrameEvent.FrameNavigatedWithinDocument, undefined);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, 'Navigation');\n  }\n\n  #onFrameDetached(\n    frameId: string,\n    reason: Protocol.Page.FrameDetachedEventReason\n  ): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    switch (reason) {\n      case 'remove':\n        // Only remove the frame if the reason for the detached event is\n        // an actual removement of the frame.\n        // For frames that become OOP iframes, the reason would be 'swap'.\n        this.#removeFramesRecursively(frame);\n        break;\n      case 'swap':\n        this.emit(FrameManagerEvent.FrameSwapped, frame);\n        frame.emit(FrameEvent.FrameSwapped, undefined);\n        break;\n    }\n  }\n\n  #onExecutionContextCreated(\n    contextPayload: Protocol.Runtime.ExecutionContextDescription,\n    session: CDPSession\n  ): void {\n    const auxData = contextPayload.auxData as {frameId?: string} | undefined;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world: IsolatedWorld | undefined;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame.client !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (\n        contextPayload.name === UTILITY_WORLD_NAME &&\n        !frame.worlds[PUPPETEER_WORLD].hasContext()\n      ) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    // If there is no world, the context is not meant to be handled by us.\n    if (!world) {\n      return;\n    }\n    const context = new ExecutionContext(\n      frame?.client || this.#client,\n      contextPayload,\n      world\n    );\n    if (world) {\n      world.setContext(context);\n    }\n    const key = `${session.id()}:${contextPayload.id}`;\n    this.#contextIdToContext.set(key, context);\n  }\n\n  #onExecutionContextDestroyed(\n    executionContextId: number,\n    session: CDPSession\n  ): void {\n    const key = `${session.id()}:${executionContextId}`;\n    const context = this.#contextIdToContext.get(key);\n    if (!context) {\n      return;\n    }\n    this.#contextIdToContext.delete(key);\n    if (context._world) {\n      context._world.clearContext();\n    }\n  }\n\n  #onExecutionContextsCleared(session: CDPSession): void {\n    for (const [key, context] of this.#contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) {\n        continue;\n      }\n      if (context._world) {\n        context._world.clearContext();\n      }\n      this.#contextIdToContext.delete(key);\n    }\n  }\n\n  #removeFramesRecursively(frame: CdpFrame): void {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame[disposeSymbol]();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEvent.FrameDetached, frame);\n    frame.emit(FrameEvent.FrameDetached, frame);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}