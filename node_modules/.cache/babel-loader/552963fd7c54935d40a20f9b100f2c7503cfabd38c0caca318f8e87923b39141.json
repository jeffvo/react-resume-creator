{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyStylesheets = exports.renderElements = exports.renderBucketElement = exports.collapseWhitespace = exports.renderElement = exports.bucketElements = exports.hasBlockContent = exports.isBlockStyle = void 0;\nconst react_1 = __importDefault(require(\"react\"));\nconst renderers_1 = __importStar(require(\"./renderers\"));\nconst renderer_1 = require(\"@react-pdf/renderer\");\nconst parse_1 = __importDefault(require(\"./parse\"));\nconst styles_1 = require(\"./styles\");\nconst tags_1 = require(\"./tags\");\nconst convertEntities = input => {\n  const entities = [['amp', '&'], ['apos', \"'\"], ['#x27', \"'\"], ['#x2F', '/'], ['#39', \"'\"], ['#47', '/'], ['lt', '<'], ['gt', '>'], ['nbsp', ' '], ['quot', '\"']];\n  let text = input;\n  for (let entity of entities) {\n    text = text.replace(new RegExp('&' + entity[0] + ';', 'g'), entity[1]);\n  }\n  return text;\n};\nconst isBlockStyle = style => ['block', 'flex'].includes(style.display);\nexports.isBlockStyle = isBlockStyle;\nconst hasBlockContent = element => {\n  var _a;\n  if (typeof element === 'string') {\n    return false;\n  }\n  if (element.tag === 'a' || tags_1.isText[element.tag]) {\n    if ((_a = element.style) === null || _a === void 0 ? void 0 : _a.some(exports.isBlockStyle)) {\n      return true;\n    }\n    // anchor tags match their content\n    if (element.content) {\n      return element.content.some(exports.hasBlockContent);\n    }\n    return false;\n  }\n  return true;\n};\nexports.hasBlockContent = hasBlockContent;\nconst ltrim = text => text.replace(/^\\s+/, '');\nconst rtrim = text => text.replace(/\\s+$/, '');\nconst isCustomElement = element => {\n  if (!element || typeof element === 'string') return false;\n  return tags_1.isText[element.tag] === undefined;\n};\n/**\n * Groups all block and non-block elements into buckets so that all non-block elements can be rendered in a parent Text element\n * @param elements Elements to place in buckets of block and non-block content\n * @param collapse\n * @param parentTag\n */\nconst bucketElements = (elements, collapse, parentTag) => {\n  let bucket;\n  let hasBlock;\n  const buckets = [];\n  elements.forEach((element, index) => {\n    // clear empty strings between block elements\n    if (typeof element === 'string') {\n      if (collapse) {\n        if (parentTag === 'pre') {\n          if (element[0] === '\\n') {\n            element = element.substr(1);\n          }\n          if (element[element.length - 1] === '\\n') {\n            element = element.substr(0, element.length - 1);\n          }\n        } else {\n          const isBucketCustomElement = isCustomElement(bucket === null || bucket === void 0 ? void 0 : bucket.content[0]);\n          if (!isBucketCustomElement && (hasBlock || hasBlock === undefined)) {\n            element = ltrim(element);\n          }\n          const next = elements[index + 1];\n          if (next) {\n            const isNextCustomElement = isCustomElement(next);\n            if ((0, exports.hasBlockContent)(next) && !isNextCustomElement) {\n              element = rtrim(element);\n            }\n          }\n        }\n      }\n      if (element === '') {\n        return;\n      }\n    }\n    const block = (0, exports.hasBlockContent)(element);\n    if (block !== hasBlock || isCustomElement(element)) {\n      hasBlock = block;\n      bucket = {\n        hasBlock,\n        content: []\n      };\n      buckets.push(bucket);\n    }\n    bucket.content.push(element);\n  });\n  return buckets;\n};\nexports.bucketElements = bucketElements;\nconst renderElement = (element, stylesheets, renderers, children, index) => {\n  if (typeof element === 'string') {\n    element = convertEntities(element);\n    if (/(\\s )|( \\s)/.test(element)) {\n      // hack to avoid collapsing sequential spaces\n      return element.split(/(\\s{2,})/g).reduce((strings, string, index) => string === '' ? strings : strings.concat(index % 2 ? string.split('') : string), []);\n    }\n    return element;\n  }\n  let Element = renderers[element.tag];\n  if (!Element) {\n    if (!(element.tag in tags_1.isText)) {\n      // Unknown element, do nothing\n      console.warn(`Excluding \"${element.tag}\" because it has no renderer`);\n      Element = renderers_1.renderNoop;\n    } else {\n      Element = (0, exports.hasBlockContent)(element) ? renderers_1.renderBlock : renderers_1.renderInline;\n    }\n  }\n  return react_1.default.createElement(Element, {\n    key: index,\n    style: element.style,\n    children: children,\n    element: element,\n    stylesheets: stylesheets\n  });\n};\nexports.renderElement = renderElement;\nconst collapseWhitespace = string => string.replace(/(\\s+)/g, ' ');\nexports.collapseWhitespace = collapseWhitespace;\nconst renderBucketElement = (element, options, index) => {\n  if (typeof element === 'string') {\n    return (0, exports.renderElement)(options.collapse ? (0, exports.collapseWhitespace)(element) : element, options.stylesheets, options.renderers, undefined, index);\n  }\n  return (0, exports.renderElement)(element, options.stylesheets, options.renderers, (0, exports.renderElements)(element.content, element.tag === 'pre' ? Object.assign(Object.assign({}, options), {\n    collapse: false\n  }) : options, element), index);\n};\nexports.renderBucketElement = renderBucketElement;\nconst isAnchor = content => {\n  return Array.isArray(content) ? content.length === 1 && typeof content[0] !== 'string' && content[0].tag === 'a' : content.tag === 'a';\n};\nconst renderElements = (elements, options, parent) => {\n  const buckets = (0, exports.bucketElements)(elements, options.collapse, parent === null || parent === void 0 ? void 0 : parent.tag);\n  const parentIsText = parent && !isAnchor(parent) && !(0, exports.hasBlockContent)(parent);\n  const renderedBuckets = buckets.map((bucket, bucketIndex) => {\n    const wrapWithText = !bucket.hasBlock && !parentIsText && !isAnchor(bucket.content) && (bucket.content.length > 1 || typeof bucket.content[0] === 'string');\n    // Avoid extra array\n    if (bucket.content.length === 1 && !wrapWithText) {\n      return (0, exports.renderBucketElement)(bucket.content[0], options, bucketIndex);\n    }\n    let rendered = bucket.content.map((element, index) => {\n      return (0, exports.renderBucketElement)(element, options, index);\n    });\n    // unwrap extra array\n    if (rendered.length === 1) {\n      rendered = rendered[0];\n    }\n    if (wrapWithText) {\n      return react_1.default.createElement(renderer_1.Text, {\n        key: bucketIndex\n      }, rendered);\n    } else {\n      return buckets.length === 1 ? rendered : react_1.default.createElement(react_1.default.Fragment, {\n        key: bucketIndex\n      }, rendered);\n    }\n  });\n  // unwrap extra array\n  return buckets.length === 1 ? renderedBuckets[0] : renderedBuckets;\n};\nexports.renderElements = renderElements;\nconst applyStylesheets = (stylesheets, rootElement) => {\n  stylesheets.forEach(stylesheet => {\n    for (const selector of Object.keys(stylesheet)) {\n      const elements = rootElement.querySelectorAll(selector);\n      elements.forEach(element => {\n        element.style.push(stylesheet[selector]);\n      });\n    }\n  });\n};\nexports.applyStylesheets = applyStylesheets;\nconst renderHtml = (text, options = {}) => {\n  const defaultFontSize = 18;\n  const fontSizeStyle = {\n    fontSize: defaultFontSize\n  };\n  const styles = options.style ? Array.isArray(options.style) ? options.style : [options.style] : [];\n  styles.forEach(style => {\n    if (!style) {\n      return;\n    }\n    if (typeof style.fontSize === 'number') {\n      fontSizeStyle.fontSize = style.fontSize;\n    }\n    if (typeof style.fontSize === 'string' && style.fontSize.endsWith('px')) {\n      fontSizeStyle.fontSize = parseInt(style.fontSize, 10);\n    }\n  });\n  const baseStyles = (0, styles_1.createHtmlStylesheet)(fontSizeStyle.fontSize, options.resetStyles);\n  const parsed = (0, parse_1.default)(text);\n  const stylesheets = options.stylesheet ? Array.isArray(options.stylesheet) ? options.stylesheet : [options.stylesheet] : [];\n  const opts = Object.assign(Object.assign({\n    collapse: true,\n    resetStyles: false\n  }, options), {\n    renderers: Object.assign(Object.assign({}, renderers_1.default), options.renderers),\n    stylesheets: [baseStyles, ...stylesheets, ...parsed.stylesheets]\n  });\n  (0, exports.applyStylesheets)(opts.stylesheets, parsed.rootElement);\n  return react_1.default.createElement(renderer_1.View, {\n    style: [...styles, fontSizeStyle]\n  }, (0, exports.renderElements)(parsed.rootElement.content, opts));\n};\nexports.default = renderHtml;","map":{"version":3,"names":["react_1","__importDefault","require","renderers_1","__importStar","renderer_1","parse_1","styles_1","tags_1","convertEntities","input","entities","text","entity","replace","RegExp","isBlockStyle","style","includes","display","exports","hasBlockContent","element","tag","isText","_a","some","content","ltrim","rtrim","isCustomElement","undefined","bucketElements","elements","collapse","parentTag","bucket","hasBlock","buckets","forEach","index","substr","length","isBucketCustomElement","next","isNextCustomElement","block","push","renderElement","stylesheets","renderers","children","test","split","reduce","strings","string","concat","Element","console","warn","renderNoop","renderBlock","renderInline","default","createElement","key","collapseWhitespace","renderBucketElement","options","renderElements","Object","assign","isAnchor","Array","isArray","parent","parentIsText","renderedBuckets","map","bucketIndex","wrapWithText","rendered","Text","Fragment","applyStylesheets","rootElement","stylesheet","selector","keys","querySelectorAll","renderHtml","defaultFontSize","fontSizeStyle","fontSize","styles","endsWith","parseInt","baseStyles","createHtmlStylesheet","resetStyles","parsed","opts","View"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/src/render.tsx"],"sourcesContent":["import React, { ReactElement } from 'react';\nimport renderers, { renderBlock, renderInline, renderNoop } from './renderers';\nimport { Text, View } from '@react-pdf/renderer';\nimport parseHtml, { HtmlContent, HtmlElement } from './parse';\nimport { createHtmlStylesheet, HtmlStyle, HtmlStyles } from './styles';\nimport { Style } from '@react-pdf/types';\nimport { isText, Tag } from './tags';\n\nexport type HtmlRenderer = React.FC<\n  React.PropsWithChildren<{\n    element: HtmlElement;\n    style: Style[];\n    stylesheets: HtmlStyles[];\n  }>\n>;\n\nexport type HtmlRenderers = Record<Tag | string, HtmlRenderer>;\n\nexport type HtmlRenderOptions = {\n  collapse: boolean;\n  renderers: HtmlRenderers;\n  stylesheets: HtmlStyles[];\n  resetStyles: boolean;\n};\n\ntype ContentBucket = {\n  hasBlock: boolean;\n  content: HtmlContent;\n};\n\nconst convertEntities = (input: string) => {\n  const entities = [\n    ['amp', '&'],\n    ['apos', \"'\"],\n    ['#x27', \"'\"],\n    ['#x2F', '/'],\n    ['#39', \"'\"],\n    ['#47', '/'],\n    ['lt', '<'],\n    ['gt', '>'],\n    ['nbsp', ' '],\n    ['quot', '\"'],\n  ];\n\n  let text = input;\n  for (let entity of entities) {\n    text = text.replace(new RegExp('&' + entity[0] + ';', 'g'), entity[1]);\n  }\n  return text;\n};\n\nexport const isBlockStyle = (style: HtmlStyle) =>\n  ['block', 'flex'].includes(style.display);\n\nexport const hasBlockContent = (element: HtmlElement | string): boolean => {\n  if (typeof element === 'string') {\n    return false;\n  }\n\n  if (element.tag === 'a' || isText[element.tag]) {\n    if (element.style?.some(isBlockStyle)) {\n      return true;\n    }\n\n    // anchor tags match their content\n    if (element.content) {\n      return element.content.some(hasBlockContent);\n    }\n    return false;\n  }\n\n  return true;\n};\n\nconst ltrim = (text: string): string => text.replace(/^\\s+/, '');\nconst rtrim = (text: string): string => text.replace(/\\s+$/, '');\n\nconst isCustomElement = (element?: HtmlElement | string): boolean => {\n  if (!element || typeof element === 'string') return false;\n  return isText[element.tag] === undefined;\n};\n\n/**\n * Groups all block and non-block elements into buckets so that all non-block elements can be rendered in a parent Text element\n * @param elements Elements to place in buckets of block and non-block content\n * @param collapse\n * @param parentTag\n */\nexport const bucketElements = (\n  elements: HtmlContent,\n  collapse: boolean,\n  parentTag?: Tag | string\n): ContentBucket[] => {\n  let bucket: ContentBucket;\n  let hasBlock: boolean;\n  const buckets: ContentBucket[] = [];\n  elements.forEach((element, index) => {\n    // clear empty strings between block elements\n    if (typeof element === 'string') {\n      if (collapse) {\n        if (parentTag === 'pre') {\n          if (element[0] === '\\n') {\n            element = element.substr(1);\n          }\n          if (element[element.length - 1] === '\\n') {\n            element = element.substr(0, element.length - 1);\n          }\n        } else {\n          const isBucketCustomElement = isCustomElement(bucket?.content[0]);\n          if (!isBucketCustomElement && (hasBlock || hasBlock === undefined)) {\n            element = ltrim(element);\n          }\n          const next = elements[index + 1];\n\n          if (next) {\n            const isNextCustomElement = isCustomElement(next);\n            if (hasBlockContent(next) && !isNextCustomElement) {\n              element = rtrim(element);\n            }\n          }\n        }\n      }\n      if (element === '') {\n        return;\n      }\n    }\n    const block = hasBlockContent(element);\n    if (block !== hasBlock || isCustomElement(element)) {\n      hasBlock = block;\n      bucket = {\n        hasBlock,\n        content: [],\n      };\n      buckets.push(bucket);\n    }\n    bucket.content.push(element);\n  });\n\n  return buckets;\n};\n\ntype RenderedContent = ReactElement | ReactElement[] | string | string[];\n\nexport const renderElement = (\n  element: HtmlElement | string,\n  stylesheets: HtmlStyles[],\n  renderers: HtmlRenderers,\n  children?: any,\n  index?: number\n): RenderedContent => {\n  if (typeof element === 'string') {\n    element = convertEntities(element);\n    if (/(\\s )|( \\s)/.test(element)) {\n      // hack to avoid collapsing sequential spaces\n      return element\n        .split(/(\\s{2,})/g)\n        .reduce(\n          (strings, string, index) =>\n            string === ''\n              ? strings\n              : strings.concat(index % 2 ? string.split('') : string),\n          [] as string[]\n        );\n    }\n    return element;\n  }\n  let Element: HtmlRenderer | undefined = renderers[element.tag];\n  if (!Element) {\n    if (!(element.tag in isText)) {\n      // Unknown element, do nothing\n      console.warn(`Excluding \"${element.tag}\" because it has no renderer`);\n      Element = renderNoop;\n    } else {\n      Element = hasBlockContent(element) ? renderBlock : renderInline;\n    }\n  }\n\n  return (\n    <Element\n      key={index}\n      style={element.style}\n      children={children}\n      element={element}\n      stylesheets={stylesheets}\n    />\n  );\n};\n\nexport const collapseWhitespace = (string: any): string =>\n  string.replace(/(\\s+)/g, ' ');\n\nexport const renderBucketElement = (\n  element: HtmlElement | string,\n  options: HtmlRenderOptions,\n  index: number\n): RenderedContent => {\n  if (typeof element === 'string') {\n    return renderElement(\n      options.collapse ? collapseWhitespace(element) : element,\n      options.stylesheets,\n      options.renderers,\n      undefined,\n      index\n    );\n  }\n  return renderElement(\n    element,\n    options.stylesheets,\n    options.renderers,\n    renderElements(\n      element.content,\n      element.tag === 'pre' ? { ...options, collapse: false } : options,\n      element\n    ),\n    index\n  );\n};\n\nconst isAnchor = (content: HtmlContent | HtmlElement): boolean => {\n  return Array.isArray(content)\n    ? content.length === 1 &&\n        typeof content[0] !== 'string' &&\n        content[0].tag === 'a'\n    : content.tag === 'a';\n};\n\nexport const renderElements = (\n  elements: HtmlContent,\n  options: HtmlRenderOptions,\n  parent?: HtmlElement\n): RenderedContent | RenderedContent[] => {\n  const buckets = bucketElements(elements, options.collapse, parent?.tag);\n  const parentIsText = parent && !isAnchor(parent) && !hasBlockContent(parent);\n\n  const renderedBuckets: (RenderedContent[] | RenderedContent)[] = buckets.map(\n    (bucket, bucketIndex) => {\n      const wrapWithText =\n        !bucket.hasBlock &&\n        !parentIsText &&\n        !isAnchor(bucket.content) &&\n        (bucket.content.length > 1 || typeof bucket.content[0] === 'string');\n\n      // Avoid extra array\n      if (bucket.content.length === 1 && !wrapWithText) {\n        return renderBucketElement(bucket.content[0], options, bucketIndex);\n      }\n\n      let rendered: RenderedContent | RenderedContent[] = bucket.content.map(\n        (element, index) => {\n          return renderBucketElement(element, options, index);\n        }\n      );\n\n      // unwrap extra array\n      if (rendered.length === 1) {\n        rendered = rendered[0];\n      }\n\n      if (wrapWithText) {\n        return <Text key={bucketIndex}>{rendered}</Text>;\n      } else {\n        return buckets.length === 1 ? (\n          rendered\n        ) : (\n          <React.Fragment key={bucketIndex}>{rendered}</React.Fragment>\n        );\n      }\n    }\n  );\n\n  // unwrap extra array\n  return buckets.length === 1\n    ? (renderedBuckets[0] as RenderedContent)\n    : (renderedBuckets as RenderedContent[]);\n};\n\nexport const applyStylesheets = (\n  stylesheets: HtmlStyles[],\n  rootElement: HtmlElement\n) => {\n  stylesheets.forEach((stylesheet) => {\n    for (const selector of Object.keys(stylesheet)) {\n      const elements = rootElement.querySelectorAll(selector) as HtmlElement[];\n      elements.forEach((element) => {\n        element.style.push(stylesheet[selector]);\n      });\n    }\n  });\n};\n\nconst renderHtml = (\n  text: string,\n  options: {\n    collapse?: boolean;\n    renderers?: HtmlRenderers;\n    style?: Style | Style[];\n    stylesheet?: HtmlStyles | HtmlStyles[];\n    resetStyles?: boolean;\n  } = {}\n): ReactElement => {\n  const defaultFontSize = 18;\n  const fontSizeStyle = { fontSize: defaultFontSize };\n  const styles = options.style\n    ? Array.isArray(options.style)\n      ? options.style\n      : [options.style]\n    : [];\n\n  styles.forEach((style) => {\n    if (!style) {\n      return;\n    }\n    if (typeof style.fontSize === 'number') {\n      fontSizeStyle.fontSize = style.fontSize;\n    }\n    if (typeof style.fontSize === 'string' && style.fontSize.endsWith('px')) {\n      fontSizeStyle.fontSize = parseInt(style.fontSize, 10);\n    }\n  });\n  const baseStyles = createHtmlStylesheet(\n    fontSizeStyle.fontSize,\n    options.resetStyles\n  );\n  const parsed = parseHtml(text);\n\n  const stylesheets = options.stylesheet\n    ? Array.isArray(options.stylesheet)\n      ? options.stylesheet\n      : [options.stylesheet]\n    : [];\n\n  const opts: HtmlRenderOptions = {\n    collapse: true,\n    resetStyles: false,\n    ...options,\n    renderers: { ...renderers, ...options.renderers },\n    stylesheets: [baseStyles, ...stylesheets, ...parsed.stylesheets],\n  };\n\n  applyStylesheets(opts.stylesheets, parsed.rootElement);\n\n  return (\n    <View style={[...styles, fontSizeStyle]}>\n      {renderElements(parsed.rootElement.content, opts)}\n    </View>\n  );\n};\n\nexport default renderHtml;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}