{"ast":null,"code":"import { headersArray, HTTPRequest, InterceptResolutionAction, STATUS_TEXTS } from '../api/HTTPRequest.js';\nimport { debugError, isString } from '../common/util.js';\nimport { assert } from '../util/assert.js';\n/**\n * @internal\n */\nexport class CdpHTTPRequest extends HTTPRequest {\n  id;\n  #client;\n  #isNavigationRequest;\n  #allowInterception;\n  #interceptionHandled = false;\n  #url;\n  #resourceType;\n  #method;\n  #hasPostData = false;\n  #postData;\n  #headers = {};\n  #frame;\n  #continueRequestOverrides;\n  #responseForRequest = null;\n  #abortErrorReason = null;\n  #interceptResolutionState = {\n    action: InterceptResolutionAction.None\n  };\n  #interceptHandlers;\n  #initiator;\n  get client() {\n    return this.#client;\n  }\n  constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {\n    super();\n    this.#client = client;\n    this.id = data.requestId;\n    this.#isNavigationRequest = data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#allowInterception = allowInterception;\n    this.#url = data.request.url;\n    this.#resourceType = (data.type || 'other').toLowerCase();\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#hasPostData = data.request.hasPostData ?? false;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#continueRequestOverrides = {};\n    this.#interceptHandlers = [];\n    this.#initiator = data.initiator;\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n  url() {\n    return this.#url;\n  }\n  continueRequestOverrides() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#continueRequestOverrides;\n  }\n  responseForRequest() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#responseForRequest;\n  }\n  abortErrorReason() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#abortErrorReason;\n  }\n  interceptResolutionState() {\n    if (!this.#allowInterception) {\n      return {\n        action: InterceptResolutionAction.Disabled\n      };\n    }\n    if (this.#interceptionHandled) {\n      return {\n        action: InterceptResolutionAction.AlreadyHandled\n      };\n    }\n    return {\n      ...this.#interceptResolutionState\n    };\n  }\n  isInterceptResolutionHandled() {\n    return this.#interceptionHandled;\n  }\n  enqueueInterceptAction(pendingHandler) {\n    this.#interceptHandlers.push(pendingHandler);\n  }\n  async finalizeInterceptions() {\n    await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {\n      action\n    } = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return await this.#abort(this.#abortErrorReason);\n      case 'respond':\n        if (this.#responseForRequest === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return await this.#respond(this.#responseForRequest);\n      case 'continue':\n        return await this.#continue(this.#continueRequestOverrides);\n    }\n  }\n  resourceType() {\n    return this.#resourceType;\n  }\n  method() {\n    return this.#method;\n  }\n  postData() {\n    return this.#postData;\n  }\n  hasPostData() {\n    return this.#hasPostData;\n  }\n  async fetchPostData() {\n    try {\n      const result = await this.#client.send('Network.getRequestPostData', {\n        requestId: this.id\n      });\n      return result.postData;\n    } catch (err) {\n      debugError(err);\n      return;\n    }\n  }\n  headers() {\n    return this.#headers;\n  }\n  response() {\n    return this._response;\n  }\n  frame() {\n    return this.#frame;\n  }\n  isNavigationRequest() {\n    return this.#isNavigationRequest;\n  }\n  initiator() {\n    return this.#initiator;\n  }\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  failure() {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText\n    };\n  }\n  async continue(overrides = {}, priority) {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#continue(overrides);\n    }\n    this.#continueRequestOverrides = overrides;\n    if (this.#interceptResolutionState.priority === undefined || priority > this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort' || this.#interceptResolutionState.action === 'respond') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n  async #continue(overrides = {}) {\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this.#interceptionHandled = true;\n    const postDataBinaryBase64 = postData ? Buffer.from(postData).toString('base64') : undefined;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');\n    }\n    await this.#client.send('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url,\n      method,\n      postData: postDataBinaryBase64,\n      headers: headers ? headersArray(headers) : undefined\n    }).catch(error => {\n      this.#interceptionHandled = false;\n      return handleError(error);\n    });\n  }\n  async respond(response, priority) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#respond(response);\n    }\n    this.#responseForRequest = response;\n    if (this.#interceptResolutionState.priority === undefined || priority > this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Respond;\n    }\n  }\n  async #respond(response) {\n    this.#interceptionHandled = true;\n    const responseBody = response.body && isString(response.body) ? Buffer.from(response.body) : response.body || null;\n    const responseHeaders = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n        responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map(item => {\n          return String(item);\n        }) : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (responseBody && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n    }\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');\n    }\n    await this.#client.send('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: status,\n      responsePhrase: STATUS_TEXTS[status],\n      responseHeaders: headersArray(responseHeaders),\n      body: responseBody ? responseBody.toString('base64') : undefined\n    }).catch(error => {\n      this.#interceptionHandled = false;\n      return handleError(error);\n    });\n  }\n  async abort(errorCode = 'failed', priority) {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#abort(errorReason);\n    }\n    this.#abortErrorReason = errorReason;\n    if (this.#interceptResolutionState.priority === undefined || priority >= this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority\n      };\n      return;\n    }\n  }\n  async #abort(errorReason) {\n    this.#interceptionHandled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');\n    }\n    await this.#client.send('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason: errorReason || 'Failed'\n    }).catch(handleError);\n  }\n}\nconst errorReasons = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed'\n};\nasync function handleError(error) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}","map":{"version":3,"names":["headersArray","HTTPRequest","InterceptResolutionAction","STATUS_TEXTS","debugError","isString","assert","CdpHTTPRequest","id","client","isNavigationRequest","allowInterception","interceptionHandled","url","resourceType","method","hasPostData","postData","headers","frame","continueRequestOverrides","responseForRequest","abortErrorReason","interceptResolutionState","action","None","interceptHandlers","initiator","constructor","interceptionId","data","redirectChain","requestId","loaderId","type","_interceptionId","request","toLowerCase","_redirectChain","key","value","Object","entries","Disabled","AlreadyHandled","isInterceptResolutionHandled","enqueueInterceptAction","pendingHandler","push","finalizeInterceptions","reduce","promiseChain","interceptAction","then","Promise","resolve","abort","Error","respond","continue","fetchPostData","result","send","err","response","_response","slice","failure","_failureText","errorText","overrides","priority","startsWith","undefined","Continue","#continue","postDataBinaryBase64","Buffer","from","toString","catch","error","handleError","Respond","#respond","responseBody","body","responseHeaders","header","keys","Array","isArray","map","item","String","contentType","byteLength","status","responseCode","responsePhrase","errorCode","errorReason","errorReasons","Abort","#abort","aborted","accessdenied","addressunreachable","blockedbyclient","blockedbyresponse","connectionaborted","connectionclosed","connectionfailed","connectionrefused","connectionreset","internetdisconnected","namenotresolved","timedout","failed","includes","originalMessage"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/puppeteer-core/src/cdp/HTTPRequest.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {Frame} from '../api/Frame.js';\nimport {\n  type ContinueRequestOverrides,\n  type ErrorCode,\n  headersArray,\n  HTTPRequest,\n  InterceptResolutionAction,\n  type InterceptResolutionState,\n  type ResourceType,\n  type ResponseForRequest,\n  STATUS_TEXTS,\n} from '../api/HTTPRequest.js';\nimport type {ProtocolError} from '../common/Errors.js';\nimport {debugError, isString} from '../common/util.js';\nimport {assert} from '../util/assert.js';\n\nimport type {CdpHTTPResponse} from './HTTPResponse.js';\n\n/**\n * @internal\n */\nexport class CdpHTTPRequest extends HTTPRequest {\n  override id: string;\n  declare _redirectChain: CdpHTTPRequest[];\n  declare _response: CdpHTTPResponse | null;\n\n  #client: CDPSession;\n  #isNavigationRequest: boolean;\n  #allowInterception: boolean;\n  #interceptionHandled = false;\n  #url: string;\n  #resourceType: ResourceType;\n\n  #method: string;\n  #hasPostData = false;\n  #postData?: string;\n  #headers: Record<string, string> = {};\n  #frame: Frame | null;\n  #continueRequestOverrides: ContinueRequestOverrides;\n  #responseForRequest: Partial<ResponseForRequest> | null = null;\n  #abortErrorReason: Protocol.Network.ErrorReason | null = null;\n  #interceptResolutionState: InterceptResolutionState = {\n    action: InterceptResolutionAction.None,\n  };\n  #interceptHandlers: Array<() => void | PromiseLike<any>>;\n  #initiator?: Protocol.Network.Initiator;\n\n  override get client(): CDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CDPSession,\n    frame: Frame | null,\n    interceptionId: string | undefined,\n    allowInterception: boolean,\n    data: {\n      /**\n       * Request identifier.\n       */\n      requestId: Protocol.Network.RequestId;\n      /**\n       * Loader identifier. Empty string if the request is fetched from worker.\n       */\n      loaderId?: Protocol.Network.LoaderId;\n      /**\n       * URL of the document this request is loaded for.\n       */\n      documentURL?: string;\n      /**\n       * Request data.\n       */\n      request: Protocol.Network.Request;\n      /**\n       * Request initiator.\n       */\n      initiator?: Protocol.Network.Initiator;\n      /**\n       * Type of this resource.\n       */\n      type?: Protocol.Network.ResourceType;\n    },\n    redirectChain: CdpHTTPRequest[]\n  ) {\n    super();\n    this.#client = client;\n    this.id = data.requestId;\n    this.#isNavigationRequest =\n      data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#allowInterception = allowInterception;\n    this.#url = data.request.url;\n    this.#resourceType = (data.type || 'other').toLowerCase() as ResourceType;\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#hasPostData = data.request.hasPostData ?? false;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#continueRequestOverrides = {};\n    this.#interceptHandlers = [];\n    this.#initiator = data.initiator;\n\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n\n  override url(): string {\n    return this.#url;\n  }\n\n  override continueRequestOverrides(): ContinueRequestOverrides {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#continueRequestOverrides;\n  }\n\n  override responseForRequest(): Partial<ResponseForRequest> | null {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#responseForRequest;\n  }\n\n  override abortErrorReason(): Protocol.Network.ErrorReason | null {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#abortErrorReason;\n  }\n\n  override interceptResolutionState(): InterceptResolutionState {\n    if (!this.#allowInterception) {\n      return {action: InterceptResolutionAction.Disabled};\n    }\n    if (this.#interceptionHandled) {\n      return {action: InterceptResolutionAction.AlreadyHandled};\n    }\n    return {...this.#interceptResolutionState};\n  }\n\n  override isInterceptResolutionHandled(): boolean {\n    return this.#interceptionHandled;\n  }\n\n  enqueueInterceptAction(\n    pendingHandler: () => void | PromiseLike<unknown>\n  ): void {\n    this.#interceptHandlers.push(pendingHandler);\n  }\n\n  override async finalizeInterceptions(): Promise<void> {\n    await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {action} = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return await this.#abort(this.#abortErrorReason);\n      case 'respond':\n        if (this.#responseForRequest === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return await this.#respond(this.#responseForRequest);\n      case 'continue':\n        return await this.#continue(this.#continueRequestOverrides);\n    }\n  }\n\n  override resourceType(): ResourceType {\n    return this.#resourceType;\n  }\n\n  override method(): string {\n    return this.#method;\n  }\n\n  override postData(): string | undefined {\n    return this.#postData;\n  }\n\n  override hasPostData(): boolean {\n    return this.#hasPostData;\n  }\n\n  override async fetchPostData(): Promise<string | undefined> {\n    try {\n      const result = await this.#client.send('Network.getRequestPostData', {\n        requestId: this.id,\n      });\n      return result.postData;\n    } catch (err) {\n      debugError(err);\n      return;\n    }\n  }\n\n  override headers(): Record<string, string> {\n    return this.#headers;\n  }\n\n  override response(): CdpHTTPResponse | null {\n    return this._response;\n  }\n\n  override frame(): Frame | null {\n    return this.#frame;\n  }\n\n  override isNavigationRequest(): boolean {\n    return this.#isNavigationRequest;\n  }\n\n  override initiator(): Protocol.Network.Initiator | undefined {\n    return this.#initiator;\n  }\n\n  override redirectChain(): CdpHTTPRequest[] {\n    return this._redirectChain.slice();\n  }\n\n  override failure(): {errorText: string} | null {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText,\n    };\n  }\n\n  override async continue(\n    overrides: ContinueRequestOverrides = {},\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#continue(overrides);\n    }\n    this.#continueRequestOverrides = overrides;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority > this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (\n        this.#interceptResolutionState.action === 'abort' ||\n        this.#interceptResolutionState.action === 'respond'\n      ) {\n        return;\n      }\n      this.#interceptResolutionState.action =\n        InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n\n  async #continue(overrides: ContinueRequestOverrides = {}): Promise<void> {\n    const {url, method, postData, headers} = overrides;\n    this.#interceptionHandled = true;\n\n    const postDataBinaryBase64 = postData\n      ? Buffer.from(postData).toString('base64')\n      : undefined;\n\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.continueRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.continueRequest', {\n        requestId: this._interceptionId,\n        url,\n        method,\n        postData: postDataBinaryBase64,\n        headers: headers ? headersArray(headers) : undefined,\n      })\n      .catch(error => {\n        this.#interceptionHandled = false;\n        return handleError(error);\n      });\n  }\n\n  override async respond(\n    response: Partial<ResponseForRequest>,\n    priority?: number\n  ): Promise<void> {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#respond(response);\n    }\n    this.#responseForRequest = response;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority > this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Respond;\n    }\n  }\n\n  async #respond(response: Partial<ResponseForRequest>): Promise<void> {\n    this.#interceptionHandled = true;\n\n    const responseBody: Buffer | null =\n      response.body && isString(response.body)\n        ? Buffer.from(response.body)\n        : (response.body as Buffer) || null;\n\n    const responseHeaders: Record<string, string | string[]> = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n\n        responseHeaders[header.toLowerCase()] = Array.isArray(value)\n          ? value.map(item => {\n              return String(item);\n            })\n          : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (responseBody && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(\n        Buffer.byteLength(responseBody)\n      );\n    }\n\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.fulfillRequest', {\n        requestId: this._interceptionId,\n        responseCode: status,\n        responsePhrase: STATUS_TEXTS[status],\n        responseHeaders: headersArray(responseHeaders),\n        body: responseBody ? responseBody.toString('base64') : undefined,\n      })\n      .catch(error => {\n        this.#interceptionHandled = false;\n        return handleError(error);\n      });\n  }\n\n  override async abort(\n    errorCode: ErrorCode = 'failed',\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#abort(errorReason);\n    }\n    this.#abortErrorReason = errorReason;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority >= this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority,\n      };\n      return;\n    }\n  }\n\n  async #abort(\n    errorReason: Protocol.Network.ErrorReason | null\n  ): Promise<void> {\n    this.#interceptionHandled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.failRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.failRequest', {\n        requestId: this._interceptionId,\n        errorReason: errorReason || 'Failed',\n      })\n      .catch(handleError);\n  }\n}\n\nconst errorReasons: Record<ErrorCode, Protocol.Network.ErrorReason> = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed',\n} as const;\n\nasync function handleError(error: ProtocolError) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}