{"ast":null,"code":"var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar matchGraph = require('./match-graph');\nvar MATCH = matchGraph.MATCH;\nvar MISMATCH = matchGraph.MISMATCH;\nvar DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;\nvar TYPE = require('../tokenizer/const').TYPE;\nvar STUB = 0;\nvar TOKEN = 1;\nvar OPEN_SYNTAX = 2;\nvar CLOSE_SYNTAX = 3;\nvar EXIT_REASON_MATCH = 'Match';\nvar EXIT_REASON_MISMATCH = 'Mismatch';\nvar EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\nvar ITERATION_LIMIT = 15000;\nvar totalIterationCount = 0;\nfunction reverseList(list) {\n  var prev = null;\n  var next = null;\n  var item = list;\n  while (item !== null) {\n    next = item.prev;\n    item.prev = prev;\n    prev = item;\n    item = next;\n  }\n  return prev;\n}\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n  if (testStr.length !== referenceStr.length) {\n    return false;\n  }\n  for (var i = 0; i < testStr.length; i++) {\n    var testCode = testStr.charCodeAt(i);\n    var referenceCode = referenceStr.charCodeAt(i);\n\n    // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n    if (testCode >= 0x0041 && testCode <= 0x005A) {\n      testCode = testCode | 32;\n    }\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isContextEdgeDelim(token) {\n  if (token.type !== TYPE.Delim) {\n    return false;\n  }\n\n  // Fix matching for unicode-range: U+30??, U+FF00-FF9F\n  // Probably we need to check out previous match instead\n  return token.value !== '?';\n}\nfunction isCommaContextStart(token) {\n  if (token === null) {\n    return true;\n  }\n  return token.type === TYPE.Comma || token.type === TYPE.Function || token.type === TYPE.LeftParenthesis || token.type === TYPE.LeftSquareBracket || token.type === TYPE.LeftCurlyBracket || isContextEdgeDelim(token);\n}\nfunction isCommaContextEnd(token) {\n  if (token === null) {\n    return true;\n  }\n  return token.type === TYPE.RightParenthesis || token.type === TYPE.RightSquareBracket || token.type === TYPE.RightCurlyBracket || token.type === TYPE.Delim;\n}\nfunction internalMatch(tokens, state, syntaxes) {\n  function moveToNextToken() {\n    do {\n      tokenIndex++;\n      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n    } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n  }\n  function getNextToken(offset) {\n    var nextIndex = tokenIndex + offset;\n    return nextIndex < tokens.length ? tokens[nextIndex] : null;\n  }\n  function stateSnapshotFromSyntax(nextState, prev) {\n    return {\n      nextState: nextState,\n      matchStack: matchStack,\n      syntaxStack: syntaxStack,\n      thenStack: thenStack,\n      tokenIndex: tokenIndex,\n      prev: prev\n    };\n  }\n  function pushThenStack(nextState) {\n    thenStack = {\n      nextState: nextState,\n      matchStack: matchStack,\n      syntaxStack: syntaxStack,\n      prev: thenStack\n    };\n  }\n  function pushElseStack(nextState) {\n    elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n  }\n  function addTokenToMatch() {\n    matchStack = {\n      type: TOKEN,\n      syntax: state.syntax,\n      token: token,\n      prev: matchStack\n    };\n    moveToNextToken();\n    syntaxStash = null;\n    if (tokenIndex > longestMatch) {\n      longestMatch = tokenIndex;\n    }\n  }\n  function openSyntax() {\n    syntaxStack = {\n      syntax: state.syntax,\n      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,\n      prev: syntaxStack\n    };\n    matchStack = {\n      type: OPEN_SYNTAX,\n      syntax: state.syntax,\n      token: matchStack.token,\n      prev: matchStack\n    };\n  }\n  function closeSyntax() {\n    if (matchStack.type === OPEN_SYNTAX) {\n      matchStack = matchStack.prev;\n    } else {\n      matchStack = {\n        type: CLOSE_SYNTAX,\n        syntax: syntaxStack.syntax,\n        token: matchStack.token,\n        prev: matchStack\n      };\n    }\n    syntaxStack = syntaxStack.prev;\n  }\n  var syntaxStack = null;\n  var thenStack = null;\n  var elseStack = null;\n\n  // null – stashing allowed, nothing stashed\n  // false – stashing disabled, nothing stashed\n  // anithing else – fail stashable syntaxes, some syntax stashed\n  var syntaxStash = null;\n  var iterationCount = 0; // count iterations and prevent infinite loop\n  var exitReason = null;\n  var token = null;\n  var tokenIndex = -1;\n  var longestMatch = 0;\n  var matchStack = {\n    type: STUB,\n    syntax: null,\n    token: null,\n    prev: null\n  };\n  moveToNextToken();\n  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n    // function mapList(list, fn) {\n    //     var result = [];\n    //     while (list) {\n    //         result.unshift(fn(list));\n    //         list = list.prev;\n    //     }\n    //     return result;\n    // }\n    // console.log('--\\n',\n    //     '#' + iterationCount,\n    //     require('util').inspect({\n    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n    //         token: token && token.value,\n    //         tokenIndex,\n    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n    //     }, { depth: null })\n    // );\n    switch (state.type) {\n      case 'Match':\n        if (thenStack === null) {\n          // turn to MISMATCH when some tokens left unmatched\n          if (token !== null) {\n            // doesn't mismatch if just one token left and it's an IE hack\n            if (tokenIndex !== tokens.length - 1 || token.value !== '\\\\0' && token.value !== '\\\\9') {\n              state = MISMATCH;\n              break;\n            }\n          }\n\n          // break the main loop, return a result - MATCH\n          exitReason = EXIT_REASON_MATCH;\n          break;\n        }\n\n        // go to next syntax (`then` branch)\n        state = thenStack.nextState;\n\n        // check match is not empty\n        if (state === DISALLOW_EMPTY) {\n          if (thenStack.matchStack === matchStack) {\n            state = MISMATCH;\n            break;\n          } else {\n            state = MATCH;\n          }\n        }\n\n        // close syntax if needed\n        while (thenStack.syntaxStack !== syntaxStack) {\n          closeSyntax();\n        }\n\n        // pop stack\n        thenStack = thenStack.prev;\n        break;\n      case 'Mismatch':\n        // when some syntax is stashed\n        if (syntaxStash !== null && syntaxStash !== false) {\n          // there is no else branches or a branch reduce match stack\n          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n            // restore state from the stash\n            elseStack = syntaxStash;\n            syntaxStash = false; // disable stashing\n          }\n        } else if (elseStack === null) {\n          // no else branches -> break the main loop\n          // return a result - MISMATCH\n          exitReason = EXIT_REASON_MISMATCH;\n          break;\n        }\n\n        // go to next syntax (`else` branch)\n        state = elseStack.nextState;\n\n        // restore all the rest stack states\n        thenStack = elseStack.thenStack;\n        syntaxStack = elseStack.syntaxStack;\n        matchStack = elseStack.matchStack;\n        tokenIndex = elseStack.tokenIndex;\n        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n        // pop stack\n        elseStack = elseStack.prev;\n        break;\n      case 'MatchGraph':\n        state = state.match;\n        break;\n      case 'If':\n        // IMPORTANT: else stack push must go first,\n        // since it stores the state of thenStack before changes\n        if (state.else !== MISMATCH) {\n          pushElseStack(state.else);\n        }\n        if (state.then !== MATCH) {\n          pushThenStack(state.then);\n        }\n        state = state.match;\n        break;\n      case 'MatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state,\n          index: 0,\n          mask: 0\n        };\n        break;\n      case 'MatchOnceBuffer':\n        var terms = state.syntax.terms;\n        if (state.index === terms.length) {\n          // no matches at all or it's required all terms to be matched\n          if (state.mask === 0 || state.syntax.all) {\n            state = MISMATCH;\n            break;\n          }\n\n          // a partial match is ok\n          state = MATCH;\n          break;\n        }\n\n        // all terms are matched\n        if (state.mask === (1 << terms.length) - 1) {\n          state = MATCH;\n          break;\n        }\n        for (; state.index < terms.length; state.index++) {\n          var matchFlag = 1 << state.index;\n          if ((state.mask & matchFlag) === 0) {\n            // IMPORTANT: else stack push must go first,\n            // since it stores the state of thenStack before changes\n            pushElseStack(state);\n            pushThenStack({\n              type: 'AddMatchOnce',\n              syntax: state.syntax,\n              mask: state.mask | matchFlag\n            });\n\n            // match\n            state = terms[state.index++];\n            break;\n          }\n        }\n        break;\n      case 'AddMatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state.syntax,\n          index: 0,\n          mask: state.mask\n        };\n        break;\n      case 'Enum':\n        if (token !== null) {\n          var name = token.value.toLowerCase();\n\n          // drop \\0 and \\9 hack from keyword name\n          if (name.indexOf('\\\\') !== -1) {\n            name = name.replace(/\\\\[09].*$/, '');\n          }\n          if (hasOwnProperty.call(state.map, name)) {\n            state = state.map[name];\n            break;\n          }\n        }\n        state = MISMATCH;\n        break;\n      case 'Generic':\n        var opts = syntaxStack !== null ? syntaxStack.opts : null;\n        var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n        if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n          state = MATCH;\n        } else {\n          state = MISMATCH;\n        }\n        break;\n      case 'Type':\n      case 'Property':\n        var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n        var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n        if (!dictSyntax || !dictSyntax.match) {\n          throw new Error('Bad syntax reference: ' + (state.type === 'Type' ? '<' + state.name + '>' : '<\\'' + state.name + '\\'>'));\n        }\n\n        // stash a syntax for types with low priority\n        if (syntaxStash !== false && token !== null && state.type === 'Type') {\n          var lowPriorityMatching =\n          // https://drafts.csswg.org/css-values-4/#custom-idents\n          // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n          // can only claim the keyword if no other unfulfilled production can claim it.\n          state.name === 'custom-ident' && token.type === TYPE.Ident ||\n          // https://drafts.csswg.org/css-values-4/#lengths\n          // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n          // it must parse as a <number>\n          state.name === 'length' && token.value === '0';\n          if (lowPriorityMatching) {\n            if (syntaxStash === null) {\n              syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n            }\n            state = MISMATCH;\n            break;\n          }\n        }\n        openSyntax();\n        state = dictSyntax.match;\n        break;\n      case 'Keyword':\n        var name = state.name;\n        if (token !== null) {\n          var keywordName = token.value;\n\n          // drop \\0 and \\9 hack from keyword name\n          if (keywordName.indexOf('\\\\') !== -1) {\n            keywordName = keywordName.replace(/\\\\[09].*$/, '');\n          }\n          if (areStringsEqualCaseInsensitive(keywordName, name)) {\n            addTokenToMatch();\n            state = MATCH;\n            break;\n          }\n        }\n        state = MISMATCH;\n        break;\n      case 'AtKeyword':\n      case 'Function':\n        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n          addTokenToMatch();\n          state = MATCH;\n          break;\n        }\n        state = MISMATCH;\n        break;\n      case 'Token':\n        if (token !== null && token.value === state.value) {\n          addTokenToMatch();\n          state = MATCH;\n          break;\n        }\n        state = MISMATCH;\n        break;\n      case 'Comma':\n        if (token !== null && token.type === TYPE.Comma) {\n          if (isCommaContextStart(matchStack.token)) {\n            state = MISMATCH;\n          } else {\n            addTokenToMatch();\n            state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n          }\n        } else {\n          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n        }\n        break;\n      case 'String':\n        var string = '';\n        for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n          string += tokens[lastTokenIndex].value;\n        }\n        if (areStringsEqualCaseInsensitive(string, state.value)) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n          state = MATCH;\n        } else {\n          state = MISMATCH;\n        }\n        break;\n      default:\n        throw new Error('Unknown node type: ' + state.type);\n    }\n  }\n  totalIterationCount += iterationCount;\n  switch (exitReason) {\n    case null:\n      console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n      exitReason = EXIT_REASON_ITERATION_LIMIT;\n      matchStack = null;\n      break;\n    case EXIT_REASON_MATCH:\n      while (syntaxStack !== null) {\n        closeSyntax();\n      }\n      break;\n    default:\n      matchStack = null;\n  }\n  return {\n    tokens: tokens,\n    reason: exitReason,\n    iterations: iterationCount,\n    match: matchStack,\n    longestMatch: longestMatch\n  };\n}\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n  if (matchResult.match !== null) {\n    var item = reverseList(matchResult.match).prev;\n    matchResult.match = [];\n    while (item !== null) {\n      switch (item.type) {\n        case STUB:\n          break;\n        case OPEN_SYNTAX:\n        case CLOSE_SYNTAX:\n          matchResult.match.push({\n            type: item.type,\n            syntax: item.syntax\n          });\n          break;\n        default:\n          matchResult.match.push({\n            token: item.token.value,\n            node: item.token.node\n          });\n          break;\n      }\n      item = item.prev;\n    }\n  }\n  return matchResult;\n}\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n  if (matchResult.match === null) {\n    return matchResult;\n  }\n  var item = matchResult.match;\n  var host = matchResult.match = {\n    syntax: matchGraph.syntax || null,\n    match: []\n  };\n  var hostStack = [host];\n\n  // revert a list and start with 2nd item since 1st is a stub item\n  item = reverseList(item).prev;\n\n  // build a tree\n  while (item !== null) {\n    switch (item.type) {\n      case OPEN_SYNTAX:\n        host.match.push(host = {\n          syntax: item.syntax,\n          match: []\n        });\n        hostStack.push(host);\n        break;\n      case CLOSE_SYNTAX:\n        hostStack.pop();\n        host = hostStack[hostStack.length - 1];\n        break;\n      default:\n        host.match.push({\n          syntax: item.syntax || null,\n          token: item.token.value,\n          node: item.token.node\n        });\n    }\n    item = item.prev;\n  }\n  return matchResult;\n}\nmodule.exports = {\n  matchAsList: matchAsList,\n  matchAsTree: matchAsTree,\n  getTotalIterationCount: function () {\n    return totalIterationCount;\n  }\n};","map":{"version":3,"names":["hasOwnProperty","Object","prototype","matchGraph","require","MATCH","MISMATCH","DISALLOW_EMPTY","TYPE","STUB","TOKEN","OPEN_SYNTAX","CLOSE_SYNTAX","EXIT_REASON_MATCH","EXIT_REASON_MISMATCH","EXIT_REASON_ITERATION_LIMIT","ITERATION_LIMIT","totalIterationCount","reverseList","list","prev","next","item","areStringsEqualCaseInsensitive","testStr","referenceStr","length","i","testCode","charCodeAt","referenceCode","isContextEdgeDelim","token","type","Delim","value","isCommaContextStart","Comma","Function","LeftParenthesis","LeftSquareBracket","LeftCurlyBracket","isCommaContextEnd","RightParenthesis","RightSquareBracket","RightCurlyBracket","internalMatch","tokens","state","syntaxes","moveToNextToken","tokenIndex","WhiteSpace","Comment","getNextToken","offset","nextIndex","stateSnapshotFromSyntax","nextState","matchStack","syntaxStack","thenStack","pushThenStack","pushElseStack","elseStack","addTokenToMatch","syntax","syntaxStash","longestMatch","openSyntax","opts","closeSyntax","iterationCount","exitReason","match","else","then","index","mask","terms","all","matchFlag","name","toLowerCase","indexOf","replace","call","map","lastTokenIndex","Math","floor","fn","isNaN","syntaxDict","dictSyntax","Error","lowPriorityMatching","Ident","keywordName","string","console","warn","reason","iterations","matchAsList","matchResult","push","node","matchAsTree","host","hostStack","pop","module","exports","getTotalIterationCount"],"sources":["/Users/jeffreyvanoosterwijk/Desktop/repos/resume-generator/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/match.js"],"sourcesContent":["var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar matchGraph = require('./match-graph');\nvar MATCH = matchGraph.MATCH;\nvar MISMATCH = matchGraph.MISMATCH;\nvar DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;\nvar TYPE = require('../tokenizer/const').TYPE;\n\nvar STUB = 0;\nvar TOKEN = 1;\nvar OPEN_SYNTAX = 2;\nvar CLOSE_SYNTAX = 3;\n\nvar EXIT_REASON_MATCH = 'Match';\nvar EXIT_REASON_MISMATCH = 'Mismatch';\nvar EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\n\nvar ITERATION_LIMIT = 15000;\nvar totalIterationCount = 0;\n\nfunction reverseList(list) {\n    var prev = null;\n    var next = null;\n    var item = list;\n\n    while (item !== null) {\n        next = item.prev;\n        item.prev = prev;\n        prev = item;\n        item = next;\n    }\n\n    return prev;\n}\n\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n    if (testStr.length !== referenceStr.length) {\n        return false;\n    }\n\n    for (var i = 0; i < testStr.length; i++) {\n        var testCode = testStr.charCodeAt(i);\n        var referenceCode = referenceStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n        if (testCode >= 0x0041 && testCode <= 0x005A) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction isContextEdgeDelim(token) {\n    if (token.type !== TYPE.Delim) {\n        return false;\n    }\n\n    // Fix matching for unicode-range: U+30??, U+FF00-FF9F\n    // Probably we need to check out previous match instead\n    return token.value !== '?';\n}\n\nfunction isCommaContextStart(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.Comma ||\n        token.type === TYPE.Function ||\n        token.type === TYPE.LeftParenthesis ||\n        token.type === TYPE.LeftSquareBracket ||\n        token.type === TYPE.LeftCurlyBracket ||\n        isContextEdgeDelim(token)\n    );\n}\n\nfunction isCommaContextEnd(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.RightParenthesis ||\n        token.type === TYPE.RightSquareBracket ||\n        token.type === TYPE.RightCurlyBracket ||\n        token.type === TYPE.Delim\n    );\n}\n\nfunction internalMatch(tokens, state, syntaxes) {\n    function moveToNextToken() {\n        do {\n            tokenIndex++;\n            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n    }\n\n    function getNextToken(offset) {\n        var nextIndex = tokenIndex + offset;\n\n        return nextIndex < tokens.length ? tokens[nextIndex] : null;\n    }\n\n    function stateSnapshotFromSyntax(nextState, prev) {\n        return {\n            nextState: nextState,\n            matchStack: matchStack,\n            syntaxStack: syntaxStack,\n            thenStack: thenStack,\n            tokenIndex: tokenIndex,\n            prev: prev\n        };\n    }\n\n    function pushThenStack(nextState) {\n        thenStack = {\n            nextState: nextState,\n            matchStack: matchStack,\n            syntaxStack: syntaxStack,\n            prev: thenStack\n        };\n    }\n\n    function pushElseStack(nextState) {\n        elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n    }\n\n    function addTokenToMatch() {\n        matchStack = {\n            type: TOKEN,\n            syntax: state.syntax,\n            token: token,\n            prev: matchStack\n        };\n\n        moveToNextToken();\n        syntaxStash = null;\n\n        if (tokenIndex > longestMatch) {\n            longestMatch = tokenIndex;\n        }\n    }\n\n    function openSyntax() {\n        syntaxStack = {\n            syntax: state.syntax,\n            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,\n            prev: syntaxStack\n        };\n\n        matchStack = {\n            type: OPEN_SYNTAX,\n            syntax: state.syntax,\n            token: matchStack.token,\n            prev: matchStack\n        };\n    }\n\n    function closeSyntax() {\n        if (matchStack.type === OPEN_SYNTAX) {\n            matchStack = matchStack.prev;\n        } else {\n            matchStack = {\n                type: CLOSE_SYNTAX,\n                syntax: syntaxStack.syntax,\n                token: matchStack.token,\n                prev: matchStack\n            };\n        }\n\n        syntaxStack = syntaxStack.prev;\n    }\n\n    var syntaxStack = null;\n    var thenStack = null;\n    var elseStack = null;\n\n    // null – stashing allowed, nothing stashed\n    // false – stashing disabled, nothing stashed\n    // anithing else – fail stashable syntaxes, some syntax stashed\n    var syntaxStash = null;\n\n    var iterationCount = 0; // count iterations and prevent infinite loop\n    var exitReason = null;\n\n    var token = null;\n    var tokenIndex = -1;\n    var longestMatch = 0;\n    var matchStack = {\n        type: STUB,\n        syntax: null,\n        token: null,\n        prev: null\n    };\n\n    moveToNextToken();\n\n    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n        // function mapList(list, fn) {\n        //     var result = [];\n        //     while (list) {\n        //         result.unshift(fn(list));\n        //         list = list.prev;\n        //     }\n        //     return result;\n        // }\n        // console.log('--\\n',\n        //     '#' + iterationCount,\n        //     require('util').inspect({\n        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n        //         token: token && token.value,\n        //         tokenIndex,\n        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n        //     }, { depth: null })\n        // );\n        switch (state.type) {\n            case 'Match':\n                if (thenStack === null) {\n                    // turn to MISMATCH when some tokens left unmatched\n                    if (token !== null) {\n                        // doesn't mismatch if just one token left and it's an IE hack\n                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\\\0' && token.value !== '\\\\9')) {\n                            state = MISMATCH;\n                            break;\n                        }\n                    }\n\n                    // break the main loop, return a result - MATCH\n                    exitReason = EXIT_REASON_MATCH;\n                    break;\n                }\n\n                // go to next syntax (`then` branch)\n                state = thenStack.nextState;\n\n                // check match is not empty\n                if (state === DISALLOW_EMPTY) {\n                    if (thenStack.matchStack === matchStack) {\n                        state = MISMATCH;\n                        break;\n                    } else {\n                        state = MATCH;\n                    }\n                }\n\n                // close syntax if needed\n                while (thenStack.syntaxStack !== syntaxStack) {\n                    closeSyntax();\n                }\n\n                // pop stack\n                thenStack = thenStack.prev;\n                break;\n\n            case 'Mismatch':\n                // when some syntax is stashed\n                if (syntaxStash !== null && syntaxStash !== false) {\n                    // there is no else branches or a branch reduce match stack\n                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n                        // restore state from the stash\n                        elseStack = syntaxStash;\n                        syntaxStash = false; // disable stashing\n                    }\n                } else if (elseStack === null) {\n                    // no else branches -> break the main loop\n                    // return a result - MISMATCH\n                    exitReason = EXIT_REASON_MISMATCH;\n                    break;\n                }\n\n                // go to next syntax (`else` branch)\n                state = elseStack.nextState;\n\n                // restore all the rest stack states\n                thenStack = elseStack.thenStack;\n                syntaxStack = elseStack.syntaxStack;\n                matchStack = elseStack.matchStack;\n                tokenIndex = elseStack.tokenIndex;\n                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n                // pop stack\n                elseStack = elseStack.prev;\n                break;\n\n            case 'MatchGraph':\n                state = state.match;\n                break;\n\n            case 'If':\n                // IMPORTANT: else stack push must go first,\n                // since it stores the state of thenStack before changes\n                if (state.else !== MISMATCH) {\n                    pushElseStack(state.else);\n                }\n\n                if (state.then !== MATCH) {\n                    pushThenStack(state.then);\n                }\n\n                state = state.match;\n                break;\n\n            case 'MatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state,\n                    index: 0,\n                    mask: 0\n                };\n                break;\n\n            case 'MatchOnceBuffer':\n                var terms = state.syntax.terms;\n\n                if (state.index === terms.length) {\n                    // no matches at all or it's required all terms to be matched\n                    if (state.mask === 0 || state.syntax.all) {\n                        state = MISMATCH;\n                        break;\n                    }\n\n                    // a partial match is ok\n                    state = MATCH;\n                    break;\n                }\n\n                // all terms are matched\n                if (state.mask === (1 << terms.length) - 1) {\n                    state = MATCH;\n                    break;\n                }\n\n                for (; state.index < terms.length; state.index++) {\n                    var matchFlag = 1 << state.index;\n\n                    if ((state.mask & matchFlag) === 0) {\n                        // IMPORTANT: else stack push must go first,\n                        // since it stores the state of thenStack before changes\n                        pushElseStack(state);\n                        pushThenStack({\n                            type: 'AddMatchOnce',\n                            syntax: state.syntax,\n                            mask: state.mask | matchFlag\n                        });\n\n                        // match\n                        state = terms[state.index++];\n                        break;\n                    }\n                }\n                break;\n\n            case 'AddMatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state.syntax,\n                    index: 0,\n                    mask: state.mask\n                };\n                break;\n\n            case 'Enum':\n                if (token !== null) {\n                    var name = token.value.toLowerCase();\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (name.indexOf('\\\\') !== -1) {\n                        name = name.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (hasOwnProperty.call(state.map, name)) {\n                        state = state.map[name];\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Generic':\n                var opts = syntaxStack !== null ? syntaxStack.opts : null;\n                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            case 'Type':\n            case 'Property':\n                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n                var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n                if (!dictSyntax || !dictSyntax.match) {\n                    throw new Error(\n                        'Bad syntax reference: ' +\n                        (state.type === 'Type'\n                            ? '<' + state.name + '>'\n                            : '<\\'' + state.name + '\\'>')\n                    );\n                }\n\n                // stash a syntax for types with low priority\n                if (syntaxStash !== false && token !== null && state.type === 'Type') {\n                    var lowPriorityMatching =\n                        // https://drafts.csswg.org/css-values-4/#custom-idents\n                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n                        // can only claim the keyword if no other unfulfilled production can claim it.\n                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||\n\n                        // https://drafts.csswg.org/css-values-4/#lengths\n                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n                        // it must parse as a <number>\n                        (state.name === 'length' && token.value === '0');\n\n                    if (lowPriorityMatching) {\n                        if (syntaxStash === null) {\n                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n                        }\n\n                        state = MISMATCH;\n                        break;\n                    }\n                }\n\n                openSyntax();\n                state = dictSyntax.match;\n                break;\n\n            case 'Keyword':\n                var name = state.name;\n\n                if (token !== null) {\n                    var keywordName = token.value;\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (keywordName.indexOf('\\\\') !== -1) {\n                        keywordName = keywordName.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (areStringsEqualCaseInsensitive(keywordName, name)) {\n                        addTokenToMatch();\n                        state = MATCH;\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'AtKeyword':\n            case 'Function':\n                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Token':\n                if (token !== null && token.value === state.value) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Comma':\n                if (token !== null && token.type === TYPE.Comma) {\n                    if (isCommaContextStart(matchStack.token)) {\n                        state = MISMATCH;\n                    } else {\n                        addTokenToMatch();\n                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n                    }\n                } else {\n                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n                }\n\n                break;\n\n            case 'String':\n                var string = '';\n\n                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n                    string += tokens[lastTokenIndex].value;\n                }\n\n                if (areStringsEqualCaseInsensitive(string, state.value)) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            default:\n                throw new Error('Unknown node type: ' + state.type);\n        }\n    }\n\n    totalIterationCount += iterationCount;\n\n    switch (exitReason) {\n        case null:\n            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n            exitReason = EXIT_REASON_ITERATION_LIMIT;\n            matchStack = null;\n            break;\n\n        case EXIT_REASON_MATCH:\n            while (syntaxStack !== null) {\n                closeSyntax();\n            }\n            break;\n\n        default:\n            matchStack = null;\n    }\n\n    return {\n        tokens: tokens,\n        reason: exitReason,\n        iterations: iterationCount,\n        match: matchStack,\n        longestMatch: longestMatch\n    };\n}\n\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match !== null) {\n        var item = reverseList(matchResult.match).prev;\n\n        matchResult.match = [];\n\n        while (item !== null) {\n            switch (item.type) {\n                case STUB:\n                    break;\n\n                case OPEN_SYNTAX:\n                case CLOSE_SYNTAX:\n                    matchResult.match.push({\n                        type: item.type,\n                        syntax: item.syntax\n                    });\n                    break;\n\n                default:\n                    matchResult.match.push({\n                        token: item.token.value,\n                        node: item.token.node\n                    });\n                    break;\n            }\n\n            item = item.prev;\n        }\n    }\n\n    return matchResult;\n}\n\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match === null) {\n        return matchResult;\n    }\n\n    var item = matchResult.match;\n    var host = matchResult.match = {\n        syntax: matchGraph.syntax || null,\n        match: []\n    };\n    var hostStack = [host];\n\n    // revert a list and start with 2nd item since 1st is a stub item\n    item = reverseList(item).prev;\n\n    // build a tree\n    while (item !== null) {\n        switch (item.type) {\n            case OPEN_SYNTAX:\n                host.match.push(host = {\n                    syntax: item.syntax,\n                    match: []\n                });\n                hostStack.push(host);\n                break;\n\n            case CLOSE_SYNTAX:\n                hostStack.pop();\n                host = hostStack[hostStack.length - 1];\n                break;\n\n            default:\n                host.match.push({\n                    syntax: item.syntax || null,\n                    token: item.token.value,\n                    node: item.token.node\n                });\n        }\n\n        item = item.prev;\n    }\n\n    return matchResult;\n}\n\nmodule.exports = {\n    matchAsList: matchAsList,\n    matchAsTree: matchAsTree,\n    getTotalIterationCount: function() {\n        return totalIterationCount;\n    }\n};\n"],"mappings":"AAAA,IAAIA,cAAc,GAAGC,MAAM,CAACC,SAAS,CAACF,cAAc;AACpD,IAAIG,UAAU,GAAGC,OAAO,CAAC,eAAe,CAAC;AACzC,IAAIC,KAAK,GAAGF,UAAU,CAACE,KAAK;AAC5B,IAAIC,QAAQ,GAAGH,UAAU,CAACG,QAAQ;AAClC,IAAIC,cAAc,GAAGJ,UAAU,CAACI,cAAc;AAC9C,IAAIC,IAAI,GAAGJ,OAAO,CAAC,oBAAoB,CAAC,CAACI,IAAI;AAE7C,IAAIC,IAAI,GAAG,CAAC;AACZ,IAAIC,KAAK,GAAG,CAAC;AACb,IAAIC,WAAW,GAAG,CAAC;AACnB,IAAIC,YAAY,GAAG,CAAC;AAEpB,IAAIC,iBAAiB,GAAG,OAAO;AAC/B,IAAIC,oBAAoB,GAAG,UAAU;AACrC,IAAIC,2BAA2B,GAAG,uGAAuG;AAEzI,IAAIC,eAAe,GAAG,KAAK;AAC3B,IAAIC,mBAAmB,GAAG,CAAC;AAE3B,SAASC,WAAWA,CAACC,IAAI,EAAE;EACvB,IAAIC,IAAI,GAAG,IAAI;EACf,IAAIC,IAAI,GAAG,IAAI;EACf,IAAIC,IAAI,GAAGH,IAAI;EAEf,OAAOG,IAAI,KAAK,IAAI,EAAE;IAClBD,IAAI,GAAGC,IAAI,CAACF,IAAI;IAChBE,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChBA,IAAI,GAAGE,IAAI;IACXA,IAAI,GAAGD,IAAI;EACf;EAEA,OAAOD,IAAI;AACf;AAEA,SAASG,8BAA8BA,CAACC,OAAO,EAAEC,YAAY,EAAE;EAC3D,IAAID,OAAO,CAACE,MAAM,KAAKD,YAAY,CAACC,MAAM,EAAE;IACxC,OAAO,KAAK;EAChB;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,OAAO,CAACE,MAAM,EAAEC,CAAC,EAAE,EAAE;IACrC,IAAIC,QAAQ,GAAGJ,OAAO,CAACK,UAAU,CAACF,CAAC,CAAC;IACpC,IAAIG,aAAa,GAAGL,YAAY,CAACI,UAAU,CAACF,CAAC,CAAC;;IAE9C;IACA,IAAIC,QAAQ,IAAI,MAAM,IAAIA,QAAQ,IAAI,MAAM,EAAE;MAC1CA,QAAQ,GAAGA,QAAQ,GAAG,EAAE;IAC5B;IAEA,IAAIA,QAAQ,KAAKE,aAAa,EAAE;MAC5B,OAAO,KAAK;IAChB;EACJ;EAEA,OAAO,IAAI;AACf;AAEA,SAASC,kBAAkBA,CAACC,KAAK,EAAE;EAC/B,IAAIA,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAAC0B,KAAK,EAAE;IAC3B,OAAO,KAAK;EAChB;;EAEA;EACA;EACA,OAAOF,KAAK,CAACG,KAAK,KAAK,GAAG;AAC9B;AAEA,SAASC,mBAAmBA,CAACJ,KAAK,EAAE;EAChC,IAAIA,KAAK,KAAK,IAAI,EAAE;IAChB,OAAO,IAAI;EACf;EAEA,OACIA,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAAC6B,KAAK,IACzBL,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAAC8B,QAAQ,IAC5BN,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAAC+B,eAAe,IACnCP,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAACgC,iBAAiB,IACrCR,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAACiC,gBAAgB,IACpCV,kBAAkB,CAACC,KAAK,CAAC;AAEjC;AAEA,SAASU,iBAAiBA,CAACV,KAAK,EAAE;EAC9B,IAAIA,KAAK,KAAK,IAAI,EAAE;IAChB,OAAO,IAAI;EACf;EAEA,OACIA,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAACmC,gBAAgB,IACpCX,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAACoC,kBAAkB,IACtCZ,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAACqC,iBAAiB,IACrCb,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAAC0B,KAAK;AAEjC;AAEA,SAASY,aAAaA,CAACC,MAAM,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EAC5C,SAASC,eAAeA,CAAA,EAAG;IACvB,GAAG;MACCC,UAAU,EAAE;MACZnB,KAAK,GAAGmB,UAAU,GAAGJ,MAAM,CAACrB,MAAM,GAAGqB,MAAM,CAACI,UAAU,CAAC,GAAG,IAAI;IAClE,CAAC,QAAQnB,KAAK,KAAK,IAAI,KAAKA,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAAC4C,UAAU,IAAIpB,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAAC6C,OAAO,CAAC;EAC9F;EAEA,SAASC,YAAYA,CAACC,MAAM,EAAE;IAC1B,IAAIC,SAAS,GAAGL,UAAU,GAAGI,MAAM;IAEnC,OAAOC,SAAS,GAAGT,MAAM,CAACrB,MAAM,GAAGqB,MAAM,CAACS,SAAS,CAAC,GAAG,IAAI;EAC/D;EAEA,SAASC,uBAAuBA,CAACC,SAAS,EAAEtC,IAAI,EAAE;IAC9C,OAAO;MACHsC,SAAS,EAAEA,SAAS;MACpBC,UAAU,EAAEA,UAAU;MACtBC,WAAW,EAAEA,WAAW;MACxBC,SAAS,EAAEA,SAAS;MACpBV,UAAU,EAAEA,UAAU;MACtB/B,IAAI,EAAEA;IACV,CAAC;EACL;EAEA,SAAS0C,aAAaA,CAACJ,SAAS,EAAE;IAC9BG,SAAS,GAAG;MACRH,SAAS,EAAEA,SAAS;MACpBC,UAAU,EAAEA,UAAU;MACtBC,WAAW,EAAEA,WAAW;MACxBxC,IAAI,EAAEyC;IACV,CAAC;EACL;EAEA,SAASE,aAAaA,CAACL,SAAS,EAAE;IAC9BM,SAAS,GAAGP,uBAAuB,CAACC,SAAS,EAAEM,SAAS,CAAC;EAC7D;EAEA,SAASC,eAAeA,CAAA,EAAG;IACvBN,UAAU,GAAG;MACT1B,IAAI,EAAEvB,KAAK;MACXwD,MAAM,EAAElB,KAAK,CAACkB,MAAM;MACpBlC,KAAK,EAAEA,KAAK;MACZZ,IAAI,EAAEuC;IACV,CAAC;IAEDT,eAAe,CAAC,CAAC;IACjBiB,WAAW,GAAG,IAAI;IAElB,IAAIhB,UAAU,GAAGiB,YAAY,EAAE;MAC3BA,YAAY,GAAGjB,UAAU;IAC7B;EACJ;EAEA,SAASkB,UAAUA,CAAA,EAAG;IAClBT,WAAW,GAAG;MACVM,MAAM,EAAElB,KAAK,CAACkB,MAAM;MACpBI,IAAI,EAAEtB,KAAK,CAACkB,MAAM,CAACI,IAAI,IAAKV,WAAW,KAAK,IAAI,IAAIA,WAAW,CAACU,IAAK,IAAI,IAAI;MAC7ElD,IAAI,EAAEwC;IACV,CAAC;IAEDD,UAAU,GAAG;MACT1B,IAAI,EAAEtB,WAAW;MACjBuD,MAAM,EAAElB,KAAK,CAACkB,MAAM;MACpBlC,KAAK,EAAE2B,UAAU,CAAC3B,KAAK;MACvBZ,IAAI,EAAEuC;IACV,CAAC;EACL;EAEA,SAASY,WAAWA,CAAA,EAAG;IACnB,IAAIZ,UAAU,CAAC1B,IAAI,KAAKtB,WAAW,EAAE;MACjCgD,UAAU,GAAGA,UAAU,CAACvC,IAAI;IAChC,CAAC,MAAM;MACHuC,UAAU,GAAG;QACT1B,IAAI,EAAErB,YAAY;QAClBsD,MAAM,EAAEN,WAAW,CAACM,MAAM;QAC1BlC,KAAK,EAAE2B,UAAU,CAAC3B,KAAK;QACvBZ,IAAI,EAAEuC;MACV,CAAC;IACL;IAEAC,WAAW,GAAGA,WAAW,CAACxC,IAAI;EAClC;EAEA,IAAIwC,WAAW,GAAG,IAAI;EACtB,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIG,SAAS,GAAG,IAAI;;EAEpB;EACA;EACA;EACA,IAAIG,WAAW,GAAG,IAAI;EAEtB,IAAIK,cAAc,GAAG,CAAC,CAAC,CAAC;EACxB,IAAIC,UAAU,GAAG,IAAI;EAErB,IAAIzC,KAAK,GAAG,IAAI;EAChB,IAAImB,UAAU,GAAG,CAAC,CAAC;EACnB,IAAIiB,YAAY,GAAG,CAAC;EACpB,IAAIT,UAAU,GAAG;IACb1B,IAAI,EAAExB,IAAI;IACVyD,MAAM,EAAE,IAAI;IACZlC,KAAK,EAAE,IAAI;IACXZ,IAAI,EAAE;EACV,CAAC;EAED8B,eAAe,CAAC,CAAC;EAEjB,OAAOuB,UAAU,KAAK,IAAI,IAAI,EAAED,cAAc,GAAGxD,eAAe,EAAE;IAC9D;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,QAAQgC,KAAK,CAACf,IAAI;MACd,KAAK,OAAO;QACR,IAAI4B,SAAS,KAAK,IAAI,EAAE;UACpB;UACA,IAAI7B,KAAK,KAAK,IAAI,EAAE;YAChB;YACA,IAAImB,UAAU,KAAKJ,MAAM,CAACrB,MAAM,GAAG,CAAC,IAAKM,KAAK,CAACG,KAAK,KAAK,KAAK,IAAIH,KAAK,CAACG,KAAK,KAAK,KAAM,EAAE;cACtFa,KAAK,GAAG1C,QAAQ;cAChB;YACJ;UACJ;;UAEA;UACAmE,UAAU,GAAG5D,iBAAiB;UAC9B;QACJ;;QAEA;QACAmC,KAAK,GAAGa,SAAS,CAACH,SAAS;;QAE3B;QACA,IAAIV,KAAK,KAAKzC,cAAc,EAAE;UAC1B,IAAIsD,SAAS,CAACF,UAAU,KAAKA,UAAU,EAAE;YACrCX,KAAK,GAAG1C,QAAQ;YAChB;UACJ,CAAC,MAAM;YACH0C,KAAK,GAAG3C,KAAK;UACjB;QACJ;;QAEA;QACA,OAAOwD,SAAS,CAACD,WAAW,KAAKA,WAAW,EAAE;UAC1CW,WAAW,CAAC,CAAC;QACjB;;QAEA;QACAV,SAAS,GAAGA,SAAS,CAACzC,IAAI;QAC1B;MAEJ,KAAK,UAAU;QACX;QACA,IAAI+C,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,EAAE;UAC/C;UACA,IAAIH,SAAS,KAAK,IAAI,IAAIb,UAAU,GAAGa,SAAS,CAACb,UAAU,EAAE;YACzD;YACAa,SAAS,GAAGG,WAAW;YACvBA,WAAW,GAAG,KAAK,CAAC,CAAC;UACzB;QACJ,CAAC,MAAM,IAAIH,SAAS,KAAK,IAAI,EAAE;UAC3B;UACA;UACAS,UAAU,GAAG3D,oBAAoB;UACjC;QACJ;;QAEA;QACAkC,KAAK,GAAGgB,SAAS,CAACN,SAAS;;QAE3B;QACAG,SAAS,GAAGG,SAAS,CAACH,SAAS;QAC/BD,WAAW,GAAGI,SAAS,CAACJ,WAAW;QACnCD,UAAU,GAAGK,SAAS,CAACL,UAAU;QACjCR,UAAU,GAAGa,SAAS,CAACb,UAAU;QACjCnB,KAAK,GAAGmB,UAAU,GAAGJ,MAAM,CAACrB,MAAM,GAAGqB,MAAM,CAACI,UAAU,CAAC,GAAG,IAAI;;QAE9D;QACAa,SAAS,GAAGA,SAAS,CAAC5C,IAAI;QAC1B;MAEJ,KAAK,YAAY;QACb4B,KAAK,GAAGA,KAAK,CAAC0B,KAAK;QACnB;MAEJ,KAAK,IAAI;QACL;QACA;QACA,IAAI1B,KAAK,CAAC2B,IAAI,KAAKrE,QAAQ,EAAE;UACzByD,aAAa,CAACf,KAAK,CAAC2B,IAAI,CAAC;QAC7B;QAEA,IAAI3B,KAAK,CAAC4B,IAAI,KAAKvE,KAAK,EAAE;UACtByD,aAAa,CAACd,KAAK,CAAC4B,IAAI,CAAC;QAC7B;QAEA5B,KAAK,GAAGA,KAAK,CAAC0B,KAAK;QACnB;MAEJ,KAAK,WAAW;QACZ1B,KAAK,GAAG;UACJf,IAAI,EAAE,iBAAiB;UACvBiC,MAAM,EAAElB,KAAK;UACb6B,KAAK,EAAE,CAAC;UACRC,IAAI,EAAE;QACV,CAAC;QACD;MAEJ,KAAK,iBAAiB;QAClB,IAAIC,KAAK,GAAG/B,KAAK,CAACkB,MAAM,CAACa,KAAK;QAE9B,IAAI/B,KAAK,CAAC6B,KAAK,KAAKE,KAAK,CAACrD,MAAM,EAAE;UAC9B;UACA,IAAIsB,KAAK,CAAC8B,IAAI,KAAK,CAAC,IAAI9B,KAAK,CAACkB,MAAM,CAACc,GAAG,EAAE;YACtChC,KAAK,GAAG1C,QAAQ;YAChB;UACJ;;UAEA;UACA0C,KAAK,GAAG3C,KAAK;UACb;QACJ;;QAEA;QACA,IAAI2C,KAAK,CAAC8B,IAAI,KAAK,CAAC,CAAC,IAAIC,KAAK,CAACrD,MAAM,IAAI,CAAC,EAAE;UACxCsB,KAAK,GAAG3C,KAAK;UACb;QACJ;QAEA,OAAO2C,KAAK,CAAC6B,KAAK,GAAGE,KAAK,CAACrD,MAAM,EAAEsB,KAAK,CAAC6B,KAAK,EAAE,EAAE;UAC9C,IAAII,SAAS,GAAG,CAAC,IAAIjC,KAAK,CAAC6B,KAAK;UAEhC,IAAI,CAAC7B,KAAK,CAAC8B,IAAI,GAAGG,SAAS,MAAM,CAAC,EAAE;YAChC;YACA;YACAlB,aAAa,CAACf,KAAK,CAAC;YACpBc,aAAa,CAAC;cACV7B,IAAI,EAAE,cAAc;cACpBiC,MAAM,EAAElB,KAAK,CAACkB,MAAM;cACpBY,IAAI,EAAE9B,KAAK,CAAC8B,IAAI,GAAGG;YACvB,CAAC,CAAC;;YAEF;YACAjC,KAAK,GAAG+B,KAAK,CAAC/B,KAAK,CAAC6B,KAAK,EAAE,CAAC;YAC5B;UACJ;QACJ;QACA;MAEJ,KAAK,cAAc;QACf7B,KAAK,GAAG;UACJf,IAAI,EAAE,iBAAiB;UACvBiC,MAAM,EAAElB,KAAK,CAACkB,MAAM;UACpBW,KAAK,EAAE,CAAC;UACRC,IAAI,EAAE9B,KAAK,CAAC8B;QAChB,CAAC;QACD;MAEJ,KAAK,MAAM;QACP,IAAI9C,KAAK,KAAK,IAAI,EAAE;UAChB,IAAIkD,IAAI,GAAGlD,KAAK,CAACG,KAAK,CAACgD,WAAW,CAAC,CAAC;;UAEpC;UACA,IAAID,IAAI,CAACE,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YAC3BF,IAAI,GAAGA,IAAI,CAACG,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;UACxC;UAEA,IAAIrF,cAAc,CAACsF,IAAI,CAACtC,KAAK,CAACuC,GAAG,EAAEL,IAAI,CAAC,EAAE;YACtClC,KAAK,GAAGA,KAAK,CAACuC,GAAG,CAACL,IAAI,CAAC;YACvB;UACJ;QACJ;QAEAlC,KAAK,GAAG1C,QAAQ;QAChB;MAEJ,KAAK,SAAS;QACV,IAAIgE,IAAI,GAAGV,WAAW,KAAK,IAAI,GAAGA,WAAW,CAACU,IAAI,GAAG,IAAI;QACzD,IAAIkB,cAAc,GAAGrC,UAAU,GAAGsC,IAAI,CAACC,KAAK,CAAC1C,KAAK,CAAC2C,EAAE,CAAC3D,KAAK,EAAEsB,YAAY,EAAEgB,IAAI,CAAC,CAAC;QAEjF,IAAI,CAACsB,KAAK,CAACJ,cAAc,CAAC,IAAIA,cAAc,GAAGrC,UAAU,EAAE;UACvD,OAAOA,UAAU,GAAGqC,cAAc,EAAE;YAChCvB,eAAe,CAAC,CAAC;UACrB;UAEAjB,KAAK,GAAG3C,KAAK;QACjB,CAAC,MAAM;UACH2C,KAAK,GAAG1C,QAAQ;QACpB;QAEA;MAEJ,KAAK,MAAM;MACX,KAAK,UAAU;QACX,IAAIuF,UAAU,GAAG7C,KAAK,CAACf,IAAI,KAAK,MAAM,GAAG,OAAO,GAAG,YAAY;QAC/D,IAAI6D,UAAU,GAAG9F,cAAc,CAACsF,IAAI,CAACrC,QAAQ,EAAE4C,UAAU,CAAC,GAAG5C,QAAQ,CAAC4C,UAAU,CAAC,CAAC7C,KAAK,CAACkC,IAAI,CAAC,GAAG,IAAI;QAEpG,IAAI,CAACY,UAAU,IAAI,CAACA,UAAU,CAACpB,KAAK,EAAE;UAClC,MAAM,IAAIqB,KAAK,CACX,wBAAwB,IACvB/C,KAAK,CAACf,IAAI,KAAK,MAAM,GAChB,GAAG,GAAGe,KAAK,CAACkC,IAAI,GAAG,GAAG,GACtB,KAAK,GAAGlC,KAAK,CAACkC,IAAI,GAAG,KAAK,CACpC,CAAC;QACL;;QAEA;QACA,IAAIf,WAAW,KAAK,KAAK,IAAInC,KAAK,KAAK,IAAI,IAAIgB,KAAK,CAACf,IAAI,KAAK,MAAM,EAAE;UAClE,IAAI+D,mBAAmB;UACnB;UACA;UACA;UACChD,KAAK,CAACkC,IAAI,KAAK,cAAc,IAAIlD,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAACyF,KAAK;UAE3D;UACA;UACA;UACCjD,KAAK,CAACkC,IAAI,KAAK,QAAQ,IAAIlD,KAAK,CAACG,KAAK,KAAK,GAAI;UAEpD,IAAI6D,mBAAmB,EAAE;YACrB,IAAI7B,WAAW,KAAK,IAAI,EAAE;cACtBA,WAAW,GAAGV,uBAAuB,CAACT,KAAK,EAAEgB,SAAS,CAAC;YAC3D;YAEAhB,KAAK,GAAG1C,QAAQ;YAChB;UACJ;QACJ;QAEA+D,UAAU,CAAC,CAAC;QACZrB,KAAK,GAAG8C,UAAU,CAACpB,KAAK;QACxB;MAEJ,KAAK,SAAS;QACV,IAAIQ,IAAI,GAAGlC,KAAK,CAACkC,IAAI;QAErB,IAAIlD,KAAK,KAAK,IAAI,EAAE;UAChB,IAAIkE,WAAW,GAAGlE,KAAK,CAACG,KAAK;;UAE7B;UACA,IAAI+D,WAAW,CAACd,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YAClCc,WAAW,GAAGA,WAAW,CAACb,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;UACtD;UAEA,IAAI9D,8BAA8B,CAAC2E,WAAW,EAAEhB,IAAI,CAAC,EAAE;YACnDjB,eAAe,CAAC,CAAC;YACjBjB,KAAK,GAAG3C,KAAK;YACb;UACJ;QACJ;QAEA2C,KAAK,GAAG1C,QAAQ;QAChB;MAEJ,KAAK,WAAW;MAChB,KAAK,UAAU;QACX,IAAI0B,KAAK,KAAK,IAAI,IAAIT,8BAA8B,CAACS,KAAK,CAACG,KAAK,EAAEa,KAAK,CAACkC,IAAI,CAAC,EAAE;UAC3EjB,eAAe,CAAC,CAAC;UACjBjB,KAAK,GAAG3C,KAAK;UACb;QACJ;QAEA2C,KAAK,GAAG1C,QAAQ;QAChB;MAEJ,KAAK,OAAO;QACR,IAAI0B,KAAK,KAAK,IAAI,IAAIA,KAAK,CAACG,KAAK,KAAKa,KAAK,CAACb,KAAK,EAAE;UAC/C8B,eAAe,CAAC,CAAC;UACjBjB,KAAK,GAAG3C,KAAK;UACb;QACJ;QAEA2C,KAAK,GAAG1C,QAAQ;QAChB;MAEJ,KAAK,OAAO;QACR,IAAI0B,KAAK,KAAK,IAAI,IAAIA,KAAK,CAACC,IAAI,KAAKzB,IAAI,CAAC6B,KAAK,EAAE;UAC7C,IAAID,mBAAmB,CAACuB,UAAU,CAAC3B,KAAK,CAAC,EAAE;YACvCgB,KAAK,GAAG1C,QAAQ;UACpB,CAAC,MAAM;YACH2D,eAAe,CAAC,CAAC;YACjBjB,KAAK,GAAGN,iBAAiB,CAACV,KAAK,CAAC,GAAG1B,QAAQ,GAAGD,KAAK;UACvD;QACJ,CAAC,MAAM;UACH2C,KAAK,GAAGZ,mBAAmB,CAACuB,UAAU,CAAC3B,KAAK,CAAC,IAAIU,iBAAiB,CAACV,KAAK,CAAC,GAAG3B,KAAK,GAAGC,QAAQ;QAChG;QAEA;MAEJ,KAAK,QAAQ;QACT,IAAI6F,MAAM,GAAG,EAAE;QAEf,KAAK,IAAIX,cAAc,GAAGrC,UAAU,EAAEqC,cAAc,GAAGzC,MAAM,CAACrB,MAAM,IAAIyE,MAAM,CAACzE,MAAM,GAAGsB,KAAK,CAACb,KAAK,CAACT,MAAM,EAAE8D,cAAc,EAAE,EAAE;UAC1HW,MAAM,IAAIpD,MAAM,CAACyC,cAAc,CAAC,CAACrD,KAAK;QAC1C;QAEA,IAAIZ,8BAA8B,CAAC4E,MAAM,EAAEnD,KAAK,CAACb,KAAK,CAAC,EAAE;UACrD,OAAOgB,UAAU,GAAGqC,cAAc,EAAE;YAChCvB,eAAe,CAAC,CAAC;UACrB;UAEAjB,KAAK,GAAG3C,KAAK;QACjB,CAAC,MAAM;UACH2C,KAAK,GAAG1C,QAAQ;QACpB;QAEA;MAEJ;QACI,MAAM,IAAIyF,KAAK,CAAC,qBAAqB,GAAG/C,KAAK,CAACf,IAAI,CAAC;IAC3D;EACJ;EAEAhB,mBAAmB,IAAIuD,cAAc;EAErC,QAAQC,UAAU;IACd,KAAK,IAAI;MACL2B,OAAO,CAACC,IAAI,CAAC,8BAA8B,GAAGrF,eAAe,GAAG,aAAa,CAAC;MAC9EyD,UAAU,GAAG1D,2BAA2B;MACxC4C,UAAU,GAAG,IAAI;MACjB;IAEJ,KAAK9C,iBAAiB;MAClB,OAAO+C,WAAW,KAAK,IAAI,EAAE;QACzBW,WAAW,CAAC,CAAC;MACjB;MACA;IAEJ;MACIZ,UAAU,GAAG,IAAI;EACzB;EAEA,OAAO;IACHZ,MAAM,EAAEA,MAAM;IACduD,MAAM,EAAE7B,UAAU;IAClB8B,UAAU,EAAE/B,cAAc;IAC1BE,KAAK,EAAEf,UAAU;IACjBS,YAAY,EAAEA;EAClB,CAAC;AACL;AAEA,SAASoC,WAAWA,CAACzD,MAAM,EAAE5C,UAAU,EAAE8C,QAAQ,EAAE;EAC/C,IAAIwD,WAAW,GAAG3D,aAAa,CAACC,MAAM,EAAE5C,UAAU,EAAE8C,QAAQ,IAAI,CAAC,CAAC,CAAC;EAEnE,IAAIwD,WAAW,CAAC/B,KAAK,KAAK,IAAI,EAAE;IAC5B,IAAIpD,IAAI,GAAGJ,WAAW,CAACuF,WAAW,CAAC/B,KAAK,CAAC,CAACtD,IAAI;IAE9CqF,WAAW,CAAC/B,KAAK,GAAG,EAAE;IAEtB,OAAOpD,IAAI,KAAK,IAAI,EAAE;MAClB,QAAQA,IAAI,CAACW,IAAI;QACb,KAAKxB,IAAI;UACL;QAEJ,KAAKE,WAAW;QAChB,KAAKC,YAAY;UACb6F,WAAW,CAAC/B,KAAK,CAACgC,IAAI,CAAC;YACnBzE,IAAI,EAAEX,IAAI,CAACW,IAAI;YACfiC,MAAM,EAAE5C,IAAI,CAAC4C;UACjB,CAAC,CAAC;UACF;QAEJ;UACIuC,WAAW,CAAC/B,KAAK,CAACgC,IAAI,CAAC;YACnB1E,KAAK,EAAEV,IAAI,CAACU,KAAK,CAACG,KAAK;YACvBwE,IAAI,EAAErF,IAAI,CAACU,KAAK,CAAC2E;UACrB,CAAC,CAAC;UACF;MACR;MAEArF,IAAI,GAAGA,IAAI,CAACF,IAAI;IACpB;EACJ;EAEA,OAAOqF,WAAW;AACtB;AAEA,SAASG,WAAWA,CAAC7D,MAAM,EAAE5C,UAAU,EAAE8C,QAAQ,EAAE;EAC/C,IAAIwD,WAAW,GAAG3D,aAAa,CAACC,MAAM,EAAE5C,UAAU,EAAE8C,QAAQ,IAAI,CAAC,CAAC,CAAC;EAEnE,IAAIwD,WAAW,CAAC/B,KAAK,KAAK,IAAI,EAAE;IAC5B,OAAO+B,WAAW;EACtB;EAEA,IAAInF,IAAI,GAAGmF,WAAW,CAAC/B,KAAK;EAC5B,IAAImC,IAAI,GAAGJ,WAAW,CAAC/B,KAAK,GAAG;IAC3BR,MAAM,EAAE/D,UAAU,CAAC+D,MAAM,IAAI,IAAI;IACjCQ,KAAK,EAAE;EACX,CAAC;EACD,IAAIoC,SAAS,GAAG,CAACD,IAAI,CAAC;;EAEtB;EACAvF,IAAI,GAAGJ,WAAW,CAACI,IAAI,CAAC,CAACF,IAAI;;EAE7B;EACA,OAAOE,IAAI,KAAK,IAAI,EAAE;IAClB,QAAQA,IAAI,CAACW,IAAI;MACb,KAAKtB,WAAW;QACZkG,IAAI,CAACnC,KAAK,CAACgC,IAAI,CAACG,IAAI,GAAG;UACnB3C,MAAM,EAAE5C,IAAI,CAAC4C,MAAM;UACnBQ,KAAK,EAAE;QACX,CAAC,CAAC;QACFoC,SAAS,CAACJ,IAAI,CAACG,IAAI,CAAC;QACpB;MAEJ,KAAKjG,YAAY;QACbkG,SAAS,CAACC,GAAG,CAAC,CAAC;QACfF,IAAI,GAAGC,SAAS,CAACA,SAAS,CAACpF,MAAM,GAAG,CAAC,CAAC;QACtC;MAEJ;QACImF,IAAI,CAACnC,KAAK,CAACgC,IAAI,CAAC;UACZxC,MAAM,EAAE5C,IAAI,CAAC4C,MAAM,IAAI,IAAI;UAC3BlC,KAAK,EAAEV,IAAI,CAACU,KAAK,CAACG,KAAK;UACvBwE,IAAI,EAAErF,IAAI,CAACU,KAAK,CAAC2E;QACrB,CAAC,CAAC;IACV;IAEArF,IAAI,GAAGA,IAAI,CAACF,IAAI;EACpB;EAEA,OAAOqF,WAAW;AACtB;AAEAO,MAAM,CAACC,OAAO,GAAG;EACbT,WAAW,EAAEA,WAAW;EACxBI,WAAW,EAAEA,WAAW;EACxBM,sBAAsB,EAAE,SAAAA,CAAA,EAAW;IAC/B,OAAOjG,mBAAmB;EAC9B;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}